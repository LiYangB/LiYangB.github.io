<!DOCTYPE html>
<html lang='en'>

<head>
  <meta name="generator" content="Hexo 6.2.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://fastly.jsdelivr.net'>
  <link rel="preconnect" href="https://fastly.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>前端面试题 - 个人博客</title>

  
    <meta name="description" content="文件描述: 本文件包括了常见的HTML,CSS,JS,Vue,浏览器与http&#x2F;https,webpack面试题,仅供参考. 一.HTML&#x2F;HTML51.form中input可以设置为readonly与disabled,请问两者有什么区别?1)共同点:  Readonly和Disabled它们都能够做到使用户不能够更改表单域中的内容。 2)区别:   Readonly只针对in">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题">
<meta property="og:url" content="http://example.com/2022/08/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="文件描述: 本文件包括了常见的HTML,CSS,JS,Vue,浏览器与http&#x2F;https,webpack面试题,仅供参考. 一.HTML&#x2F;HTML51.form中input可以设置为readonly与disabled,请问两者有什么区别?1)共同点:  Readonly和Disabled它们都能够做到使用户不能够更改表单域中的内容。 2)区别:   Readonly只针对in">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-08-23T12:26:09.000Z">
<meta property="article:modified_time" content="2022-10-07T13:22:21.322Z">
<meta property="article:author" content="李阳滨">
<meta property="article:tag" content="常见面试题">
<meta name="twitter:card" content="summary">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="title" href="/"><div class="main">个人博客</div></a></div>
<nav class="menu dis-select"></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">TOC</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-HTML-x2F-HTML5"><span class="toc-text">一.HTML&#x2F;HTML5</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-form%E4%B8%ADinput%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E4%B8%BAreadonly%E4%B8%8Edisabled-%E8%AF%B7%E9%97%AE%E4%B8%A4%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">1.form中input可以设置为readonly与disabled,请问两者有什么区别?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-text">1)共同点:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8C%BA%E5%88%AB"><span class="toc-text">2)区别:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFDOCTYPE%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8"><span class="toc-text">2.什么是DOCTYPE及其作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0-%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-text">3.常见的行内元素与块级元素,以及它们的区别与转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0"><span class="toc-text">1)行内元素:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0"><span class="toc-text">2)块级元素:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">3)块级元素和内联元素的区别：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-text">4)块级元素和内联元素之间的转换：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-HTML5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">4.HTML5有哪些新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3HTML5%E7%BB%93%E6%9E%84%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-text">5.如何理解HTML5结构的语义化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE-%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">6.为什么要使用语义化标签(语义化的优点)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-src%E4%B8%8Ehref%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7.src与href的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-img-%E7%9A%84alt%E4%B8%8Etitle-%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C"><span class="toc-text">8.img 的alt与title 有何异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84%E5%9B%BE%E7%89%87-%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99-%EF%BC%8C%E5%8A%A0%E8%BD%BD%E5%BE%88%E6%85%A2%EF%BC%8C%E4%BD%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%BC%98%E5%8C%96%E8%BF%99%E4%BA%9B%E5%9B%BE%E7%89%87%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%8C%E7%BB%99%E7%94%A8%E6%88%B7%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BD%93%E9%AA%8C"><span class="toc-text">9.一个页面上有大量的图片(大型电商网站)，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E8%B0%88%E8%B0%88%E4%BB%A5%E5%89%8D%E7%AB%AF%E8%A7%92%E5%BA%A6%E5%87%BA%E5%8F%91%E5%81%9A%E5%A5%BDSEO%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E4%BB%80%E4%B9%88"><span class="toc-text">10.谈谈以前端角度出发做好SEO需要考虑什么</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%B4%E6%8A%A4%E7%BD%91%E7%AB%99%EF%BC%8C%E6%8F%90%E9%AB%98%E5%86%85%E5%AE%B9%E8%B4%A8%E9%87%8F%EF%BC%8C%E4%BF%9D%E6%8C%81%E6%9B%B4%E6%96%B0"><span class="toc-text">1.维护网站，提高内容质量，保持更新</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BD%91%E7%AB%99%E7%BB%93%E6%9E%84%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%9A%E5%B0%BD%E9%87%8F%E7%AE%80%E5%8D%95%E3%80%81%E5%BC%80%E9%97%A8%E8%A7%81%E5%B1%B1%EF%BC%8C%E6%8F%90%E5%80%A1%E6%89%81%E5%B9%B3%E5%8C%96%E7%BB%93%E6%9E%84%E3%80%82"><span class="toc-text">2.网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8E%A7%E5%88%B6%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">3.控制页面的大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%80%82%E9%87%8F%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8D%E5%92%8C%E7%BD%91%E9%A1%B5%E6%8F%8F%E8%BF%B0"><span class="toc-text">4.适量的关键词和网页描述</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">11.渐进增强和优雅降级之间的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-websocket-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E4%B8%8Ecookie"><span class="toc-text">12.websocket 本地存储与cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4iframe%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-text">13.请你说说iframe有哪些优点和缺点?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-CSS-x2F-CSS3"><span class="toc-text">二.CSS&#x2F;CSS3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-css%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E9%80%89%E6%8B%A9%E5%99%A8-%E5%AE%83%E4%BB%AC%E7%9A%84%E6%9D%83%E9%87%8D%E6%98%AF%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E7%9A%84"><span class="toc-text">1.css有哪些基本选择器?它们的权重是如何表示的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D-%E8%A7%A3%E5%86%B3%E9%AB%98%E5%BA%A6%E5%9D%8D%E5%A1%8C-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">2. 清除浮动带来的影响(解决高度坍塌)有几种方式?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%BA%E7%88%B6%E5%85%83%E7%B4%A0%E5%BC%80%E5%90%AFBFC-%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">1.为父元素开启BFC(块级格式化上下文)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AEclear"><span class="toc-text">2.设置clear</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%80%AA%E5%BC%82%E7%9B%92%E6%A8%A1%E5%9E%8Bbox-sizing-%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9B%92%E5%B8%83%E5%B1%80"><span class="toc-text">3.怪异盒模型box-sizing?弹性盒模型盒布局?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%AA%E5%BC%82%E7%9B%92%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-text">怪异盒模型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%EF%BC%9A%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88%E3%80%82"><span class="toc-text">弹性盒子：布局方案。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-transition-transform-%E5%92%8Canimation%E5%8C%BA%E5%88%AB"><span class="toc-text">4.transition,transform 和animation区别?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-transform-%E5%8F%98%E5%BD%A2"><span class="toc-text">1. transform(变形)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-transition-%E8%BF%87%E6%B8%A1"><span class="toc-text">2. transition(过渡)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-animation-%E5%8A%A8%E7%94%BB"><span class="toc-text">3. animation(动画)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-text">4.总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-css%E5%AE%9E%E7%8E%B0%E5%AD%90%E5%85%83%E7%B4%A0%E5%9C%A8%E7%88%B6%E5%85%83%E7%B4%A0%E4%B8%AD%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">5.css实现子元素在父元素中水平垂直居中的几种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-margin-auto"><span class="toc-text">方法1：使用绝对定位 + margin: auto</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-transform"><span class="toc-text">方法2：使用绝对定位 + transform</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E7%88%B6%E5%85%83%E7%B4%A0%E4%BD%BF%E7%94%A8flex%E5%B8%83%E5%B1%80%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC%E4%B8%BAcenter"><span class="toc-text">方法3：父元素使用flex布局，并设置相关的属性值为center</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%954%EF%BC%9A%E4%BD%BF%E7%94%A8table-cell%E5%AE%9E%E7%8E%B0"><span class="toc-text">方法4：使用table-cell实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A6%82%E6%9E%9C%E5%AF%B9-css%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-text">6.如果对 css进行优化，如何处理?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%86%85%E8%81%94%E9%A6%96%E5%B1%8F%E5%85%B3%E9%94%AECSS%EF%BC%88Critical-CSS%EF%BC%89"><span class="toc-text">1. 内联首屏关键CSS（Critical CSS）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDCSS"><span class="toc-text">2. 异步加载CSS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9"><span class="toc-text">3. 文件压缩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%8E%BB%E9%99%A4%E6%97%A0%E7%94%A8CSS"><span class="toc-text">4. 去除无用CSS</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-CSS3-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">7.CSS3 有哪些新特性?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-text">一、选择器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E8%BE%B9%E6%A1%86"><span class="toc-text">二.边框</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E8%83%8C%E6%99%AF"><span class="toc-text">三.背景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B-%E6%96%87%E5%AD%97"><span class="toc-text">四.文字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94-%E9%A2%9C%E8%89%B2"><span class="toc-text">五.颜色</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AD-transition-%E8%BF%87%E6%B8%A1"><span class="toc-text">六.transition 过渡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%83-transform-%E8%BD%AC%E6%8D%A2"><span class="toc-text">七.transform 转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AB-animation-%E5%8A%A8%E7%94%BB"><span class="toc-text">八.animation 动画</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%9D-%E6%B8%90%E5%8F%98"><span class="toc-text">九.渐变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%81-%E5%B8%83%E5%B1%80"><span class="toc-text">十.布局</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%A7%A3%E9%87%8A-%E4%B8%8BCSS-Sprites-%E4%BB%A5%E5%8F%8A%E4%BD%A0%E8%A6%81%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E6%88%96%E7%BD%91%E7%AB%99%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%83%E3%80%82"><span class="toc-text">8.解释 下CSS Sprites,以及你要如何在页面或网站中使用它。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%88%86%E6%9E%90%E6%AF%94%E8%BE%83opacity-0%E3%80%81visibility-hidden%E3%80%81display-none-%E4%BC%98%E5%8A%A3%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA"><span class="toc-text">9.分析比较opacity:0、visibility:hidden、display:.none 优劣和适用场</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">一.区别：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E6%80%A7%E8%83%BD%EF%BC%9A"><span class="toc-text">二.性能：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%A1%8C%E9%99%B7-x2F-%E5%A4%96%E8%BE%B9%E8%B7%9D%E6%8A%98%E5%8F%A0"><span class="toc-text">10.外边距塌陷&#x2F;外边距折叠?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-text">原因:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3-%E4%B8%BA%E5%85%83%E7%B4%A0%E5%BC%80%E5%90%AFBFC-%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">解决:为元素开启BFC(块级格式化上下文)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E9%87%8D%E6%8E%92-%E5%9B%9E%E6%B5%81-%E5%92%8C%E9%87%8D%E7%BB%98"><span class="toc-text">11.重排(回流)和重绘?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93"><span class="toc-text">一.浏览器渲染</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E5%9B%9E%E6%B5%81"><span class="toc-text">二.回流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E9%87%8D%E7%BB%98"><span class="toc-text">三.重绘</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F"><span class="toc-text">12.常用的几种布局方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9B%BA%E5%AE%9A%E5%B8%83%E5%B1%80"><span class="toc-text">1.固定布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-text">2.流式布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80"><span class="toc-text">3.弹性布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80"><span class="toc-text">4.浮动布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%AE%9A%E4%BD%8D%E5%B8%83%E5%B1%80"><span class="toc-text">5.定位布局</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-css3-%E5%AE%9E%E7%8E%B00-5px%E7%9A%84%E7%BB%86%E7%BA%BF"><span class="toc-text">13.css3 实现0.5px的细线</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E6%B8%90%E5%8F%98%E5%AE%9E%E7%8E%B0"><span class="toc-text">一.渐变实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E4%BD%BF%E7%94%A8%E7%BC%A9%E6%94%BE"><span class="toc-text">二.使用缩放</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-%E7%94%A8%E7%BA%AFCSS%E5%88%9B%E5%BB%BA-%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">14.用纯CSS创建-一个三角形的原理是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-CSS%E6%A0%B7%E5%BC%8F%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%8D%95%E4%BD%8D"><span class="toc-text">15.CSS样式中常用单位?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-px"><span class="toc-text">一.px</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E7%99%BE%E5%88%86%E5%8F%B7"><span class="toc-text">二.百分号 %</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-em"><span class="toc-text">三.em</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B-rem"><span class="toc-text">四.rem</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94-vw%EF%BC%8Cvh%EF%BC%8Cvmin%EF%BC%8Cvmax"><span class="toc-text">五.vw，vh，vmin，vmax</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%80%E4%BB%A5%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8rem-vm%E7%BB%93%E5%90%88%E5%88%B6%E4%BD%9C%E7%A7%BB%E5%8A%A8%E7%AB%AF"><span class="toc-text">所以可以使用rem+vm结合制作移动端:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-CSS3%E7%9A%84Flexbox-%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B"><span class="toc-text">16.请解释一下 CSS3的Flexbox ( 弹性盒布局模型) ?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFflex"><span class="toc-text">1.什么是flex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%B9%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">2.容器属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7"><span class="toc-text">3.项目属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-link-%E4%B8%8E-import%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">17.link 与@import的区别.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-JS"><span class="toc-text">三.JS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">1.值传递和引用传递分别是什么，有什么区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%8E%E6%A0%B7%E6%B7%BB%E5%8A%A0%E3%80%81-%E7%A7%BB%E9%99%A4%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-text">2.怎样添加、 移除、移动、复制、创建和查找节点?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-javascript-%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.javascript 中有几种数据类型?怎么判断数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E6%80%BB%E5%85%B1%E5%85%AB%E7%A7%8D"><span class="toc-text">(一)总共八种</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E9%89%B4%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="toc-text">(二)鉴定方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-var-let-%E5%92%8Cconst%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.var,let 和const之间的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-text">(一)变量提升</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="toc-text">(二)暂时性死区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">(三)块级作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B-%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E"><span class="toc-text">(四)重复声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94-%E4%BF%AE%E6%94%B9%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">(五)修改声明的变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-JavaScript-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">5.JavaScript 数组的常用方法?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%A2%9E"><span class="toc-text">(一)增</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E5%88%A0"><span class="toc-text">(二)删</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E6%94%B9"><span class="toc-text">(三)改</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B-%E6%9F%A5"><span class="toc-text">(四)查</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94-%E6%8E%92%E5%BA%8F"><span class="toc-text">(五)排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AD-%E8%BD%AC%E6%8D%A2"><span class="toc-text">(六)转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%83-%E9%81%8D%E5%8E%86"><span class="toc-text">(七)遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-ES6-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">6.ES6 的新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81let%E5%92%8Cconst"><span class="toc-text">1、let和const</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81symbol"><span class="toc-text">2、symbol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">3、模板字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E8%A7%A3%E6%9E%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">4、解构表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%AF%B9%E8%B1%A1%E6%96%B9%E9%9D%A2"><span class="toc-text">5、对象方面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%87%BD%E6%95%B0%E6%96%B9%E9%9D%A2"><span class="toc-text">6、函数方面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81class%EF%BC%88%E7%B1%BB%EF%BC%89"><span class="toc-text">7、class（类）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81promise"><span class="toc-text">8、promise</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">9、模块化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%99%AE%E9%80%9A-%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7.普通 函数和箭头函数的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E8%AF%AD%E6%B3%95%E6%9B%B4%E5%8A%A0%E7%AE%80%E6%B4%81%E3%80%81%E6%B8%85%E6%99%B0"><span class="toc-text">(一)语法更加简洁、清晰</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89-prototype-%E5%8E%9F%E5%9E%8B-%EF%BC%8C%E6%89%80%E4%BB%A5%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%AC%E8%BA%AB%E6%B2%A1%E6%9C%89this"><span class="toc-text">(二)箭头函数没有 prototype (原型)，所以箭头函数本身没有this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8D%E4%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84this"><span class="toc-text">(三)箭头函数不会创建自己的this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B-call-apply-bind-%E6%97%A0%E6%B3%95%E6%94%B9%E5%8F%98%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-text">(四)call | apply | bind 无法改变箭头函数中this的指向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8"><span class="toc-text">(五)箭头函数不能作为构造函数使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%AF%B4%E4%B8%80%E4%B8%8BPromise"><span class="toc-text">8.说一下Promise?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9A%E4%B9%89"><span class="toc-text">(一)定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E4%BD%BF%E7%94%A8"><span class="toc-text">(二)使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-API"><span class="toc-text">(三)API</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-Async-x2F-await-%E5%AF%B9%E6%AF%94promise%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">9.Async&#x2F;await 对比promise的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-JS%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%EF%BC%8C%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">10.JS中的堆和栈，栈和队列有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AE%83"><span class="toc-text">11.什么是闭包，如何使用它，为什么要使用它?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9A%E4%B9%89-1"><span class="toc-text">(一)定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6"><span class="toc-text">(二)产生条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E4%BD%9C%E7%94%A8"><span class="toc-text">(三)作用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%B0%E5%BA%95%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">12.new 操作符到底到了什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E6%94%B9%E5%8F%98this%E7%9A%84%E6%8C%87%E5%90%91%E4%B8%ADbind%E3%80%81call%E3%80%81-apply-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">13.改变this的指向中bind、call、 apply 的区别.</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-this%E6%8C%87%E5%90%91"><span class="toc-text">(一)this指向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-text">(二)三者区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-javascript-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86"><span class="toc-text">14 .javascript 对象的深度克隆?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">15.如何实现浏览器内多个标签页之间的通信?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8localStorage"><span class="toc-text">第一种——调用localStorage</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8cookie-setInterval"><span class="toc-text">第二种——调用cookie+setInterval()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">16.哪些操作会造成内存泄漏?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">(一)内存溢出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">(二)内存泄露</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E8%B0%88%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">17.谈谈垃圾回收机制方式及内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%E6%98%AF"><span class="toc-text">基本思路是:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%E4%B8%BA"><span class="toc-text">垃圾回收策略为:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">内存管理:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">18. 谈谈你对this对象的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-JS-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB-%E4%BC%AA-%E6%95%B0%E7%BB%84-%E5%A6%82%E4%BD%95%E5%B0%86%E7%B1%BB-%E4%BC%AA-%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="toc-text">19.JS 中什么是类(伪)数组?如何将类(伪)数组转化为数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9A%E4%B9%89-2"><span class="toc-text">(一)定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E8%BD%AC%E6%8D%A2"><span class="toc-text">(二)转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-text">20.什么是事件代理(事件委托) ?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9A%E4%B9%89-3"><span class="toc-text">(一)定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E5%88%86%E6%88%90%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-text">(二)事件传播分成三个阶段：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">(三)事件委托的优点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%88%B6-%E6%98%BE%E5%BC%8F-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">21.什么是强制(显式)类型转换?什么是隐式类型转换?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E8%B0%88%E4%B8%80%E8%B0%88JS%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%82"><span class="toc-text">22.谈一谈JS作用域链。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">(一)作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">(二)作用域链</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3JS%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">23.如何理解JS原型链?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-text">(一)原型(原型对象)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E5%8E%9F%E5%9E%8B%E9%93%BE-%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">(二)原型链(隐式原型链)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E6%9F%A5%E6%89%BE%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-text">(三)查找对象属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-%E8%AF%B4%E4%B8%80%E4%B8%8B-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFeventloop"><span class="toc-text">24.说一下 事件循环eventloop</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><span class="toc-text">主线程和任务队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%EF%BC%9A"><span class="toc-text">同步任务：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%EF%BC%9A"><span class="toc-text">异步任务：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%9D%A5%E8%AF%B4%EF%BC%9A"><span class="toc-text">具体来说：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">25.什么是防抖和节流?有什么区别?如何实现?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E9%98%B2%E6%8A%96"><span class="toc-text">(一)防抖:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E8%8A%82%E6%B5%81"><span class="toc-text">(二)节流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">三、应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-null-%E5%92%8Cundefined%E5%8C%BA%E5%88%AB"><span class="toc-text">26.null 和undefined区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-%E6%89%8B%E5%86%99Ajax%EF%BC%8CXMLHtpRequest"><span class="toc-text">27.手写Ajax，XMLHtpRequest.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-%E8%AF%B7%E8%A7%A3%E9%87%8A%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%E3%80%82"><span class="toc-text">28.请解释变量声明提升。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">29.实现继承的多种方式和优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E7%94%A8%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">(一)用原型链</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">(二)构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">(三)原型链+构造函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-jQuery-%E8%8E%B7%E5%8F%96dom%E5%92%8C%E5%8E%9F%E7%94%9F%E8%8E%B7%E5%8F%96dom%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">30.jQuery 获取dom和原生获取dom有什么区别.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E8%AF%B4%E4%B8%89%E7%A7%8D%E5%8E%BB%E9%99%A4%E4%B8%A4%E7%AB%AF%E7%A9%BA%E6%A0%BC%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">31.说三种去除两端空格的方法?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81replace%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95"><span class="toc-text">1、replace正则匹配方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81trim%E6%96%B9%E6%B3%95"><span class="toc-text">2、trim方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81JQ%E6%96%B9%E6%B3%95%EF%BC%9A-trim-str-%E6%96%B9%E6%B3%95"><span class="toc-text">3、JQ方法：$.trim(str)方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-Vue"><span class="toc-text">四.Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9SPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1.说说你对SPA单页面的理解，它的优缺点分别是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSPA"><span class="toc-text">一、什么是SPA</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SPA%E5%92%8CMPA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">二、SPA和MPA的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">单页应用优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%9B%B4%E6%8E%A5%E7%BB%99%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E9%A1%B9%E8%B5%8B%E5%80%BC-Vue-%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E5%8F%98%E5%8C%96%E5%90%97"><span class="toc-text">2.直接给一个数组项赋值,Vue 能检测到变化吗?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-Vue-set-target-key-value-vm-set"><span class="toc-text">(一)Vue.set(target,key,value)||vm.$set()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E8%B0%83%E7%94%A8Vue%E5%B7%B2%E7%BB%8F%E5%B0%81%E8%A3%85%E5%A5%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">(二)调用Vue已经封装好的方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%86%85%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-text">3.在哪个生命周期内调用异步请求?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%83%BD%E8%AF%B4%E4%B8%8Bvue-router-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84hash-%E5%92%8Chistory-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%90%97"><span class="toc-text">4.能说下vue-router 中常用的hash 和history 路由模式实现原理吗?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-hash%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">1. hash模式实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-history%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">2. history模式的实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-history%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">3. history的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-nextTick%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-text">5.nextTick适用场景和原理?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-text">1.使用原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BA%94%E7%94%A8"><span class="toc-text">2.应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">3.场景：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-vue-cli-%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%84%E4%BB%B6-%E6%9C%89%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%E5%90%97"><span class="toc-text">6.vue-cli 用自定义的组件?有遇到过哪些问题吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-vue-delete-%E5%92%8Cdelete-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7.vue.delete 和delete 的区别.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Vue-%E4%B8%ADMVVM"><span class="toc-text">8.Vue 中MVVM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-vue%E7%9A%84diff%E7%90%86%E8%A7%A3"><span class="toc-text">9.vue的diff理解.</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9A%E4%B9%89-4"><span class="toc-text">(一)定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E7%89%B9%E7%82%B9"><span class="toc-text">(二)特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E8%BF%87%E7%A8%8B"><span class="toc-text">(三)过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E5%88%97%E8%A1%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%86%99key-%E5%85%B6%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">10.为什么要在列表组件中写key,其作用是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%99%9A%E6%8B%9FDOM%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-text">1.虚拟DOM中key的作用：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AF%B9%E6%AF%94%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-text">2.对比规则：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%94%A8index%E4%BD%9C%E4%B8%BAkey%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">3.用index作为key可能会引发的问题：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9key"><span class="toc-text">4.开发中如何选择key?:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E6%8B%9Fdom%E4%BC%9A%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD"><span class="toc-text">11.为什么虚拟dom会提高性能?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89vue-router%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1-%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%BC%A0%E9%80%92%E8%BF%87%E6%9D%A5%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-text">12.怎么定义vue router的动态路由?怎么获取传递过来的动态参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E4%BC%A0query%E5%8F%82%E6%95%B0"><span class="toc-text">(一)传query参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E4%BC%A0params%E5%8F%82%E6%95%B0"><span class="toc-text">(二)传params参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-query-%E5%92%8C-params-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">(三)query 和 params 之间的区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-vue-router%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90-%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="toc-text">13.vue -router有哪几种导航钩子(路由守卫)?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%85%A8%E5%B1%80%E5%AE%88%E5%8D%AB"><span class="toc-text">(一)全局守卫</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E7%8B%AC%E4%BA%AB%E5%AE%88%E5%8D%AB"><span class="toc-text">(二)独享守卫</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E7%BB%84%E4%BB%B6%E5%AE%88%E5%8D%AB"><span class="toc-text">(三)组件守卫</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-v-model-%E6%98%AF%E4%BB%80%E4%B9%88-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8"><span class="toc-text">14.v-model 是什么?怎么使用?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4-v-check%E3%80%81-v-focus-%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B-%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">15.自定义指令(v-check、 v-focus) 的方法有哪些?它有哪些钩子函数?有哪些钩子函数参数?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%B1%80%E9%83%A8%E6%8C%87%E4%BB%A4-%E5%86%99%E5%9C%A8%E9%85%8D%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%84directives%E4%B8%AD"><span class="toc-text">(一)局部指令(写在配置对象的directives中)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E5%85%A8%E5%B1%80%E6%8C%87%E4%BB%A4"><span class="toc-text">(二)全局指令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-vue-router-%E6%98%AF%E4%BB%80%E4%B9%88-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">16.vue-router 是什么?怎么使用？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E4%BD%BF%E7%94%A8"><span class="toc-text">(一)使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-vue%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">17.vue的双向数据绑定原理是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="toc-text">具体步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-defineProperty"><span class="toc-text">Object.defineProperty</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-v-show-%E5%92%8Cv-if%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-text">18.v-show 和v-if指令的共同点和不同点?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%85%B1%E5%90%8C%E7%82%B9-1"><span class="toc-text">1.共同点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8C%BA%E5%88%AB-1"><span class="toc-text">2.区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">3.应用场景：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-vue-%E7%9A%84%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">19.vue 的父组件和子组件生命周期钩子执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-text">20.组件中的data为什么是函数?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-vue-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">21.vue 组件通信的方式有哪些?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-props"><span class="toc-text">(一)props</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-text">(二)自定义事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF"><span class="toc-text">(三)全局事件总线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B-%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83"><span class="toc-text">(四)消息订阅与发布</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94-Vuex"><span class="toc-text">(五)Vuex</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-vue-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">22.vue 常用指令有哪些?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-watch%E3%80%81-computed%E3%80%81-filters-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">23.watch、 computed、 filters 的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%90%86%E8%A7%A3"><span class="toc-text">24.vue生命周期理解?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">生命周期有哪些</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-text">使用场景分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E5%9C%A8created%E5%92%8Cmouted%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">数据请求在created和mouted的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%81%BF%E5%85%8Dv-if%E5%92%8Cv-for%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">25.为什么避免v-if和v-for用在一起?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-webpack"><span class="toc-text">五.webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9C%A8%E4%BD%BF%E7%94%A8webpack%E6%97%B6-%E4%BD%A0%E9%83%BD%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88"><span class="toc-text">1.在使用webpack时,你都做些什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-wepack-%E4%B8%ADloader%E5%92%8Cplugin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.wepack 中loader和plugin的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B4%E8%AF%B4webpack%E6%89%93%E5%8C%85%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">3.说说webpack打包的流程</span></a></li></ol></li></ol></div></div></div>


</div>


    </aside>
    <div class='l_main'>
      

      

<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a><span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a></div><div id="post-meta">Posted on&nbsp;<time datetime="2022-08-23T12:26:09.000Z">2022-08-23</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>前端面试题</span></h1>
<p>文件描述:</p>
<p>本文件包括了常见的HTML,CSS,JS,Vue,浏览器与http&#x2F;https,webpack面试题,仅供参考.</p>
<h3 id="一-HTML-x2F-HTML5"><a href="#一-HTML-x2F-HTML5" class="headerlink" title="一.HTML&#x2F;HTML5"></a>一.HTML&#x2F;HTML5</h3><h4 id="1-form中input可以设置为readonly与disabled-请问两者有什么区别"><a href="#1-form中input可以设置为readonly与disabled-请问两者有什么区别" class="headerlink" title="1.form中input可以设置为readonly与disabled,请问两者有什么区别?"></a>1.form中input可以设置为readonly与disabled,请问两者有什么区别?</h4><h5 id="1-共同点"><a href="#1-共同点" class="headerlink" title="1)共同点:"></a>1)共同点:</h5><p>  Readonly和Disabled它们都能够做到使用户不能够更改表单域中的内容。</p>
<h5 id="2-区别"><a href="#2-区别" class="headerlink" title="2)区别:"></a>2)区别:</h5><p>   Readonly只针对input(text &#x2F; password)和textarea有效，而disabled对于所有的表单元素都有效，但是表单元素在使用了disabled后，当我们将表单以POST或GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去（ readonly接受值更改可以回传，disable接受改但不回传数据）。</p>
<h4 id="2-什么是DOCTYPE及其作用"><a href="#2-什么是DOCTYPE及其作用" class="headerlink" title="2.什么是DOCTYPE及其作用"></a>2.什么是DOCTYPE及其作用</h4><p>DOCTYPE是document type的简写，它是一种标记语言的文档类型声明，即告诉浏览器当前 HTML 是用什么版本编写的。</p>
<h4 id="3-常见的行内元素与块级元素-以及它们的区别与转换"><a href="#3-常见的行内元素与块级元素-以及它们的区别与转换" class="headerlink" title="3.常见的行内元素与块级元素,以及它们的区别与转换"></a>3.常见的行内元素与块级元素,以及它们的区别与转换</h4><h5 id="1-行内元素"><a href="#1-行内元素" class="headerlink" title="1)行内元素:"></a>1)行内元素:</h5><p>a - 锚点<br>select - 项目选择<br>span - 常用内联容器，定义文本内区块<br>strong - 粗体强调<br>img - 图片<br>input - 输入框<br>label - 表格标签<br>textarea - 多行文本输入框<br>br - 换行</p>
<h5 id="2-块级元素"><a href="#2-块级元素" class="headerlink" title="2)块级元素:"></a>2)块级元素:</h5><p>div<br>ul ,li 非排序列表<br>form - 交互表单<br>table - 表格<br>h1 -h6 标题<br>hr - 水平分隔线<br>p - 段落<br>dl -dt-dd - 定义列表<br>address - 地址<br>blockquote - 块引用<br>fieldset - form控制组</p>
<h5 id="3-块级元素和内联元素的区别："><a href="#3-块级元素和内联元素的区别：" class="headerlink" title="3)块级元素和内联元素的区别："></a>3)块级元素和内联元素的区别：</h5><p>  (1).块级元素，宽度默认是它容器的100%,各占据一行，垂直方向排列；内联元素，都是同一行，水平方向排列；<br>  (2).块级元素，能容纳其他块元素或者内联元素；内联元素，只能容纳文本或其他内联元素；<br>  (3).块级元素中height，line-height以及margin和padding都可以控制；行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效</p>
<h5 id="4-块级元素和内联元素之间的转换："><a href="#4-块级元素和内联元素之间的转换：" class="headerlink" title="4)块级元素和内联元素之间的转换："></a>4)块级元素和内联元素之间的转换：</h5><p>(1)display<br>  块元素默认display:block;行内非替换元素(a,span)默认为display：inline;行内替换元素(input)默认为display:inline-block;<br>a.display:none;不显示该元素，也不会保留该元素原先占有的文档流位置。<br>b.display:block;转换为块级元素。<br>c.display:inline;转换为行内元素。<br>d.display:inline-block;转换为行内块级元素。<br>(2).float<br>  当把行内元素设置完float:left&#x2F;right后，该行内元素的display属性会被赋予block值，且拥有浮动特性。行内元素去除了之间的莫名空白。<br>(3).position<br>  当为行内元素进行定位时，position:absolute与position:fixed.都会使得原先的行内元素变为块级元素。</p>
<h4 id="4-HTML5有哪些新特性"><a href="#4-HTML5有哪些新特性" class="headerlink" title="4.HTML5有哪些新特性"></a>4.HTML5有哪些新特性</h4><ul>
<li>新的语义元素，比如 [header&gt;, [footer&gt;, [article&gt;, and [section&gt;。</li>
<li>新的表单控件，比如数字、日期、时间、日历和滑块。</li>
<li>强大的图像支持（借由 [canvas&gt; 和 [svg&gt;）</li>
<li>强大的多媒体支持（借由 [video&gt; 和 [audio&gt;）</li>
<li>强大的新 API，比如:<ul>
<li>用webStorage储存机制取代 cookie。</li>
<li>HTML5 地理定位</li>
</ul>
</li>
</ul>
<h4 id="5-如何理解HTML5结构的语义化"><a href="#5-如何理解HTML5结构的语义化" class="headerlink" title="5.如何理解HTML5结构的语义化"></a>5.如何理解HTML5结构的语义化</h4><p>HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构，如 header,footer,nav，从标签上即可以直观的知道这个标签的作用，而不是滥用div.</p>
<h4 id="6-为什么要使用语义化标签-语义化的优点"><a href="#6-为什么要使用语义化标签-语义化的优点" class="headerlink" title="6.为什么要使用语义化标签(语义化的优点)"></a>6.为什么要使用语义化标签(语义化的优点)</h4><p>为了更容易让屏幕阅读器读出内容，使网页结构更清晰，更容易被搜索引擎搜入，也为了在实际开发过程中一些团队合作的方便，HTML5新推出了一系列语义化标签如[hearder&gt;&#x2F;[footer&gt;&#x2F;[main&gt;等</p>
<h4 id="7-src与href的区别"><a href="#7-src与href的区别" class="headerlink" title="7.src与href的区别"></a>7.src与href的区别</h4><p><strong>href</strong>标识超文本引用，用在<strong>link</strong>和<strong>a</strong>等元素上，<strong>href</strong>是引用和页面关联，是在当前元素和引用资源之间建立联系</p>
<p><strong>src</strong>表示引用资源，表示替换当前元素，用在<strong>img</strong>，<strong>script</strong>，<strong>iframe</strong>上，src是页面内容不可缺少的一部分。</p>
<h4 id="8-img-的alt与title-有何异同"><a href="#8-img-的alt与title-有何异同" class="headerlink" title="8.img 的alt与title 有何异同"></a>8.img 的alt与title 有何异同</h4><p>alt属性和title属性相同点：<br>    它们都会出现浮层，显示自己设置的图片相关的内容。<br>alt属性和title属性不同点：<br>    alt属性:1.当图片加载不出来的时候，就会在图片未显示的地方出现一段alt设置的属性内容。这个属性的作用是为了给未加载的图片显示提示信息，即使在网络比较差的时候，用户也可以知道图片的内容，方便用户浏览网页。同时在程序员对网站维护的时候也能更快的查找到问题。2.浏览器的搜索引擎可以通过alt属性的文字描述来获取图片。<br>    title属性：title属性可以用在任何的元素上，当用户把鼠标移动到元素上时，就会显示预先设置的title的内容，起到对图片说明的作用，实质上就是对图片的解释和备注。</p>
<h4 id="9-一个页面上有大量的图片-大型电商网站-，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验"><a href="#9-一个页面上有大量的图片-大型电商网站-，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验" class="headerlink" title="9.一个页面上有大量的图片(大型电商网站)，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验"></a>9.一个页面上有大量的图片(大型电商网站)，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</h4><p>1.图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</p>
<p>2.如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</p>
<p>3.如果图片为css图片，可以使用Base64等技术。</p>
<p>4.如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</p>
<h4 id="10-谈谈以前端角度出发做好SEO需要考虑什么"><a href="#10-谈谈以前端角度出发做好SEO需要考虑什么" class="headerlink" title="10.谈谈以前端角度出发做好SEO需要考虑什么"></a>10.谈谈以前端角度出发做好SEO需要考虑什么</h4><h5 id="1-维护网站，提高内容质量，保持更新"><a href="#1-维护网站，提高内容质量，保持更新" class="headerlink" title="1.维护网站，提高内容质量，保持更新"></a>1.维护网站，提高内容质量，保持更新</h5><p>搜索引擎会考评网站的质量，保持网站的经常更新，使网站拥有大量的、有用的、可读性强的优质信息。网站的权重会相应的提升。为了保持更新频率而去抄袭并不可取。</p>
<h5 id="2-网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。"><a href="#2-网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。" class="headerlink" title="2.网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。"></a>2.网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。</h5><p>一般而言，建立的网站结构层次越少，越容易被“蜘蛛”抓取，也就容易被收录。一般中小型网站目录结构超过三级，“蜘蛛”便不愿意往下爬，并且根据相关调查：访客如果经过跳转3次还没找到需要的信息，很可能离开。因此，三层目录结构也是体验的需要。</p>
<h5 id="3-控制页面的大小"><a href="#3-控制页面的大小" class="headerlink" title="3.控制页面的大小"></a>3.控制页面的大小</h5><p>减少http请求，提高网站的加载速度。当速度很慢时，用户体验不好，留不住访客，并且一旦超时，“蜘蛛”也会离开</p>
<h5 id="4-适量的关键词和网页描述"><a href="#4-适量的关键词和网页描述" class="headerlink" title="4.适量的关键词和网页描述"></a>4.适量的关键词和网页描述</h5><p>1.title标题：只强调重点即可，尽量把重要的关键词放在前面，关键词不要重复出现，尽量做到每个页面的title标题中不要设置相同的内容。</p>
<p>2.meta keywords标签：关键词，列举出几个页面的重要关键字即可，切记过分堆砌。</p>
<p>3.meta description标签：网页描述，需要高度概括网页内容，切记不能太长，过分堆砌关键词，每个页面也要有所不同。</p>
<p>4.a标签：页内链接，要加 “title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上 el&#x3D;”nofollow” 属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。</p>
<p>5.img应使用 “alt” 属性加以说明。为图片加上alt属性,当网络速度很慢，或者图片地址失效的时候，就可以体现出alt属性的作用，他可以让用户在图片没有显示的时候知道这个图片的作用。</p>
<h4 id="11-渐进增强和优雅降级之间的区别"><a href="#11-渐进增强和优雅降级之间的区别" class="headerlink" title="11.渐进增强和优雅降级之间的区别?"></a>11.渐进增强和优雅降级之间的区别?</h4><p>渐进增强 ： 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
<p>优雅降级 ： 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<p>区别： 优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</p>
<h4 id="12-websocket-本地存储与cookie"><a href="#12-websocket-本地存储与cookie" class="headerlink" title="12.websocket 本地存储与cookie"></a>12.websocket 本地存储与cookie</h4><p>通过本地存储（Local Storage），web 应用程序能够在用户浏览器中对数据进行本地的存储。存放数据大小为一般为5MB,.只能存储字符串类型,对于复杂的对象可以使用JS提供的JSON对象的stringify和parse来处理。</p>
<p>1.localStorage 对象存储的是没有截止日期的数据。当浏览器被关闭时数据不会被删除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;lastname&quot;</span>, <span class="string">&quot;Gates&quot;</span>);</span><br><span class="line"><span class="comment">// 取回</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;result&quot;</span>).<span class="property">innerHTML</span> = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;lastname&quot;</span>);</span><br><span class="line"><span class="comment">//移除</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&quot;lastname&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>2.sessionStorage 对象等同 localStorage 对象，不同之处在于只对一个 session 存储数据。如果用户关闭具体的浏览器标签页，数据也会被删除。</p>
<p>3.cookie为HTTP请求发送Set-Cookie HTTP头作为响应的一部分。生命期为只在设置的cookie过期时间之前一直有效(一般默认是浏览器关闭失效,可以自己设置失效时间)，即使窗口或浏览器关闭。 存放数据大小为4K左右 。</p>
<h4 id="13-请你说说iframe有哪些优点和缺点"><a href="#13-请你说说iframe有哪些优点和缺点" class="headerlink" title="13.请你说说iframe有哪些优点和缺点?"></a>13.请你说说iframe有哪些优点和缺点?</h4><p><strong>优点</strong> <strong>:</strong>  </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.iframe</span>能够把嵌入的网页原样展现出来；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.模块分离，便于更改，如果有多个网页引用<span class="selector-tag">iframe</span>，只需要修改<span class="selector-tag">iframe</span>的内容，就可以实现调用的每一个页面内容的更改，方便快捷；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用<span class="selector-tag">iframe</span>来嵌套，增加代码的可重用；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由<span class="selector-tag">iframe</span>来解决；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.重载页面时不需要重载整个页面，只需要重载页面中的一个框架页；</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.方便制作导航栏。</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong> <strong>:</strong>  </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.样式和脚本需要额外链入，调用外部页面,需要额外调用css,增加页面额外的请求次数，增加服务器的http请求；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.代码复杂，在网页中使用框架结构最大的弊病是搜索引擎的“蜘蛛”程序无法解读这种页面，会影响搜索引擎优化，不利于网站排名；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.框架结构有时会让人感到迷惑，滚动条除了会挤占有限的页面空间外会使<span class="selector-tag">iframe</span>布局混乱，还会分散访问者的注意力，影响用户体验；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.链接导航疑问。运用框架结构时，必须保证正确配置所有的导航链接，否则，会给访问者带来很大的麻烦。比如被链接的页面出现在导航框架内，这种情况下访问者便被陷住了，因为此时他没有其他地点可去； </span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.产生多个页面，不易管理；</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.多数小型的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。</span><br></pre></td></tr></table></figure>

<h3 id="二-CSS-x2F-CSS3"><a href="#二-CSS-x2F-CSS3" class="headerlink" title="二.CSS&#x2F;CSS3"></a>二.CSS&#x2F;CSS3</h3><h4 id="1-css有哪些基本选择器-它们的权重是如何表示的"><a href="#1-css有哪些基本选择器-它们的权重是如何表示的" class="headerlink" title="1.css有哪些基本选择器?它们的权重是如何表示的?"></a>1.css有哪些基本选择器?它们的权重是如何表示的?</h4><table>
<thead>
<tr>
<th>id 选择器</th>
<th>0,1,0,0</th>
<th>2</th>
</tr>
</thead>
<tbody><tr>
<td>类、伪类、属性选择器</td>
<td>0,0,1,0</td>
<td>3</td>
</tr>
<tr>
<td>标签、伪元素选择器</td>
<td>0,0,0,1</td>
<td>4</td>
</tr>
<tr>
<td>通配符选择器</td>
<td>0,0,0,0</td>
<td>5</td>
</tr>
</tbody></table>
<p><strong>后代选择器、子选择器、兄弟选择器、交集选择器</strong>：所有的基础选择器的权重相加</p>
<p><strong>并集选择器</strong>：相当于多个选择器一起设置样式，权重分开计算即可。</p>
<h4 id="2-清除浮动带来的影响-解决高度坍塌-有几种方式"><a href="#2-清除浮动带来的影响-解决高度坍塌-有几种方式" class="headerlink" title="2. 清除浮动带来的影响(解决高度坍塌)有几种方式?"></a>2. 清除浮动带来的影响(解决高度坍塌)有几种方式?</h4><h5 id="1-为父元素开启BFC-块级格式化上下文"><a href="#1-为父元素开启BFC-块级格式化上下文" class="headerlink" title="1.为父元素开启BFC(块级格式化上下文)"></a>1.为父元素开启BFC(块级格式化上下文)</h5><h6 id="1-BFC特点"><a href="#1-BFC特点" class="headerlink" title="1)BFC特点:"></a>1)BFC特点:</h6><p>①开启BFC的元素不会被浮动元素覆盖</p>
<p>②开启BFC的父元素与其子元素外边距不会重叠(可以用来解决外边距重叠问题)</p>
<p>③开启BFC的元素可以包含浮动的子元素</p>
<h6 id="2-如何开启BFC"><a href="#2-如何开启BFC" class="headerlink" title="2)如何开启BFC"></a>2)如何开启BFC</h6><p>1、float的值不是none。<br>2、position的值不是static或者relative。<br>3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex<br>4、overflow的值不是visible</p>
<h5 id="2-设置clear"><a href="#2-设置clear" class="headerlink" title="2.设置clear"></a>2.设置clear</h5><p>1).原理:（给子元素设置clear:both相当于给它自动设置了1个mrgin-top外边距从而可以撑开父盒子高度）</p>
<p>2)实现:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//给父元素设置一个clearfix的class</span><br><span class="line"><span class="selector-class">.clearfix</span>::brfore,</span><br><span class="line">.clearfix::after&#123;</span><br><span class="line">	<span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">	dispaly:table;</span><br><span class="line">	<span class="attribute">clear</span>:both</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-怪异盒模型box-sizing-弹性盒模型盒布局"><a href="#3-怪异盒模型box-sizing-弹性盒模型盒布局" class="headerlink" title="3.怪异盒模型box-sizing?弹性盒模型盒布局?"></a>3.怪异盒模型box-sizing?弹性盒模型盒布局?</h4><h5 id="怪异盒模型："><a href="#怪异盒模型：" class="headerlink" title="怪异盒模型："></a>怪异盒模型：</h5><p>   box-sizing:<br>        属性值：<br>            box-sizing:content-box;  常规盒模型<br>            box-sizing:border-box:   怪异盒模型（IE盒模型）<br>        怪异盒模型特点：padding和border都会在元素的宽高的内部，不会把盒子撑大。</p>
<h5 id="弹性盒子：布局方案。"><a href="#弹性盒子：布局方案。" class="headerlink" title="弹性盒子：布局方案。"></a>弹性盒子：布局方案。</h5><p>​        作用：控制离它最近的一层子元素的布局方式。<br>​        特点：<br>​            a：弹性盒子里面的离它最近的一层子元素都可以添加大小。<br>​            b: 如果想让弹性盒子里面的一个子元素左右上下居中，只需要给子元素添加margin:auto即可<br>​            c: 弹性盒子里面的子元素都是沿着“主轴”排列</p>
<p>一：触发弹性盒子：<br>        display:flex;</p>
<p>二：改变主轴的方向：<br>        flex-direction:<br>            属性值：<br>                row     (默认值：X轴(自左向右)为主轴)<br>                row-reverse    (以X轴为主轴反向排列)<br>                column  (Y轴(自上向下)为主轴)<br>                column-reverse    (以Y轴为主轴反向排列)</p>
<p>三：改变主轴的对齐方式：<br>        justify-content:<br>            属性值：<br>                flex-start   默认状态：在弹性盒子开始的地方显示<br>                flex-end     在弹性盒子末端对齐<br>                center        居中对齐<br>                space-between    两端对齐<br>                space-around     自动分配间距<br>    四：侧轴的对齐方式:<br>        align-items:<br>            flex-start    侧轴开始的位置<br>            flex-end      侧轴结束的位置<br>            center        侧轴居中的位置<br>            baseline      基线（flex-start等效）<br>            stretch（默认值）   拉伸<br>    五：控制弹性盒子里面的子元素（灵活元素）换行处理：<br>        flex-wrap:<br>            wrap         换行<br>            nowrap       不换行<br>            wrap-reverse   反向换行<br>    六：控制行与行的对齐方式：<br>        align-content:<br>                flex-start   默认状态：行与行之间不存在默认的行间距<br>                flex-end     在弹性盒子末端对齐<br>                center        居中对齐<br>                space-between    两端对齐<br>                space-around     自动分配间距<br>    七：补充：flex-direction 和 flex-wrap简写：<br>        flex-flow:;<br>    注：以上7个属性全部添加在父元素弹性盒子上面！！！！！！！！！！！！！</p>
<p>添加在子元素上面的属性：</p>
<p>一：控制弹性盒子里面 某个 灵活元素 在侧轴的对齐方式。<br>        align-self:<br>            auto  默认值。元素继承了它的父容器的 align-items 属性。如果没有父容器则为 “stretch”。<br>            Stretch 元素被拉伸以适应容器。<br>            Center 元素位于容器的中心。<br>            flex-start 元素位于容器的开头。<br>            flex-end 元素位于容器的结尾。<br>    二：控制子元素的排列顺序：<br>        order: 数值越大越往后排列。支持负数。<br>    三：剩余空间的分配：<br>        flex:1;  分配主轴剩余空间。<br>    flex:1;  简写形式。</p>
<p>flex-grow:;      扩展的量<br>            flex-shrink:;    收缩的量<br>            flex-basis:;     元素的大小<br>    记住：flex-shrink:0;  不压缩。<br> 多列属性：</p>
<p>1：列数：<br>            column-count:;</p>
<p>2:列间距：<br>            column-gap:;</p>
<p>3:列分割线：<br>            column-rule:</p>
<p>4:控制每一列的列的高度是否统一：<br>            column-fill:;<br>                auto     列高度自适应内容<br>                balance  有列的高度以其中最高的一列统一</p>
<p>5:跨列：<br>            column-span:all;</p>
<p>6:列宽<br>            column-width:</p>
<p>7:columns: 7<br>            column-count 和 column-width  简写</p>
<h4 id="4-transition-transform-和animation区别"><a href="#4-transition-transform-和animation区别" class="headerlink" title="4.transition,transform 和animation区别?"></a>4.transition,transform 和animation区别?</h4><h5 id="1-transform-变形"><a href="#1-transform-变形" class="headerlink" title="1. transform(变形)"></a>1. transform(变形)</h5><h6 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义:"></a>1.1 定义:</h6><p>transform<code>主要用于给元素做变换,主要由以下几种变换,</code>rotate<code>(旋转),</code>scale<code>(缩放),</code>skew<code>(扭曲),</code>translate<code>(移动)和</code>matrix&#96;(矩阵变换).</p>
<h6 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h6><p>1)使用<code>transition</code>和<code>position: absolute;</code>结合实现水平垂直居中:</p>
<p>2)定义放大,旋转,倾斜,矩阵变换等交互效果:</p>
<h5 id="2-transition-过渡"><a href="#2-transition-过渡" class="headerlink" title="2. transition(过渡)"></a>2. transition(过渡)</h5><h6 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h6><p>用来定义某个css属性或者多个css属性的变化的过渡效果.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: property duration timing-function delay;</span><br></pre></td></tr></table></figure>

<p>属性定义及使用说明:</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transition-property</td>
<td>指定CSS属性的name，transition效果: 大小,位置,扭曲等</td>
</tr>
<tr>
<td>transition-duration</td>
<td>规定完成过渡效果需要花费的时间（以秒或毫秒计）。 默认值是 0，意味着不会有效果。</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>指定transition效果的转速曲线</td>
</tr>
<tr>
<td>transition-delay</td>
<td>定义transition效果开始的时候</td>
</tr>
</tbody></table>
<h6 id="2-2-使用场景"><a href="#2-2-使用场景" class="headerlink" title="2.2 使用场景"></a>2.2 使用场景</h6><p>1)实现激活状态的过渡效果(宽度和透明度变化):</p>
<p>2)transition和transform结合实现动画过渡</p>
<h5 id="3-animation-动画"><a href="#3-animation-动画" class="headerlink" title="3. animation(动画)"></a>3. animation(动画)</h5><h6 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h6><p>animation动画的定义,先通过@(-webkit-)keyframes定义动画名称及动画的行为,然后再通过animation的相关属性定义动画的执行效果.</p>
<p><strong>语法:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation: name duration timing-function delay iteration-count direction fill-mode play-state;</span><br></pre></td></tr></table></figure>

<p>用来定义多个中间态的一系列的动画过渡效果.</p>
<p><strong>属性定义及使用说明:</strong></p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>animation-name</td>
<td>指定要绑定到选择器的关键帧的名称</td>
</tr>
<tr>
<td>animation-duration</td>
<td>规动画指定需要多少秒或毫秒完成</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>设置动画将如何完成一个周期</td>
</tr>
<tr>
<td>animation-delay</td>
<td>设置动画在启动前的延迟间隔</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>定义动画的播放次数</td>
</tr>
<tr>
<td>animation-direction</td>
<td>指定是否应该轮流反向播放动画</td>
</tr>
<tr>
<td>animation-fill-mode</td>
<td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式</td>
</tr>
<tr>
<td>animation-play-state</td>
<td>指定动画是否正在运行或已暂停</td>
</tr>
</tbody></table>
<h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h5><p>transform, transition 和animation的区别:</p>
<ul>
<li>transform本身是没有过渡效果的,它只是对元素做大小,旋转,倾斜等各种变换,通过和transition或者animation相结合,可以让这一变换过程具有动画的效果,它通常只有一个到达态,中间态的过渡可以通过和transition或者animation相结合实现,也可以通过js设置定时器来实现.</li>
<li>transition一般是定义单个或多个css属性发生变化时的过渡动画,比如width,opacity等.当定义的css属性发生变化的时候才会执行过渡动画,animation动画一旦定义,就会在页面加载完成后自动执行.</li>
<li>transition定义的动画触发一次执行一次,想要再次执行想要再次触发.animation定义的动画可以指定播放次数或者无限循环播放. transition: 需要用户操作,执行次数固定.</li>
<li>transition定义的动画只有两个状态,开始态和结束态,animation可以定义多个动画中间态,且可以控制多个复杂动画的有序执行.</li>
</ul>
<h4 id="5-css实现子元素在父元素中水平垂直居中的几种方法"><a href="#5-css实现子元素在父元素中水平垂直居中的几种方法" class="headerlink" title="5.css实现子元素在父元素中水平垂直居中的几种方法"></a>5.css实现子元素在父元素中水平垂直居中的几种方法</h4><h5 id="方法1：使用绝对定位-margin-auto"><a href="#方法1：使用绝对定位-margin-auto" class="headerlink" title="方法1：使用绝对定位 + margin: auto"></a>方法1：使用绝对定位 + margin: auto</h5><p>适用于:父子元素宽高都未知时。</p>
<p>父元素开启定位,给子元素添加如下样式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">margin</span>:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法2：使用绝对定位-transform"><a href="#方法2：使用绝对定位-transform" class="headerlink" title="方法2：使用绝对定位 + transform"></a>方法2：使用绝对定位 + transform</h5><p>适用于:父子元素都不确定宽高的情况。</p>
<p>父元素开启定位,给子元素添加如下样式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="方法3：父元素使用flex布局，并设置相关的属性值为center"><a href="#方法3：父元素使用flex布局，并设置相关的属性值为center" class="headerlink" title="方法3：父元素使用flex布局，并设置相关的属性值为center"></a>方法3：父元素使用flex布局，并设置相关的属性值为center</h5><p>这种方式要求父元素的高度是确定的，百分比形式的高度将不能生效。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="方法4：使用table-cell实现"><a href="#方法4：使用table-cell实现" class="headerlink" title="方法4：使用table-cell实现"></a>方法4：使用table-cell实现</h5><p>这种方式需要父元素的宽高都是确定的，才能保证子元素在父元素中垂直水平都居中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">    height: 500px;</span><br><span class="line">    width: 500px;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line">.son&#123;</span><br><span class="line">    margin:0 auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-如果对-css进行优化，如何处理"><a href="#6-如果对-css进行优化，如何处理" class="headerlink" title="6.如果对 css进行优化，如何处理?"></a>6.如果对 css进行优化，如何处理?</h4><h5 id="1-内联首屏关键CSS（Critical-CSS）"><a href="#1-内联首屏关键CSS（Critical-CSS）" class="headerlink" title="1. 内联首屏关键CSS（Critical CSS）"></a>1. 内联首屏关键CSS（Critical CSS）</h5><p>性能优化中有一个重要的指标——<strong>首次有效绘制</strong>（First Meaningful Paint，简称FMP）即指页面的首要内容（primary content）出现在屏幕上的时间。这一指标影响用户看到页面前所需等待的时间，而<strong>内联首屏关键CSS（即Critical CSS，可以称之为首屏关键CSS）</strong>能减少这一时间。</p>
<p>实现:</p>
<p>我们应当<strong>只将渲染首屏内容所需的关键CSS内联到HTML中</strong>。</p>
<h5 id="2-异步加载CSS"><a href="#2-异步加载CSS" class="headerlink" title="2. 异步加载CSS"></a>2. 异步加载CSS</h5><p>CSS会阻塞渲染，在CSS文件请求、下载、解析完成之前，浏览器将不会渲染任何已处理的内容。有时，这种阻塞是必须的，因为我们并不希望在所需的CSS加载之前，浏览器就开始渲染页面。那么将首屏关键CSS内联后，剩余的CSS内容的阻塞渲染就不是必需的了，可以使用外部CSS，并且异步加载。</p>
<p>实现:</p>
<p>将link元素的<code>media</code>属性设置为用户浏览器不匹配的媒体类型（或媒体查询），如完全不存在的类型<code>media=&quot;noexist&quot;</code>。对浏览器来说，如果样式表不适用于当前媒体类型，其优先级会被放低，会在不阻塞页面渲染的情况下再进行下载。当然，这么做只是为了实现CSS的异步加载，别忘了在文件加载完成之后，将<code>media</code>的值设为<code>screen</code>或<code>all</code>，从而让浏览器开始解析CSS。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;mystyles.css&quot;</span> media=<span class="string">&quot;noexist&quot;</span> <span class="literal">on</span>load=<span class="string">&quot;this.media=&#x27;all&#x27;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-文件压缩"><a href="#3-文件压缩" class="headerlink" title="3. 文件压缩"></a>3. 文件压缩</h5><h5 id="4-去除无用CSS"><a href="#4-去除无用CSS" class="headerlink" title="4. 去除无用CSS"></a>4. 去除无用CSS</h5><h6 id="1-有选择地使用选择器"><a href="#1-有选择地使用选择器" class="headerlink" title="1).有选择地使用选择器"></a>1).有选择地使用选择器</h6><ul>
<li>保持简单，不要使用嵌套过多过于复杂的选择器。</li>
<li>通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。</li>
<li>不要使用类选择器和ID选择器修饰元素标签，如h3#markdown-content，这样多此一举，还会降低效率。</li>
<li>不要为了追求速度而放弃可读性与可维护性。</li>
</ul>
<h6 id="2-减少使用昂贵的属性"><a href="#2-减少使用昂贵的属性" class="headerlink" title="2).减少使用昂贵的属性"></a>2).减少使用昂贵的属性</h6><p>在浏览器绘制屏幕时，<strong>所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价</strong>。当页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写CSS时，我们应该尽量减少使用昂贵属性，如<code>box-shadow</code>&#x2F;<code>border-radius</code>&#x2F;<code>filter</code>&#x2F;透明度&#x2F;<code>:nth-child</code>等。</p>
<h6 id="3-优化重排与重绘"><a href="#3-优化重排与重绘" class="headerlink" title="3) 优化重排与重绘"></a>3) 优化重排与重绘</h6><p>在网站的使用过程中，某些操作会导致样式的改变，这时浏览器需要检测这些改变并重新渲染，其中有些操作所耗费的性能更多。</p>
<p>3.1 减少重排</p>
<p>重排会导致浏览器重新计算整个文档，重新构建渲染树，这一过程会降低浏览器的渲染速度。如下所示，有很多操作会触发重排，我们应该避免频繁触发这些操作。</p>
<ul>
<li>改变<code>font-size</code>和<code>font-family</code></li>
<li>改变元素的内外边距</li>
<li>通过JS改变CSS类</li>
<li>通过JS获取DOM元素的位置相关属性（如width&#x2F;height&#x2F;left等）</li>
<li>CSS伪类激活</li>
<li>滚动滚动条或者改变窗口大小</li>
</ul>
<p>值得一提的是，某些CSS属性具有更好的重排性能。如使用<code>Flex</code>时，比使用<code>inline-block</code>和<code>float</code>时重排更快，所以在布局时可以优先考虑<code>Flex</code>。</p>
<p>3.2 避免不必要的重绘</p>
<p>当元素的外观（如color，background，visibility等属性）发生改变时，会触发重绘。在网站的使用过程中，<strong>重绘是无法避免的</strong>。不过，浏览器对此做了优化，它会将多次的重排、重绘操作合并为一次执行。不过我们仍需要<strong>避免不必要的重绘</strong>，如页面滚动时触发的hover事件，可以在滚动的时候禁用hover事件，这样页面在滚动时会更加流畅。</p>
<h6 id="4-不要使用-import"><a href="#4-不要使用-import" class="headerlink" title="4.不要使用@import"></a>4.不要使用@import</h6><p>首先，使用@import引入CSS会影响浏览器的并行下载。使用@import引用的CSS文件只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作。这就导致浏览器无法并行下载所需的样式文件。</p>
<p>其次，多个@import会导致下载顺序紊乱。在IE中，@import会引发资源文件的下载顺序被打乱，即<strong>排列在@import后面的js文件先于@import下载，并且打乱甚至破坏@import自身的并行下载</strong>。</p>
<p>所以不要使用这一方法，使用link标签就行了。</p>
<h4 id="7-CSS3-有哪些新特性"><a href="#7-CSS3-有哪些新特性" class="headerlink" title="7.CSS3 有哪些新特性?"></a>7.CSS3 有哪些新特性?</h4><h5 id="一、选择器"><a href="#一、选择器" class="headerlink" title="一、选择器"></a>一、选择器</h5><p>css3中新增了一些选择器:</p>
<p>1.关系选择器中兄弟选择器</p>
<p>2.部分属性选择器</p>
<p>3.部分伪类选择器</p>
<h5 id="二-边框"><a href="#二-边框" class="headerlink" title="二.边框"></a>二.边框</h5><p><code>css3</code>新增了三个边框属性，分别是：</p>
<ul>
<li>border-radius：创建圆角边框</li>
<li>box-shadow：为元素添加阴影</li>
<li>border-image：使用图片来绘制边框</li>
</ul>
<h5 id="三-背景"><a href="#三-背景" class="headerlink" title="三.背景"></a>三.背景</h5><p>新增了几个关于背景的属性，分别是<code>background-clip</code>、<code>background-origin</code>、<code>background-size</code>和<code>background-break</code></p>
<h6 id="1-background-clip"><a href="#1-background-clip" class="headerlink" title="1.background-clip"></a>1.background-clip</h6><p>用于确定背景画区，有以下几种可能的属性：</p>
<ul>
<li>background-clip: border-box; 背景从border开始显示</li>
<li>background-clip: padding-box; 背景从padding开始显示</li>
<li>background-clip: content-box; 背景显content区域开始显示</li>
<li>background-clip: no-clip; 默认属性，等同于border-box</li>
</ul>
<p>通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围</p>
<h6 id="2-background-origin"><a href="#2-background-origin" class="headerlink" title="2.background-origin"></a>2.background-origin</h6><p>当我们设置背景图片时，图片是会以左上角对齐，但是是以<code>border</code>的左上角对齐还是以<code>padding</code>的左上角或者<code>content</code>的左上角对齐? <code>border-origin</code>正是用来设置这个的</p>
<ul>
<li>background-origin: border-box; 从border开始计算background-position</li>
<li>background-origin: padding-box; 从padding开始计算background-position</li>
<li>background-origin: content-box; 从content开始计算background-position</li>
</ul>
<p>默认情况是<code>padding-box</code>，即以<code>padding</code>的左上角为原点</p>
<h6 id="3-background-size"><a href="#3-background-size" class="headerlink" title="3.background-size"></a>3.background-size</h6><p>background-size属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：</p>
<ul>
<li>background-size: contain; 缩小图片以适合元素（维持像素长宽比）</li>
<li>background-size: cover; 扩展元素以填补元素（维持像素长宽比）</li>
<li>background-size: 100px 100px; 缩小图片至指定的大小</li>
<li>background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸</li>
</ul>
<h6 id="4-background-break"><a href="#4-background-break" class="headerlink" title="4.background-break"></a>4.background-break</h6><p>元素可以被分成几个独立的盒子（如使内联元素span跨越多行），<code>background-break</code> 属性用来控制背景怎样在这些不同的盒子中显示</p>
<ul>
<li>background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）</li>
<li>background-break: bounding-box; 把盒之间的距离计算在内；</li>
<li>background-break: each-box; 为每个盒子单独重绘背景</li>
</ul>
<h5 id="四-文字"><a href="#四-文字" class="headerlink" title="四.文字"></a>四.文字</h5><h6 id="1-word-wrap"><a href="#1-word-wrap" class="headerlink" title="1.word-wrap"></a>1.word-wrap</h6><p>语法：<code>word-wrap: normal|break-word</code></p>
<ul>
<li>normal：使用浏览器默认的换行</li>
<li>break-all：允许在单词内换行</li>
</ul>
<h6 id="x3D-x3D-2-text-overflow-x3D-x3D-可以用来裁剪文字过多"><a href="#x3D-x3D-2-text-overflow-x3D-x3D-可以用来裁剪文字过多" class="headerlink" title="&#x3D;&#x3D;2.text-overflow&#x3D;&#x3D;(可以用来裁剪文字过多)"></a>&#x3D;&#x3D;2.text-overflow&#x3D;&#x3D;(可以用来裁剪文字过多)</h6><p><code>text-overflow</code>设置或检索当当前行超过指定容器的边界时如何显示，属性有两个值选择：</p>
<ul>
<li>clip：修剪文本</li>
<li>ellipsis：显示省略符号来代表被修剪的文本</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">	//网页如何处理空白,不换行</span><br><span class="line">	<span class="attribute">white-space</span>:nowrap;</span><br><span class="line">	<span class="attribute">overflow</span>:hidden;</span><br><span class="line">	<span class="attribute">text-overflow</span>:ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-text-shadow"><a href="#3-text-shadow" class="headerlink" title="3.text-shadow"></a>3.text-shadow</h6><p><code>text-shadow</code>可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色</p>
<h6 id="4-text-decoration"><a href="#4-text-decoration" class="headerlink" title="4.text-decoration"></a>4.text-decoration</h6><p>CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：</p>
<ul>
<li>text-fill-color: 设置文字内部填充颜色</li>
<li>text-stroke-color: 设置文字边界填充颜色</li>
<li>text-stroke-width: 设置文字边界宽度</li>
</ul>
<h5 id="五-颜色"><a href="#五-颜色" class="headerlink" title="五.颜色"></a>五.颜色</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">css3`新增了新的颜色表示方式`rgba`与`hsla</span><br></pre></td></tr></table></figure>

<ul>
<li>rgba分为两部分，rgb为颜色值，a为透明度</li>
<li>hala分为四部分，h为色相，s为饱和度，l为亮度，a为透明度</li>
</ul>
<h5 id="六-transition-过渡"><a href="#六-transition-过渡" class="headerlink" title="六.transition 过渡"></a>六.transition 过渡</h5><p><code>transition</code>属性可以被指定为一个或多个<code>CSS</code>属性的过渡效果，多个属性之间用逗号进行分隔，必须规定两项内容：</p>
<ul>
<li>过度效果</li>
<li>持续时间</li>
</ul>
<h5 id="七-transform-转换"><a href="#七-transform-转换" class="headerlink" title="七.transform 转换"></a>七.transform 转换</h5><p><code>transform</code>属性允许你旋转，缩放，倾斜或平移给定元素</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform-origin</span>`：转换元素的位置（围绕那个点进行转换），默认值为`(x,y,z):(<span class="number">50%</span>,<span class="number">50%</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<ul>
<li>transform: translate(120px, 50%)：位移</li>
<li>transform: scale(2, 0.5)：缩放</li>
<li>transform: rotate(0.5turn)：旋转</li>
<li>transform: skew(30deg, 20deg)：倾斜</li>
</ul>
<h5 id="八-animation-动画"><a href="#八-animation-动画" class="headerlink" title="八.animation 动画"></a>八.animation 动画</h5><p>动画这个平常用的也很多，主要是做一个预设的动画。和一些页面交互的动画效果，结果和过渡应该一样，让页面不会那么生硬</p>
<p>animation也有很多的属性</p>
<ul>
<li>animation-name：动画名称</li>
<li>animation-duration：动画持续时间</li>
<li>animation-timing-function：动画时间函数</li>
<li>animation-delay：动画延迟时间</li>
<li>animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环</li>
<li>animation-direction：动画执行方向</li>
<li>animation-paly-state：动画播放状态</li>
<li>animation-fill-mode：动画填充模式</li>
</ul>
<h5 id="九-渐变"><a href="#九-渐变" class="headerlink" title="九.渐变"></a>九.渐变</h5><p>颜色渐变是指在两个颜色之间平稳的过渡，<code>css3</code>渐变包括</p>
<ul>
<li>linear-gradient：线性渐变</li>
</ul>
<blockquote>
<p>background-image: linear-gradient(direction, color-stop1, color-stop2, …);</p>
</blockquote>
<ul>
<li>radial-gradient：径向渐变</li>
</ul>
<blockquote>
<p>linear-gradient(0deg, red, green);</p>
</blockquote>
<h5 id="十-布局"><a href="#十-布局" class="headerlink" title="十.布局"></a>十.布局</h5><p>关于<code>css3</code>其他的新特性还包括<code>flex</code>弹性布局、<code>Grid</code>栅格布局，这两个布局在以前就已经讲过，这里就不再展示</p>
<p>除此之外，还包括多列布局、媒体查询、混合模式等等……</p>
<h4 id="8-解释-下CSS-Sprites-以及你要如何在页面或网站中使用它。"><a href="#8-解释-下CSS-Sprites-以及你要如何在页面或网站中使用它。" class="headerlink" title="8.解释 下CSS Sprites,以及你要如何在页面或网站中使用它。"></a>8.解释 下CSS Sprites,以及你要如何在页面或网站中使用它。</h4><p>CSS Sprites(雪碧图,精灵图)其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位.</p>
<p>作用:</p>
<p>1.解决了图片闪烁问题</p>
<p>2.减少了向服务器多次请求,加快访问速度</p>
<h4 id="9-分析比较opacity-0、visibility-hidden、display-none-优劣和适用场"><a href="#9-分析比较opacity-0、visibility-hidden、display-none-优劣和适用场" class="headerlink" title="9.分析比较opacity:0、visibility:hidden、display:.none 优劣和适用场"></a>9.分析比较opacity:0、visibility:hidden、display:.none 优劣和适用场</h4><h5 id="一-区别："><a href="#一-区别：" class="headerlink" title="一.区别："></a>一.区别：</h5><p> display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击， </p>
<p>visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击 </p>
<p>opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击</p>
<h5 id="二-性能："><a href="#二-性能：" class="headerlink" title="二.性能："></a>二.性能：</h5><p>displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大 </p>
<p>visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容 </p>
<p>opacity: 0 ： 修改元素会造成重绘，性能消耗较少</p>
<h4 id="10-外边距塌陷-x2F-外边距折叠"><a href="#10-外边距塌陷-x2F-外边距折叠" class="headerlink" title="10.外边距塌陷&#x2F;外边距折叠?"></a>10.外边距塌陷&#x2F;外边距折叠?</h4><h5 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h5><p>相邻的垂直方向外边距会发生重叠现象</p>
<h5 id="解决-为元素开启BFC-块级格式化上下文"><a href="#解决-为元素开启BFC-块级格式化上下文" class="headerlink" title="解决:为元素开启BFC(块级格式化上下文)"></a>解决:为元素开启BFC(块级格式化上下文)</h5><h6 id="1-BFC特点-1"><a href="#1-BFC特点-1" class="headerlink" title="1)BFC特点:"></a>1)BFC特点:</h6><p>①开启BFC的元素不会被浮动元素覆盖</p>
<p>②开启BFC的父元素与其子元素外边距不会重叠(可以用来解决外边距重叠问题)</p>
<p>③开启BFC的元素可以包含浮动的子元素</p>
<h6 id="2-如何开启BFC-1"><a href="#2-如何开启BFC-1" class="headerlink" title="2)如何开启BFC"></a>2)如何开启BFC</h6><p>1、float的值不是none。<br>2、position的值不是static或者relative。<br>3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex<br>4、overflow的值不是visible</p>
<h4 id="11-重排-回流-和重绘"><a href="#11-重排-回流-和重绘" class="headerlink" title="11.重排(回流)和重绘?"></a>11.重排(回流)和重绘?</h4><h5 id="一-浏览器渲染"><a href="#一-浏览器渲染" class="headerlink" title="一.浏览器渲染"></a>一.浏览器渲染</h5><p>浏览器在渲染页面的时候，大致是以下几个步骤：</p>
<ol>
<li>解析html生成DOM树，解析css，生成CSSOM树，将DOM树和CSSOM树结合，生成渲染树；</li>
<li>根据渲染树，浏览器可以计算出网页中有哪些节点，各节点的CSS以及从属关系 - 回流</li>
<li>根据渲染树以及回流得到的节点信息，计算出每个节点在屏幕中的位置 - 重绘</li>
<li>最后将得到的节点位置信息交给浏览器的图形处理程序，让浏览器中显示页面</li>
</ol>
<h5 id="二-回流"><a href="#二-回流" class="headerlink" title="二.回流"></a>二.回流</h5><p>回流：英文叫reflow，指的是当渲染树中的节点信息发生了大小、边距等问题，需要重新计算各节点和css具体的大小和位置。</p>
<p>例：在css中对一个div修饰的样式中，使用了宽度50%，此时需要将50%转换为具体的像素，这个计算的过程，就是回流的过程。</p>
<h5 id="三-重绘"><a href="#三-重绘" class="headerlink" title="三.重绘"></a>三.重绘</h5><p>重绘：英文叫repaint，当节点的部分属性发生变化，但不影响布局，只需要重新计算节点在屏幕中的绝对位置并渲染的过程，就叫重绘。比如：改变元素的背景颜色、字体颜色等操作会造成重绘。</p>
<p>回流的过程在重绘的过程前面，所以回流一定会重绘，但重绘不一定会引起回流。</p>
<h4 id="12-常用的几种布局方式"><a href="#12-常用的几种布局方式" class="headerlink" title="12.常用的几种布局方式"></a>12.常用的几种布局方式</h4><h5 id="1-固定布局"><a href="#1-固定布局" class="headerlink" title="1.固定布局"></a>1.固定布局</h5><blockquote>
<p>宽度，高度固定，页面被一个固定网页包裹，容器不能移动，页面的宽高不随页面的变化而变化，这种布局大家比较熟悉，这种方式一度成为页面布局的主流方式，这样布局设计简单，更容易定义，但是由于屏幕尺寸的不同，特别是移动端各个设备的不同，这种布局在灵活性方式可用度不高。</p>
</blockquote>
<h5 id="2-流式布局"><a href="#2-流式布局" class="headerlink" title="2.流式布局"></a>2.流式布局</h5><blockquote>
<p>以百分比为主要形式，让屏幕自适应，这种布局方式定义灵活，能够根据屏幕的情况变化，但是这种方式设计的效果不太容易控制，一般移动端结合rem用的比较多，pc端用的不是非常多</p>
</blockquote>
<h5 id="3-弹性布局"><a href="#3-弹性布局" class="headerlink" title="3.弹性布局"></a>3.弹性布局</h5><blockquote>
<p>浮动部分和清楚浮动部分主要是兼容添加的一些代码，重点看弹性布局的部分，弹性布局相对前两种出现的比较晚些，但是弹性布局功能还是很强大的，布局也非常方便，但是此布局形式在pc端并不推荐使用，ie9以下浏览器均不支持，另外火狐等一些浏览器也需要做兼容，移动端目前绝大部分浏览器都已经支持弹性布局，在移动端大家可以尝试使用。</p>
</blockquote>
<h5 id="4-浮动布局"><a href="#4-浮动布局" class="headerlink" title="4.浮动布局"></a>4.浮动布局</h5><blockquote>
<p>浮动布局关键词，float，可以设置left或者right，他使元素脱离文档流进而达到布局的目的，也是目前一个比较主流的布局方式，但是使用浮动的结束以后，别忘记清除浮动哦。</p>
</blockquote>
<h5 id="5-定位布局"><a href="#5-定位布局" class="headerlink" title="5.定位布局"></a>5.定位布局</h5><blockquote>
<p>定位布局也是目前比较常用的一种布局方式，关键词： position: fixed;固定布局，将元素固定在一个位置，不随页面移动而移动，position: relative;相对定位，相对于元素自身定位，不脱离文档流，相当于定义一个参照物，一般和绝对定位结合使用，position: absolute;绝对定位，脱离文档流，一般和相对定位结合使用，如果不定义相对定义，将会相对于整个浏览器定位，所以定位布局，一般情况下都是相对定位和绝对定位结合着来，相当定位相当于划定一个势力范围，制定一个封闭的容器块，然后绝对定位就行对于相对定位来定位，从而达到有效的布局。</p>
</blockquote>
<h4 id="13-css3-实现0-5px的细线"><a href="#13-css3-实现0-5px的细线" class="headerlink" title="13.css3 实现0.5px的细线"></a>13.css3 实现0.5px的细线</h4><h5 id="一-渐变实现"><a href="#一-渐变实现" class="headerlink" title="一.渐变实现"></a>一.渐变实现</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">0deg</span>, transparent <span class="number">50%</span>, <span class="number">#e0e0e0</span> <span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="二-使用缩放"><a href="#二-使用缩放" class="headerlink" title="二.使用缩放"></a>二.使用缩放</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;  &quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e0e0e0</span>;</span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">scaleY</span>(.<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="14-用纯CSS创建-一个三角形的原理是什么"><a href="#14-用纯CSS创建-一个三角形的原理是什么" class="headerlink" title="14.用纯CSS创建-一个三角形的原理是什么"></a>14.用纯CSS创建-一个三角形的原理是什么</h4><p>盒子模型的border就是由三角形组成的，我们可以通过设置元素的宽高为0，然后修改border的宽度，并且修改其颜色，来达到绘制三角形的目的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">0px</span>;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">0px</span>;</span><br><span class="line">	<span class="attribute">border</span>:solid <span class="number">9px</span> transparent;</span><br><span class="line">	<span class="attribute">border-top</span>:none;</span><br><span class="line">	<span class="attribute">border-bottom-color</span>:red</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="15-CSS样式中常用单位"><a href="#15-CSS样式中常用单位" class="headerlink" title="15.CSS样式中常用单位?"></a>15.CSS样式中常用单位?</h4><h5 id="一-px"><a href="#一-px" class="headerlink" title="一.px"></a>一.px</h5><p>px 是图像显示的基本单元，是 viewport 像素，是相对单位。同样都是 1px，在不同设备上的显示有可能是不一样的。</p>
<h5 id="二-百分号"><a href="#二-百分号" class="headerlink" title="二.百分号 %"></a>二.百分号 %</h5><p>% 是相对于父元素的尺寸来计算的。</p>
<h5 id="三-em"><a href="#三-em" class="headerlink" title="三.em"></a>三.em</h5><p>em 是相对于父元素的 font-size 来计算的。</p>
<h5 id="四-rem"><a href="#四-rem" class="headerlink" title="四.rem"></a>四.rem</h5><p>rem 是相对于根元素 [html&gt; 的 font-size 来计算的(注意,谷歌浏览器最小font-size为10px,其他12px.浏览器默认大小为16px)，比如说你设置了1.2rem，根元素的font-size是100px，那么这个元素动态算出来的px数就是120px。</p>
<h5 id="五-vw，vh，vmin，vmax"><a href="#五-vw，vh，vmin，vmax" class="headerlink" title="五.vw，vh，vmin，vmax"></a>五.vw，vh，vmin，vmax</h5><p>vw、vh、vmin、vmax 是一种视窗单位，也是相对单位。是由视窗（Viewport）大小来决定的，单位 1，代表类似于 1%。<br>视窗(Viewport)是你的浏览器实际显示内容的区域（不包括工具栏和按钮）。</p>
<p>具体描述如下：</p>
<p>vw：视窗宽度的百分比（1vw 代表视窗的宽度为 1%）<br>vh：视窗高度的百分比<br>vmin：当前 vw 和 vh 中较小的一个值<br>vmax：当前 vw 和 vh 中较大的一个值<br>（3）vmin、vmax 用处<br>做移动页面开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的。<br>由于 vmin 和 vmax 是当前较小的 vw 和 vh 和当前较大的 vw 和 vh。这里就可以用到 vmin 和 vmax。使得文字大小在横竖屏下保持一致。</p>
<h5 id="所以可以使用rem-vm结合制作移动端"><a href="#所以可以使用rem-vm结合制作移动端" class="headerlink" title="所以可以使用rem+vm结合制作移动端:"></a>所以可以使用rem+vm结合制作移动端:</h5><p>在980px设计图中</p>
<p>​	100vm&#x3D;980px&#x3D;&gt;0.102vm&#x3D;1px;</p>
<p>​	所以将浏览器的font-size设为10.2vm,此时1rem&#x3D;100px</p>
<h4 id="16-请解释一下-CSS3的Flexbox-弹性盒布局模型"><a href="#16-请解释一下-CSS3的Flexbox-弹性盒布局模型" class="headerlink" title="16.请解释一下 CSS3的Flexbox ( 弹性盒布局模型) ?"></a>16.请解释一下 CSS3的Flexbox ( 弹性盒布局模型) ?</h4><h5 id="1-什么是flex"><a href="#1-什么是flex" class="headerlink" title="1.什么是flex"></a>1.什么是flex</h5><p>flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。块级元素只需要display属性为flex即可。行内元素也可以使用 Flex 布局。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: inline-flex; </span><br><span class="line">&#125;。</span><br><span class="line">//Webkit 内核的浏览器，必须加上-webkit前缀</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">&#125;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。 它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。 项目默认沿主轴排列。</p>
<h5 id="2-容器属性"><a href="#2-容器属性" class="headerlink" title="2.容器属性"></a>2.容器属性</h5><p>flex-direction属性决定主轴的方向（即项目的排列方向）。<br>flex-wrap属性定义，如果一条轴线排不下，如何换行。默认情况下，项目都排在一条线（又称”轴线”）上。<br>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap                                       flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小                                    justify-content属性定义了项目在主轴上的对齐方式。<br>align-items属性定义项目在交叉轴上如何对齐。<br>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<h5 id="3-项目属性"><a href="#3-项目属性" class="headerlink" title="3.项目属性"></a>3.项目属性</h5><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小<br>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br>flex属性是以上三个的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。<br>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</p>
<h4 id="17-link-与-import的区别"><a href="#17-link-与-import的区别" class="headerlink" title="17.link 与@import的区别."></a>17.link 与@import的区别.</h4><p>一.link属于html标签。@import在css中使用表示导入外部样式表；</p>
<p>二.页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</p>
<p>三.import只在IE5以上才能识别，而link是HTML标签，无兼容问题;</p>
<p>四.link方式的样式的权重 高于@import的权重；</p>
<p>五.link 支持使用javascript改变样式 （document.styleSheets），后者不可</p>
<h3 id="三-JS"><a href="#三-JS" class="headerlink" title="三.JS"></a>三.JS</h3><h4 id="1-值传递和引用传递分别是什么，有什么区别"><a href="#1-值传递和引用传递分别是什么，有什么区别" class="headerlink" title="1.值传递和引用传递分别是什么，有什么区别?"></a>1.值传递和引用传递分别是什么，有什么区别?</h4><p>值传递：传递的是实际参数的一个副本。基本数据类型Undefined，Null，Boolean，Number、String都是值传递。</p>
<p>引用传递：传递的是实际参数的地址。引用数据类型Object，Array，Date， Function等都是引用传递。</p>
<h4 id="2-怎样添加、-移除、移动、复制、创建和查找节点"><a href="#2-怎样添加、-移除、移动、复制、创建和查找节点" class="headerlink" title="2.怎样添加、 移除、移动、复制、创建和查找节点?"></a>2.怎样添加、 移除、移动、复制、创建和查找节点?</h4><p>1.添加：appendChild();语法:父节点.appendChild(子节点)</p>
<p>2.移除：removeChild();语法:父节点.removeChild(子节点)</p>
<p>3.移动(插入,向指定子节点前插入节点)：insertBefore();语法:父节点.insertBefore(新节点,旧节点)</p>
<p>4.复制：cloneNode() ;</p>
<p>语法:如果您需要克隆所有后代，请把 deep 参数设置 true，否则设置为 false。要克隆的节点.cloneNode(false)</p>
<p>5.创建：createElement();语法:</p>
<p>6.查找：getElementsByTag</p>
<h4 id="3-javascript-中有几种数据类型-怎么判断数据类型"><a href="#3-javascript-中有几种数据类型-怎么判断数据类型" class="headerlink" title="3.javascript 中有几种数据类型?怎么判断数据类型"></a>3.javascript 中有几种数据类型?怎么判断数据类型</h4><h5 id="一-总共八种"><a href="#一-总共八种" class="headerlink" title="(一)总共八种"></a>(一)总共八种</h5><p>1.七种基本数据类型</p>
<p>1)Number</p>
<p>2)String</p>
<p>3)Boolean</p>
<p>4)Undefined</p>
<p>5)Null</p>
<p>6)Symbol</p>
<p>7)Bigint</p>
<p>2.一种引用数据类型</p>
<p>1).Object(包括Array Function 等)</p>
<h5 id="二-鉴定方法"><a href="#二-鉴定方法" class="headerlink" title="(二)鉴定方法"></a>(二)鉴定方法</h5><p>1.typeof(typeof XXX)</p>
<p>可鉴别 Number,String,Boolean,Undefined,Symbol,Bigint,function</p>
<p>2.&#x3D;&#x3D;&#x3D;</p>
<p>可鉴别undefined,null</p>
<p>3.instanceof(a instanceof Array)</p>
<p>判断对象具体类型,返回true&#x2F;false</p>
<h4 id="4-var-let-和const之间的区别"><a href="#4-var-let-和const之间的区别" class="headerlink" title="4.var,let 和const之间的区别"></a>4.var,let 和const之间的区别</h4><p><code>var</code>、<code>let</code>、<code>const</code>三者区别可以围绕下面五点展开：</p>
<h5 id="一-变量提升"><a href="#一-变量提升" class="headerlink" title="(一)变量提升"></a>(一)变量提升</h5><p>var<code>声明的变量存在变量提升，即变量可以在声明之前调用，值为</code>undefined</p>
<p><code>let</code>和<code>const</code>不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</p>
<h5 id="二-暂时性死区"><a href="#二-暂时性死区" class="headerlink" title="(二)暂时性死区"></a>(二)暂时性死区</h5><p><code>var</code>不存在暂时性死区</p>
<p><code>let</code>和<code>const</code>存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p>
<h5 id="三-块级作用域"><a href="#三-块级作用域" class="headerlink" title="(三)块级作用域"></a>(三)块级作用域</h5><p><code>var</code>不存在块级作用域</p>
<p><code>let</code>和<code>const</code>存在块级作用域</p>
<h5 id="四-重复声明"><a href="#四-重复声明" class="headerlink" title="(四)重复声明"></a>(四)重复声明</h5><p><code>var</code>允许重复声明变量</p>
<p><code>let</code>和<code>const</code>在同一作用域不允许重复声明变量</p>
<h5 id="五-修改声明的变量"><a href="#五-修改声明的变量" class="headerlink" title="(五)修改声明的变量"></a>(五)修改声明的变量</h5><p><code>var</code>和<code>let</code>可以</p>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变</p>
<h4 id="5-JavaScript-数组的常用方法"><a href="#5-JavaScript-数组的常用方法" class="headerlink" title="5.JavaScript 数组的常用方法?"></a>5.JavaScript 数组的常用方法?</h4><h5 id="一-增"><a href="#一-增" class="headerlink" title="(一)增"></a>(一)增</h5><p>下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响</p>
<ul>
<li><p>push()</p>
<p>向尾部添加</p>
</li>
<li><p>unshift()</p>
<p>向头部添加</p>
</li>
<li><p>splice()</p>
<p>将指定元素从原数组中删除。传入三个参数,(开始位置、要删除的元素数量,插入的元素)。返回删除值</p>
</li>
<li><p>concat()</p>
<p>连接两个或多个数组,并将新的数组返回</p>
</li>
</ul>
<h5 id="二-删"><a href="#二-删" class="headerlink" title="(二)删"></a>(二)删</h5><p>下面三种都会影响原数组，最后一项不影响原数组：</p>
<ul>
<li><p>pop()</p>
<p>删除最后一个元素</p>
</li>
<li><p>shift()</p>
<p>删除第一个元素</p>
</li>
<li><p>splice()</p>
<p>将指定元素从原数组中删除。传入三个参数,(开始位置、要删除的元素数量,插入的元素)。返回删除值</p>
</li>
<li><p>slice()</p>
<p>用于创建一个包含原有数组中一个或多个元素的新数组,传入三个参数,(开始位置、结束位置)</p>
</li>
</ul>
<h5 id="三-改"><a href="#三-改" class="headerlink" title="(三)改"></a>(三)改</h5><p>slice():用于创建一个包含原有数组中一个或多个元素的新数组,传入三个参数,(开始位置、结束位置)</p>
<h5 id="四-查"><a href="#四-查" class="headerlink" title="(四)查"></a>(四)查</h5><p>即查找元素，返回元素坐标或者元素值,多不会改变原数组</p>
<ul>
<li><p>indexOf()</p>
<p>返回要查找的元素在数组中的位置，如果没找到则返回 -1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>includes()</p>
<p>返回要查找的元素在数组中的位置，找到返回<code>true</code>，否则<code>false</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">includes</span>(<span class="number">4</span>) <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>find()</p>
<p>返回第一个匹配的元素</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">27</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line">people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>) <span class="comment">// // &#123;name: &quot;Matt&quot;, age: 27&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="五-排序"><a href="#五-排序" class="headerlink" title="(五)排序"></a>(五)排序</h5><p>数组有两个方法可以用来对元素重新排序,多改变原数组：</p>
<ul>
<li><p>reverse()</p>
<p>将数组元素方向反转</p>
</li>
<li><p>sort()</p>
<p>sort()方法(默认按照unicode编码排序)接受一个比较函数,需要两个形参,根据返回值判断顺序。</p>
<p>如果返回值&gt;0则元素交换位置,&lt;&#x3D;0则不变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.<span class="title function_">sort</span>(compare);</span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 0,1,5,10,15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="六-转换"><a href="#六-转换" class="headerlink" title="(六)转换"></a>(六)转换</h5><ul>
<li>join() 方法将数组转换为字符串,接收一个参数，即字符串分隔符，返回包含所有项的字符串</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">alert(colors.join(&quot;,&quot;)); // red,green,blue</span><br><span class="line">alert(colors.join(&quot;||&quot;)); // red||green||blue</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>from()方法 从具有 length 属性或可迭代对象的任何对象返回 Array 对象。(将伪数组转换为数组)</p>
<p>Array.from(object,mapFunction,thisValue);<br>参数说明：</p>
<ol>
<li><code>object</code>：必须，要转换为数组的对象。</li>
<li><code>mapFunction</code>：可选，数组中每个元素要调用的函数。</li>
<li><code>thisValue</code>：可选，映射函数（mapFunction）中的this对象</li>
</ol>
</li>
</ul>
<h5 id="七-遍历"><a href="#七-遍历" class="headerlink" title="(七)遍历"></a>(七)遍历</h5><p>常用来迭代数组的方法（都不改变原数组）有如下：</p>
<ul>
<li><p>some()</p>
<p>对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> someResult = numbers.<span class="title function_">some</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(someResult) <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>every()</p>
<p>对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> everyResult = numbers.<span class="title function_">every</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(everyResult) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>forEach()</p>
<p>对数组每一项都运行传入的函数，没有返回值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>filter()</p>
<p>对数组每一项都运行传入的函数，函数返回 <code>true</code> 的项会组成数组之后返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filterResult); <span class="comment">// 3,4,5,4,3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>map()</p>
<p>对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapResult) <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-ES6-的新特性"><a href="#6-ES6-的新特性" class="headerlink" title="6.ES6 的新特性"></a>6.ES6 的新特性</h4><h5 id="1、let和const"><a href="#1、let和const" class="headerlink" title="1、let和const"></a>1、let和const</h5><h5 id="2、symbol"><a href="#2、symbol" class="headerlink" title="2、symbol"></a>2、symbol</h5><h5 id="3、模板字符串"><a href="#3、模板字符串" class="headerlink" title="3、模板字符串"></a>3、模板字符串</h5><p>​	3.1 字符串新方法（补充）</p>
<h5 id="4、解构表达式"><a href="#4、解构表达式" class="headerlink" title="4、解构表达式"></a>4、解构表达式</h5><p>​	4.1 数组解构<br>​	4.2 对象解构</p>
<h5 id="5、对象方面"><a href="#5、对象方面" class="headerlink" title="5、对象方面"></a>5、对象方面</h5><p>​	5.1 Map和Set<br>​		5.1.1 Map<br>​		5.1.2 Set<br>​	5.3 数组的新方法<br>​		5.3.1 Array.from()方法<br>​		5.3.2 includes()方法<br>​		5.3.3 map()、filter() 方法<br>​		5.3.4 forEach()方法<br>​		5.3.4 find()方法<br>​		5.3.6 some()、every() 方法<br>​	5.4 object的新方法<br>​		5.4.1 Object.is()<br>​		5.4.2 Object.assign()<br>​		5.4.3 Object.keys()、Object.values()、Object.entries()<br>​	5.5 对象声明简写<br>​	5.6 …(对象扩展符)</p>
<h5 id="6、函数方面"><a href="#6、函数方面" class="headerlink" title="6、函数方面"></a>6、函数方面</h5><p>​	6.1 参数默认值<br>​	6.2 箭头函数<br>​	6.3 箭头函数和普通函数最大的区别在于其内部this永远指向其父级对象的this。(重点)</p>
<h5 id="7、class（类）"><a href="#7、class（类）" class="headerlink" title="7、class（类）"></a>7、class（类）</h5><h5 id="8、promise"><a href="#8、promise" class="headerlink" title="8、promise"></a>8、promise</h5><h5 id="9、模块化"><a href="#9、模块化" class="headerlink" title="9、模块化"></a>9、模块化</h5><h4 id="7-普通-函数和箭头函数的区别"><a href="#7-普通-函数和箭头函数的区别" class="headerlink" title="7.普通 函数和箭头函数的区别"></a>7.普通 函数和箭头函数的区别</h4><h5 id="一-语法更加简洁、清晰"><a href="#一-语法更加简洁、清晰" class="headerlink" title="(一)语法更加简洁、清晰"></a>(一)语法更加简洁、清晰</h5><p>从上面的箭头函数基本语法示例中可以看出，箭头函数的定义要比普通函数定义简洁、清晰得多，很快捷。</p>
<h5 id="二-箭头函数没有-prototype-原型-，所以箭头函数本身没有this"><a href="#二-箭头函数没有-prototype-原型-，所以箭头函数本身没有this" class="headerlink" title="(二)箭头函数没有 prototype (原型)，所以箭头函数本身没有this"></a>(二)箭头函数没有 prototype (原型)，所以箭头函数本身没有this</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// &#123;constructor:f&#125;复制代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="三-箭头函数不会创建自己的this"><a href="#三-箭头函数不会创建自己的this" class="headerlink" title="(三)箭头函数不会创建自己的this"></a>(三)箭头函数不会创建自己的this</h5><p>箭头函数没有自己的this，箭头函数的this指向在定义（<strong>注意：</strong>是定义时，不是调用时）的时候继承自外层第一个普通函数的this。所以，箭头函数中 <code>this </code>的指向在它被定义的时候就已经确定了，之后永远不会改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">// undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">// 10</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// &#123;a: 10, b: ƒ, c: ƒ&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">b</span>(); </span><br><span class="line">obj.<span class="title function_">c</span>();复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="四-call-apply-bind-无法改变箭头函数中this的指向"><a href="#四-call-apply-bind-无法改变箭头函数中this的指向" class="headerlink" title="(四)call | apply | bind 无法改变箭头函数中this的指向"></a>(四)call | apply | bind 无法改变箭头函数中this的指向</h5><p><code>call | apply | bind</code>方法可以用来动态修改函数执行时this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数<code>this</code>的指向。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="number">10</span>;</span><br><span class="line">let <span class="function"><span class="keyword">fun</span> = <span class="params">()</span></span> =&gt; &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span></span>;     <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">fun</span>.call(&#123; id: <span class="number">20</span> &#125;);     <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">fun</span>.apply(&#123; id: <span class="number">20</span> &#125;);    <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">fun</span>.bind(&#123; id: <span class="number">20</span> &#125;)();   <span class="comment">// 10复制代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="五-箭头函数不能作为构造函数使用"><a href="#五-箭头函数不能作为构造函数使用" class="headerlink" title="(五)箭头函数不能作为构造函数使用"></a>(五)箭头函数不能作为构造函数使用</h5><p>我们先了解一下构造函数的new都做了些什么？简单来说，分为四步： ① JS内部首先会先生成一个对象； ② 再把函数中的this指向该对象； ③ 然后执行构造函数中的语句； ④ 最终返回该对象实例。</p>
<p>但是！！因为箭头函数没有自己的<code>this</code>，它的<code>this</code>其实是继承了外层执行环境中的<code>this</code>，且<code>this</code>指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用new调用时会报错！</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let <span class="attr">Fun</span> = (name, age) =&gt; &#123;</span><br><span class="line">    <span class="attr">this.name</span> = name<span class="comment">;</span></span><br><span class="line">    <span class="attr">this.age</span> = age<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">let <span class="attr">p</span> = new Fun(<span class="string">&#x27;dingFY&#x27;</span>, <span class="number">24</span>)<span class="comment">;复制代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-说一下Promise"><a href="#8-说一下Promise" class="headerlink" title="8.说一下Promise?"></a>8.说一下Promise?</h4><h5 id="一-定义"><a href="#一-定义" class="headerlink" title="(一)定义"></a>(一)定义</h5><p>Promise本质上只是一个构造函数,使用Promise new出来的实例对象可以用来封装一个异步操作,并可以获取其成功&#x2F;失败的结果.可以用来解决异步编程(回调地狱)</p>
<h5 id="二-使用"><a href="#二-使用" class="headerlink" title="(二)使用"></a>(二)使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p=<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//Promise三种状态:</span></span><br><span class="line">	<span class="comment">//Pending  			未定义</span></span><br><span class="line">	<span class="comment">//Resolved/fulfilled 成功</span></span><br><span class="line">	<span class="comment">//Rejected 			失败</span></span><br><span class="line">	<span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">		<span class="comment">//成功传值i</span></span><br><span class="line">		<span class="title function_">resolve</span>(i)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//失败传值j</span></span><br><span class="line">		<span class="title function_">reject</span>(j)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;&#125;)<span class="comment">//value==i;reason==j</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="三-API"><a href="#三-API" class="headerlink" title="(三)API"></a>(三)API</h5><p><code>Promise</code>构建出来的实例存在以下方法：</p>
<ul>
<li><p>then()</p>
<p><code>then</code>是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例，也就是<code>promise</code>能链式书写的原因</p>
</li>
<li><p>catch()</p>
<p><code>catch()</code>方法用于指定发生错误时的回调函数,<code>Promise</code>对象的错误存在异常穿透，会一直向后传递，直到被捕获为止。所以常常使用<code>catch</code>方法代替<code>then()</code>第二个参数</p>
</li>
<li><p>resolve()</p>
<p>快速返回一个成功&#x2F;失败的Promise对象</p>
</li>
<li><p>reject()</p>
<p>快速返回一个失败的Promise对象</p>
</li>
<li><p>all()</p>
<p><code>Promise.all()</code>方法用于将多个 <code>Promise</code>实例，返回一个新的 <code>Promise</code>实例,只有所有多成功,其才成功.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接受一个数组（迭代对象）作为参数，数组成员都应为<code>Promise</code>实例</p>
</li>
<li><p>race()</p>
<p>返回一个新的Promise对象,接收promise对象数组,第一个完成的promise对象状态为其状态</p>
</li>
</ul>
<h4 id="9-Async-x2F-await-对比promise的优缺点"><a href="#9-Async-x2F-await-对比promise的优缺点" class="headerlink" title="9.Async&#x2F;await 对比promise的优缺点"></a>9.Async&#x2F;await 对比promise的优缺点</h4><p>async&#x2F;await优点：<br>a. 它做到了真正的串行的同步写法，代码阅读相对容易<br>b. 对于条件语句和其他流程语句比较友好，可以直接写到判断条件里面<br>c. 处理复杂流程时，在代码清晰度方面有优势</p>
<p>async&#x2F;await缺点：<br>a. 无法处理promise返回的reject对象，要借助try…catch…<br>b. 用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。<br>c. try…catch…内部的变量无法传递给下一个try…catch…,Promise和then&#x2F;catch内部定义的变量，能通过then链条的参数传递到下一个then&#x2F;catch，但是async&#x2F;await的try内部的变量，如果用let和const定义则无法传递到下一个try…catch…，只能在外层作用域先定义好。</p>
<p>promise的一些问题：<br>a. 一旦执行，无法中途取消，链式调用多个then中间不能随便跳出来<br>b. 错误无法在外部被捕捉到，只能在内部进行预判处理，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部<br>c. Promise内部如何执行，监测起来很难，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</p>
<h4 id="10-JS中的堆和栈，栈和队列有什么区别"><a href="#10-JS中的堆和栈，栈和队列有什么区别" class="headerlink" title="10.JS中的堆和栈，栈和队列有什么区别"></a>10.JS中的堆和栈，栈和队列有什么区别</h4><p>堆：堆是一种树形数据结构，读取相对复杂。堆是动态分配内存，内存大小不一，也不会自动释放。栈中的数据长度不定，且占空间比较大。便于开辟内存空间，更加方便存储。<strong>引用类型</strong>是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用。</p>
<p>栈：栈是一种线性的数据结构，读取规则是<strong>先进后出</strong>。栈中的数据占用的内存空间的大小是确定的，便于代码执行时的入栈、出栈操作，并由系统自动分配和自动释放内存可以及时得到回收，相对于堆来说，更加容易管理内存空间. <strong>基本类型</strong>是保存在栈内存中的简单数据段，它们的值都有固定的大小，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放，通过按值访问。</p>
<p>队列:队列是一种<strong>先进先出</strong>的数据结构。 队列在列表的末端增加项，在首端移除项。它允许在表的首端（队列头）进行删除操作，在表的末端（队列尾）进行插入操作；(回调队列)</p>
<h4 id="11-什么是闭包，如何使用它，为什么要使用它"><a href="#11-什么是闭包，如何使用它，为什么要使用它" class="headerlink" title="11.什么是闭包，如何使用它，为什么要使用它?"></a>11.什么是闭包，如何使用它，为什么要使用它?</h4><h5 id="一-定义-1"><a href="#一-定义-1" class="headerlink" title="(一)定义"></a>(一)定义</h5><p>闭包是一个存在于<strong>被外部函数嵌套</strong>的内部函数中的包含被引用变量的<strong>对象</strong></p>
<h5 id="二-产生条件"><a href="#二-产生条件" class="headerlink" title="(二)产生条件"></a>(二)产生条件</h5><p>1.函数存在嵌套</p>
<p>2.内部函数引用了外部函数的数据</p>
<p>3.外部函数被调用(内部函数被定义就会产生闭包,不需要调用内部函数)</p>
<h5 id="三-作用"><a href="#三-作用" class="headerlink" title="(三)作用"></a>(三)作用</h5><p>1.正常情况下,函数执行完后内部声明的局部变量不会存在。但是闭包可以让这些变量的值始终保持在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中。</p>
<p>2.正常情况下,函数外部不可以直接访问函数内部的局部变量。但是闭包可以读取函数内部的变量；</p>
<h4 id="12-new-操作符到底到了什么"><a href="#12-new-操作符到底到了什么" class="headerlink" title="12.new 操作符到底到了什么"></a>12.new 操作符到底到了什么</h4><p>new操作符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
<p>语法：new constructor[([arguments])]</p>
<p>其中，constructor是一个指定对象实例的类型的类或函数，arguments是一个用来被constructor调用的参数列表。 </p>
<p>var  a &#x3D; new A();</p>
<p>假设我们要创建一个构造函数A()的实例a，则必须使用new操作符。会经历以下4个步骤：</p>
<p>（1）创建一个空对象（var o&#x3D;new Object();）</p>
<p>（2）将空对象的原型赋值为构造函数A的原型（o.<strong>proto</strong>&#x3D;A.prototype;）</p>
<p>（3）执行构造函数中的代码，为空对象添加属性（A.call(o);），也可以理解为将构造器函数内部this指向新建的空对象。</p>
<p>（4）返回添加属性后的对象。</p>
<h4 id="13-改变this的指向中bind、call、-apply-的区别"><a href="#13-改变this的指向中bind、call、-apply-的区别" class="headerlink" title="13.改变this的指向中bind、call、 apply 的区别."></a>13.改变this的指向中bind、call、 apply 的区别.</h4><h5 id="一-this指向"><a href="#一-this指向" class="headerlink" title="(一)this指向"></a>(一)this指向</h5><ul>
<li>直接调用函数时，this指向window。</li>
<li>以方法的形式调用时，this指向包含调用方法的那个对象。</li>
<li>当以构造函数的形式调用时,this就是新创建的那个对象</li>
<li>使用call(),apply(),bind()调用时,this就是指向方法中的对象</li>
</ul>
<h5 id="二-三者区别"><a href="#二-三者区别" class="headerlink" title="(二)三者区别"></a>(二)三者区别</h5><p>接收参数的方式不同</p>
<h6 id="1-call"><a href="#1-call" class="headerlink" title="1.call()"></a>1.call()</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,a+b);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">       <span class="keyword">var</span> obj = &#123;</span><br><span class="line">       <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">      fn1.<span class="title function_">call</span>(obj,<span class="number">10</span>,<span class="number">20</span>); <span class="comment">// obj,30</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">fn2</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-apply"><a href="#2-apply" class="headerlink" title="2.apply()"></a>2.apply()</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">        <span class="comment">// arguments把a,b的1,2传给fn1。</span></span><br><span class="line">       fn1.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>); <span class="comment">// 3</span></span><br><span class="line">       fn1.<span class="title function_">apply</span>(<span class="variable language_">this</span>,[<span class="number">20</span>,<span class="number">30</span>]); <span class="comment">// 50</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn2</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="3-bind"><a href="#3-bind" class="headerlink" title="3.bind()"></a>3.bind()</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">       <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> a = fn1.<span class="title function_">bind</span>(obj);</span><br><span class="line">   <span class="comment">//此时this指向obj.  this.color则为obj的属性blue</span></span><br><span class="line">   <span class="title function_">a</span>(); <span class="comment">//blue</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="14-javascript-对象的深度克隆"><a href="#14-javascript-对象的深度克隆" class="headerlink" title="14 .javascript 对象的深度克隆?"></a>14 .javascript 对象的深度克隆?</h4><p>1、浅克隆</p>
<p>浅克隆之所以被称为浅克隆，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.</p>
<p>2.深克隆</p>
<p>2.1 JSON.parse方法</p>
<p>JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(oldObj));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缺点</p>
<ul>
<li>1.他无法实现对函数 、RegExp等特殊对象的克隆;</li>
<li>2.会抛弃对象的constructor,所有的构造函数会指向Object;</li>
<li>3.对象有循环引用,会报错;</li>
</ul>
<p>2.2<a target="_blank" rel="noopener" href="https://www.delftstack.com/zh/howto/javascript/javascript-deep-clone-an-object/#%E5%9C%A8-javascript-%E4%B8%AD%E4%BD%BF%E7%94%A8-lodash-%E5%BA%93%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1">在 JavaScript 中使用 Lodash 库深度克隆对象</a></p>
<p>Lodash 库具有浅拷贝和深拷贝的函数，即 <code>clone</code> 和 <code>clonedeep</code>。这是一个很棒的库，它允许我们仅导入所需的功能，而不导入完整的库。<code>clonedeep</code> 方法的工作方式是递归地复制值，然后保留所有对象继承，从而创建对象的真实副本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lodashClonedeep = <span class="built_in">require</span>(<span class="string">&#x27;lodash.clonedeep&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">c</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> deepClone = <span class="title function_">lodashClonedeep</span>(obj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里，我们从 lodash 加载 <code>clonedeep</code> 函数，并使用它来深克隆对象。它是一个经过良好测试和维护的库，但只能与 Node.js 一起使用，不能与 Vanilla JavaScript 一起使用。</p>
<h4 id="15-如何实现浏览器内多个标签页之间的通信"><a href="#15-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="15.如何实现浏览器内多个标签页之间的通信?"></a>15.如何实现浏览器内多个标签页之间的通信?</h4><h5 id="第一种——调用localStorage"><a href="#第一种——调用localStorage" class="headerlink" title="第一种——调用localStorage"></a>第一种——调用localStorage</h5><p>在一个标签页里面使用 localStorage.setItem(key,value)添加（修改、删除）内容；<br>在另一个标签页里面监听 storage 事件(这个事件可以通过更新localstorage来触发，而且当前在同一个浏览器下打开的所有同源页面都可以监听得到！)。<br>即可得到 localstorge 存储的值，实现不同标签页之间的通信。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存入</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;storage&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;    </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">key</span> + <span class="string">&quot;=&quot;</span> + event.<span class="property">newValue</span>);    </span><br><span class="line">        &#125;);    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="第二种——调用cookie-setInterval"><a href="#第二种——调用cookie-setInterval" class="headerlink" title="第二种——调用cookie+setInterval()"></a>第二种——调用cookie+setInterval()</h5><p>将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//存入</span><br><span class="line">document.cookie = `客户端B发送的消息:$&#123;num++&#125;`</span><br><span class="line">//监听</span><br><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">    //加入定时器，让函数每一秒就调用一次，实现页面刷新</span><br><span class="line">    console.log(&quot;cookie&quot;,document.cookie)</span><br><span class="line">  &#125;, 1000);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="16-哪些操作会造成内存泄漏"><a href="#16-哪些操作会造成内存泄漏" class="headerlink" title="16.哪些操作会造成内存泄漏?"></a>16.哪些操作会造成内存泄漏?</h4><h5 id="一-内存溢出"><a href="#一-内存溢出" class="headerlink" title="(一)内存溢出"></a>(一)内存溢出</h5><p>一种程序运行时出现的错误,当程序运行需要的内存超过了剩余内存时,就抛出内存溢出错误</p>
<h5 id="二-内存泄露"><a href="#二-内存泄露" class="headerlink" title="(二)内存泄露"></a>(二)内存泄露</h5><p>占用的内存没有及时释放,内存泄露记录就会产生内存溢出</p>
<p>操作:</p>
<ul>
<li>意外的全局变量: 无法被回收</li>
<li>定时器: 未被正确关闭，导致所引用的外部变量无法被释放</li>
<li>闭包</li>
</ul>
<h4 id="17-谈谈垃圾回收机制方式及内存管理"><a href="#17-谈谈垃圾回收机制方式及内存管理" class="headerlink" title="17.谈谈垃圾回收机制方式及内存管理"></a>17.谈谈垃圾回收机制方式及内存管理</h4><p>JS是使用垃圾回收的语言.</p>
<h5 id="基本思路是"><a href="#基本思路是" class="headerlink" title="基本思路是:"></a>基本思路是:</h5><p>确定哪个变量不会在使用,然后释放它占用的内存。这个过程是周期的。</p>
<h5 id="垃圾回收策略为"><a href="#垃圾回收策略为" class="headerlink" title="垃圾回收策略为:"></a>垃圾回收策略为:</h5><p>当变量进入上下文,比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑上讲.水远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。</p>
<h5 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理:"></a>内存管理:</h5><p>在使用垃圾回收机制的编程环境中,开发者一般不用关系内存管理.不过js运行在浏览器上,而浏览器的内存通常比软件的小(避免运行大量的网页耗尽系统内存使操作系统崩溃).所以优化内存占用的最好办法是保证执行代码时只保存必要数据,如果数据不在需要就设置为null触发垃圾回收机制</p>
<h4 id="18-谈谈你对this对象的理解"><a href="#18-谈谈你对this对象的理解" class="headerlink" title="18. 谈谈你对this对象的理解"></a>18. 谈谈你对this对象的理解</h4><p>this 是执行上下文中的一个属性，它指向一个对象</p>
<ul>
<li>直接调用函数时，this指向window。</li>
<li>以方法的形式调用时，this指向包含调用方法的那个对象。</li>
<li>当以构造函数的形式调用时,this就是新创建的那个对象</li>
<li>使用call(),apply(),bind()调用时,this就是指向方法中的对象</li>
</ul>
<h4 id="19-JS-中什么是类-伪-数组-如何将类-伪-数组转化为数组"><a href="#19-JS-中什么是类-伪-数组-如何将类-伪-数组转化为数组" class="headerlink" title="19.JS 中什么是类(伪)数组?如何将类(伪)数组转化为数组"></a>19.JS 中什么是类(伪)数组?如何将类(伪)数组转化为数组</h4><h5 id="一-定义-2"><a href="#一-定义-2" class="headerlink" title="(一)定义"></a>(一)定义</h5><p>伪数组也是对象，伪数组一般具有以下特点：</p>
<ul>
<li>按索引方式存储数据；</li>
<li>具有length属性；</li>
<li>没有数组的push、shift、pop等方法;</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj=&#123;</span><br><span class="line">    <span class="string">&quot;0&quot;</span>:<span class="string">&quot;dai&quot;</span>,</span><br><span class="line">    <span class="string">&quot;1&quot;</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="attr">length</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="二-转换"><a href="#二-转换" class="headerlink" title="(二)转换"></a>(二)转换</h5><h6 id="1-使用Array-prototype-slice-call"><a href="#1-使用Array-prototype-slice-call" class="headerlink" title="1.使用Array.prototype.slice.call()"></a>1.使用Array.prototype.slice.call()</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nodeList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//通过`Array`数组构造函数调用原型对象中的`slice()`方法，并通过`call()`方法改变其`slice()`方法的内部this指向，修改为`arguments`，即伪数组对象。通过这样的方法，我们就可以返回一个数组对象，这样就将伪数组转换为标准数组了</span></span><br><span class="line">               <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> arr = <span class="title function_">nodeList</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-使用Array-from"><a href="#2-使用Array-from" class="headerlink" title="2.使用Array.from()"></a>2.使用Array.from()</h6><p>Array.from(object,mapFunction,thisValue);<br>参数说明：</p>
<ol>
<li><code>object</code>：必须，要转换为数组的对象。</li>
<li><code>mapFunction</code>：可选，数组中每个元素要调用的函数。</li>
<li><code>thisValue</code>：可选，映射函数（mapFunction）中的this对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nodeList</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> arr = <span class="title function_">nodeList</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="20-什么是事件代理-事件委托"><a href="#20-什么是事件代理-事件委托" class="headerlink" title="20.什么是事件代理(事件委托) ?"></a>20.什么是事件代理(事件委托) ?</h4><h5 id="一-定义-3"><a href="#一-定义-3" class="headerlink" title="(一)定义"></a>(一)定义</h5><p>事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown……）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。</p>
<h5 id="二-事件传播分成三个阶段："><a href="#二-事件传播分成三个阶段：" class="headerlink" title="(二)事件传播分成三个阶段："></a>(二)事件传播分成三个阶段：</h5><p>捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件；</p>
<p>目标阶段：在目标节点上触发，称为“目标阶段”</p>
<p>冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；</p>
<h5 id="三-事件委托的优点"><a href="#三-事件委托的优点" class="headerlink" title="(三)事件委托的优点"></a>(三)事件委托的优点</h5><p>【1】可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件就非常棒</p>
<p>【2】可以实现当新增子对象时无需再次对其绑定（动态绑定事件）</p>
<h4 id="21-什么是强制-显式-类型转换-什么是隐式类型转换"><a href="#21-什么是强制-显式-类型转换-什么是隐式类型转换" class="headerlink" title="21.什么是强制(显式)类型转换?什么是隐式类型转换?"></a>21.什么是强制(显式)类型转换?什么是隐式类型转换?</h4><h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><p>会自动根据运算符进行类型转换。隐式类型转换的情况主要有以下几种</p>
<ul>
<li>如果表达式中同时存在字符串类型和数字类型的操作数，而使用加号+，会自动将数字转换成字符串。</li>
<li>如果表达式运算符为-、*、&#x2F;、%中的任意一个，此时 JavaScript 会自动将字符串转换成数字，对无法转换为数字的则转换为 NaN。</li>
<li>运算符为++或–时，JavaScript 会自动将字符串转换成数字，对无法转换为数字的则转换为 NaN。</li>
<li>运算符为&gt;或&lt;时，当两个操作数一个为字符串，一个为数字时，JavaScript 会自动将字符串转换成数字。</li>
<li>运算符为 &#x3D;&#x3D; ， 先转换类型再比较，&#x3D;&#x3D;&#x3D; 先判断类型，如果不是同一类型直接为false。</li>
<li>逻辑运算符(&amp;&amp;,||,!)自动转为布尔值(五大假值:0,NAN,空串,null,undefined)</li>
</ul>
<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>主要针对功能的需要或为了使代码变得清晰易读，人为地进行类型的转换。在 JavaScript 中，强制类型转换主要是通过调用全局函数 Number()、parseInt() 和 parseFloat() 来实现。</p>
<p><strong>注意null转为number为0,undefined转为number为NAN</strong></p>
<h4 id="22-谈一谈JS作用域链。"><a href="#22-谈一谈JS作用域链。" class="headerlink" title="22.谈一谈JS作用域链。"></a>22.谈一谈JS作用域链。</h4><h5 id="一-作用域"><a href="#一-作用域" class="headerlink" title="(一)作用域"></a>(一)作用域</h5><h6 id="1-分类"><a href="#1-分类" class="headerlink" title="1.分类"></a>1.分类</h6><ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域(es6才有let与const)</li>
</ul>
<h6 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h6><p>隔离变量,不同作用域下同名变量不会有冲突</p>
<h5 id="二-作用域链"><a href="#二-作用域链" class="headerlink" title="(二)作用域链"></a>(二)作用域链</h5><h6 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h6><p>函数能够形成作用域，如果函数被嵌套在另一个函数中，嵌套的函数也有自己的作用域，从这个函数的作用域往外形成的一条链， 这个链叫做作用域链。</p>
<h6 id="2-作用-1"><a href="#2-作用-1" class="headerlink" title="2.作用"></a>2.作用</h6><p>查找变量就是沿着作用域链查找,向上查找没有就报错</p>
<h4 id="23-如何理解JS原型链"><a href="#23-如何理解JS原型链" class="headerlink" title="23.如何理解JS原型链?"></a>23.如何理解JS原型链?</h4><h5 id="一-原型-原型对象"><a href="#一-原型-原型对象" class="headerlink" title="(一)原型(原型对象)"></a>(一)原型(原型对象)</h5><p>每个函数多有一个prototype属性,默认指向一个空对象(即原型对象)。原型对象中有一个属性constructor,它指向函数.</p>
<h5 id="二-原型链-隐式原型链"><a href="#二-原型链-隐式原型链" class="headerlink" title="(二)原型链(隐式原型链)"></a>(二)原型链(隐式原型链)</h5><p>每个对象多有一个–proto–(此处应为下划线)属性,在创建对象时自动添加,默认指向函数的原型对象,而原型对象又有隐式原型,这样就层层递进就构成了原型链。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Fn()&#123;&#125;;</span><br><span class="line">var fn=new Fn();</span><br><span class="line">//即fn.__proto__===Fn.prototype</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意,所有函数多是由Function构造的(包括自身),所以所有函数的–proto–&#x3D;&#x3D;Function.prototype</p>
<h5 id="三-查找对象属性"><a href="#三-查找对象属性" class="headerlink" title="(三)查找对象属性"></a>(三)查找对象属性</h5><ul>
<li>先查找本身,找到返回</li>
<li>如果没有,沿着原型链向上找,找到返回</li>
<li>一直找到object.prototype.–proto–(为null),则返回undefind</li>
</ul>
<h4 id="24-说一下-事件循环eventloop"><a href="#24-说一下-事件循环eventloop" class="headerlink" title="24.说一下 事件循环eventloop"></a>24.说一下 事件循环eventloop</h4><h5 id="主线程和任务队列"><a href="#主线程和任务队列" class="headerlink" title="主线程和任务队列"></a>主线程和任务队列</h5><p>单线程就意味着，所有任务需要排队。所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</p>
<h5 id="同步任务："><a href="#同步任务：" class="headerlink" title="同步任务："></a>同步任务：</h5><p>在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p>
<h5 id="异步任务："><a href="#异步任务：" class="headerlink" title="异步任务："></a>异步任务：</h5><p>不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<h5 id="具体来说："><a href="#具体来说：" class="headerlink" title="具体来说："></a>具体来说：</h5><ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，根据顺序循环调用异步任务，进入执行栈，开始执行，直到所有任务队列异步任务执行完</li>
<li>另外，任务队列中的每一个事件都是一个宏任务，执行栈执行的过程中也会有微任务，他们的执行顺序是：先执行同步代码，遇到异步宏任务则将异步宏任务放入宏任务队列中，遇到异步微任务则将异步微任务放入微任务队列中，当所有同步代码执行完毕后，再将异步微任务从队列中调入主线程执行，微任务执行完毕后再将异步宏任务从队列中调入主线程执行，一直循环直至所有任务执行完毕。</li>
</ol>
<p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。</p>
<h4 id="25-什么是防抖和节流-有什么区别-如何实现"><a href="#25-什么是防抖和节流-有什么区别-如何实现" class="headerlink" title="25.什么是防抖和节流?有什么区别?如何实现?"></a>25.什么是防抖和节流?有什么区别?如何实现?</h4><h5 id="一-防抖"><a href="#一-防抖" class="headerlink" title="(一)防抖:"></a>(一)防抖:</h5><p>防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发,只会执行最后一次(类似于回城.用户操作很频繁,但是只在规定时间后执行最后一次)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    let timeout;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        let context = this; // 保存this指向</span><br><span class="line">        let args = arguments; // 拿到event对象</span><br><span class="line"></span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = setTimeout(function()&#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="二-节流"><a href="#二-节流" class="headerlink" title="(二)节流"></a>(二)节流</h5><p>节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发,给浏览器充分时间解析代码.(技能cd.用户操作很频繁,但是规定时间内执行一次)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function throttled1(fn, delay = 500) &#123;</span><br><span class="line">    let oldtime = Date.now()</span><br><span class="line">    return function (...args) &#123;</span><br><span class="line">        let newtime = Date.now()</span><br><span class="line">        if (newtime - oldtime &gt;= delay) &#123;</span><br><span class="line">            fn.apply(null, args)</span><br><span class="line">            oldtime = Date.now()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h5><p>防抖在连续的事件，只需触发一次回调的场景有：</p>
<ul>
<li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li>
<li>手机号、邮箱验证输入检测</li>
<li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li>
</ul>
<p>节流在间隔一段时间执行一次回调的场景有：</p>
<ul>
<li>滚动加载，加载更多或滚到底部监听</li>
<li>搜索框，搜索联想功能</li>
</ul>
<h4 id="26-null-和undefined区别"><a href="#26-null-和undefined区别" class="headerlink" title="26.null 和undefined区别"></a>26.null 和undefined区别</h4><p>null表示”没有对象”，即该处不应该有值。典型用法是：<br>（1） 作为函数的参数，表示该函数的参数不是对象。<br>（2） 作为对象原型链的终点。</p>
<p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：<br>（1）变量被声明了，但没有赋值时，就等于undefined。<br>（2 ) 调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>（3）对象没有赋值的属性，该属性的值为undefined。<br>（4）函数没有返回值时或者return后面什么也没有，返回undefined。</p>
<p>undefined和null在if语句中，都会被<strong>自动转为false</strong>，相等运算符甚至直接报告两者相等。</p>
<p>转为数值时，值不一样，<strong>undefined转为数值NaN，null转为数值0。</strong></p>
<h4 id="27-手写Ajax，XMLHtpRequest"><a href="#27-手写Ajax，XMLHtpRequest" class="headerlink" title="27.手写Ajax，XMLHtpRequest."></a>27.手写Ajax，XMLHtpRequest.</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建XMLHttpRequest对象</span></span><br><span class="line"> <span class="keyword">var</span> xhr=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">//设置请求信息</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;Get&#x27;</span>,<span class="string">&#x27;/URL/);//第三个参数默认为true 异步 ，false为同步</span></span><br><span class="line"><span class="string">//发送请求到服务器</span></span><br><span class="line"><span class="string">xhr.send();//get方式不需要参数，post方式需要把body部分以字符串或者FormData对象</span></span><br><span class="line"><span class="string">//接收响应</span></span><br><span class="line"><span class="string">xhr.onreadystatechang=functioin()&#123; // 状态发生变化时，函数被回调</span></span><br><span class="line"><span class="string">    if(xhr.readystate===4)&#123;    // 成功完成</span></span><br><span class="line"><span class="string">        if(xhr.status===200)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">        //成功，拿到响应文本</span></span><br><span class="line"><span class="string">        success(xhr.responseText);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        else&#123;//失败，返回响应码</span></span><br><span class="line"><span class="string">        fail(xhr.status)；</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h4 id="28-请解释变量声明提升。"><a href="#28-请解释变量声明提升。" class="headerlink" title="28.请解释变量声明提升。"></a>28.请解释变量声明提升。</h4><p>变量提升:可以使用var定义变量，变量如果没有赋值，那变量的初始值为undefined</p>
<p>函数提升:通过function声明的函数在定义之前可以直接调用(使用函数表达式没有函数提升)</p>
<p>注意:先执行变量提升,在执行函数提升,最后在赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a=1;</span><br><span class="line">function a()&#123;&#125;</span><br><span class="line">console.log(a)//1 &lt;==&gt; a=undefined =&gt; a=function =&gt; a=1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="29-实现继承的多种方式和优缺点"><a href="#29-实现继承的多种方式和优缺点" class="headerlink" title="29.实现继承的多种方式和优缺点"></a>29.实现继承的多种方式和优缺点</h4><h5 id="一-用原型链"><a href="#一-用原型链" class="headerlink" title="(一)用原型链"></a>(一)用原型链</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Animal()&#123;</span><br><span class="line">        this.name = &quot;animal&quot;;</span><br><span class="line">	    this.arrt=[1,2]</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype = &#123;</span><br><span class="line">        sayName : function()&#123;</span><br><span class="line">              alert(this.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">function Dog()&#123;</span><br><span class="line">	this.color = &quot;灰色&quot;</span><br><span class="line">&#125;</span><br><span class="line">//核心代码</span><br><span class="line">Dog.prototype = new Animal(); </span><br><span class="line">Dog.prototype.constructor=Dog;</span><br><span class="line"></span><br><span class="line">var dog = new Dog();</span><br><span class="line">var dog1=new Dog();</span><br><span class="line">console.log(dog);</span><br><span class="line">dog.arrt.push(5);</span><br><span class="line">console.log(dog1);//1 2 5</span><br><span class="line">dog.sayColor();</span><br><span class="line">dog.sayName();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.非常纯粹的继承关系，实例是子类的实例，也是父类的实例</span><br><span class="line">2.父类新增原型方法/原型属性，子类都能访问到</span><br><span class="line">3.简单，易于实现</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缺点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.包含引用类型值的原型属性会被所有实例共享，这会导致对一个实例的修改会影响另一个实例。</span><br><span class="line">2.在创建子类型的实例时，不能向超类型的构造函数中传递参数。由于这两个问题的存在，实践中很少单独使用原型链。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="二-构造函数"><a href="#二-构造函数" class="headerlink" title="(二)构造函数"></a>(二)构造函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.colors = [&quot;red&quot;,&quot;gray&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function Dog(name)&#123;</span><br><span class="line">	//继承了Animal</span><br><span class="line">	Animal.call(this,&quot;mary&quot;);//在子类型构造函数的内部调用超类型构造函数</span><br><span class="line">	this.color = &quot;gray&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.sayName = function()&#123;</span><br><span class="line">	alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var dog = new Dog();</span><br><span class="line">var dog1=new Dog();</span><br><span class="line">dog.colors.push(&quot;hhh&quot;);</span><br><span class="line">console.log(dog.colors);//red gray hhh</span><br><span class="line">console.log(dog1.colors);//red gray</span><br><span class="line">Animal.prototype.swif=&quot;hua&quot;;</span><br><span class="line">console.log(dog.swif);//undefined</span><br><span class="line">var animal = new Animal();</span><br><span class="line">console.log(animal);   //如果将函数定义在构造函数中，函数复用无从谈起</span><br><span class="line">dog.sayName();	 //在超类型的原型中定义的方法，对于子类型而言是无法看到的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p> 1.解决了1中，子类实例共享父类引用属性的问题<br> 2.创建子类实例时，可以向父类传递参数<br> 3.可以实现多继承（call多个父类对象）</p>
<p>缺点：</p>
<p>1.实例并不是父类的实例，只是子类的实例<br>2.只能继承父类的实例属性和方法，不能继承父类原型属性&#x2F;方法<br>3.无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>
<h5 id="三-原型链-构造函数"><a href="#三-原型链-构造函数" class="headerlink" title="(三)原型链+构造函数"></a>(三)原型链+构造函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.colors = [&quot;red&quot;,&quot;gray&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function Dog(name)&#123;</span><br><span class="line">	//继承了Animal（属性）</span><br><span class="line">	Animal.call(this,name);</span><br><span class="line">	this.color = &quot;gray&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.sayName = function()&#123;</span><br><span class="line">	alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">//继承方法</span><br><span class="line">Dog.prototype = new Animal();</span><br><span class="line">Dog.prototype.constructor = Animal;</span><br><span class="line"> </span><br><span class="line">var dog = new Dog();</span><br><span class="line">dog.colors.push(&quot;hhh&quot;);</span><br><span class="line">console.log(dog);</span><br><span class="line">var animal = new Animal();</span><br><span class="line">console.log(animal);</span><br><span class="line">dog.sayName();	//可以调用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.可以继承实例属性/方法，也可以继承原型属性/方法</span><br><span class="line">2.既是子类的实例，也是父类的实例</span><br><span class="line">3.不存在引用属性共享问题</span><br><span class="line">4.通过call继承父类的基本属性和引用属性并保留能传参的优点</span><br><span class="line">5.函数可复用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="30-jQuery-获取dom和原生获取dom有什么区别"><a href="#30-jQuery-获取dom和原生获取dom有什么区别" class="headerlink" title="30.jQuery 获取dom和原生获取dom有什么区别."></a>30.jQuery 获取dom和原生获取dom有什么区别.</h4><p>DOM对象：用原生 js 获取过来的对象就是 dom 对象</p>
<p>jQuery对象： 用 jQuery 方式获取过来的对象就是 jQuery 对象，本质：通过$把DOM元素进行包装后产生的对象（伪数组形式存储）</p>
<p>jQuery 对象只能使用 jQuery 方法，DOM 对象则使用原生的 JavaScript 属性和方法</p>
<h4 id="31-说三种去除两端空格的方法"><a href="#31-说三种去除两端空格的方法" class="headerlink" title="31.说三种去除两端空格的方法?"></a>31.说三种去除两端空格的方法?</h4><h5 id="1、replace正则匹配方法"><a href="#1、replace正则匹配方法" class="headerlink" title="1、replace正则匹配方法"></a>1、replace正则匹配方法</h5><p>　　去除字符串内所有的空格：str &#x3D; str.replace(&#x2F;\s*&#x2F;g,””);</p>
<p>　　去除字符串内两头的空格：str &#x3D; str.replace(&#x2F;^\s|\s$&#x2F;g,””);</p>
<p>　　去除字符串内左侧的空格：str &#x3D; str.replace(&#x2F;^\s*&#x2F;,””);</p>
<p>　　去除字符串内右侧的空格：str &#x3D; str.replace(&#x2F;(\s*$)&#x2F;g,””);</p>
<h5 id="2、trim方法"><a href="#2、trim方法" class="headerlink" title="2、trim方法"></a>2、trim方法</h5><p>​       trim()方法是用来删除字符串两端的空白字符并返回，trim方法并不影响原来的字符串本身，它返回的是一个新的字符串。</p>
<p>　　缺陷：只能去除字符串两端的空格，不能去除中间的空格</p>
<h5 id="3、JQ方法：-trim-str-方法"><a href="#3、JQ方法：-trim-str-方法" class="headerlink" title="3、JQ方法：$.trim(str)方法"></a>3、JQ方法：$.trim(str)方法</h5><p>​       $.trim() 函数用于去除字符串两端的空白字符。</p>
<p>　　<strong>注意：</strong>$.trim()函数会移除字符串开始和末尾处的所有换行符，空格(包括连续的空格)和制表符。如果这些空白字符在字符串中间时，它们将被保留，不会被移除。</p>
<h3 id="四-Vue"><a href="#四-Vue" class="headerlink" title="四.Vue"></a>四.Vue</h3><h4 id="1-说说你对SPA单页面的理解，它的优缺点分别是什么"><a href="#1-说说你对SPA单页面的理解，它的优缺点分别是什么" class="headerlink" title="1.说说你对SPA单页面的理解，它的优缺点分别是什么?"></a>1.说说你对SPA单页面的理解，它的优缺点分别是什么?</h4><h5 id="一、什么是SPA"><a href="#一、什么是SPA" class="headerlink" title="一、什么是SPA"></a>一、什么是SPA</h5><p>SPA（single-page application），翻译过来就是单页应用<code>SPA</code>是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（<code>HTML</code>、<code>JavaScript</code>和<code>CSS</code>）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面举个例子来讲就是一个杯子，早上装的牛奶，中午装的是开水，晚上装的是茶，我们发现，变的始终是杯子里的内容，而杯子始终是那个杯子</p>
<h5 id="二、SPA和MPA的区别"><a href="#二、SPA和MPA的区别" class="headerlink" title="二、SPA和MPA的区别"></a>二、SPA和MPA的区别</h5><p>上面大家已经对单页面有所了解了，下面来讲讲多页应用MPA（MultiPage-page application），翻译过来就是多页应用在<code>MPA</code>中，每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载<code>html</code>、<code>css</code>、<code>js</code>文件，公共文件则根据需求按需加载</p>
<h5 id="单页应用优缺点"><a href="#单页应用优缺点" class="headerlink" title="单页应用优缺点"></a>单页应用优缺点</h5><p>优点：</p>
<ul>
<li>具有桌面应用的即时性、网站的可移植性和可访问性</li>
<li>用户体验好、快，内容的改变不需要重新加载整个页面</li>
<li>良好的前后端分离，分工更明确</li>
</ul>
<p>缺点：</p>
<ul>
<li>不利于搜索引擎的抓取</li>
<li>首次渲染速度相对较慢</li>
</ul>
<h4 id="2-直接给一个数组项赋值-Vue-能检测到变化吗"><a href="#2-直接给一个数组项赋值-Vue-能检测到变化吗" class="headerlink" title="2.直接给一个数组项赋值,Vue 能检测到变化吗?"></a>2.直接给一个数组项赋值,Vue 能检测到变化吗?</h4><p>由于 JavaScript 的限制，Vue 不能检测到.如果想监测有两种方法</p>
<h5 id="一-Vue-set-target-key-value-vm-set"><a href="#一-Vue-set-target-key-value-vm-set" class="headerlink" title="(一)Vue.set(target,key,value)||vm.$set()"></a>(一)Vue.set(target,key,value)||vm.$set()</h5><p><strong>target</strong>：要更改的数据源(可以是对象或者数组)</p>
<p><strong>key</strong>：要更改的具体数据(可以是字符串和数字)</p>
<p><strong>value</strong> ：重新赋的值</p>
<p>用法：向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">            <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,  </span><br><span class="line">            <span class="attr">data</span>:&#123;</span><br><span class="line">                <span class="attr">json</span>:&#123;</span><br><span class="line">                    <span class="attr">username</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">                    <span class="attr">age</span>:<span class="number">20</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">msg</span>:<span class="string">&quot;hello&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//vm.json.username = &quot;李四&quot;  修改属性可以</span></span><br><span class="line">        <span class="comment">//如果对之前存在的属性username，age进行更改是可以的，因为内部通过Object.defineProperty实现了数据双向绑定，但是对与后续新增添的属性例如sex，那么视图是没有办法渲染的</span></span><br><span class="line">      <span class="comment">//  vm.json[&quot;sex&quot;]=&quot;男&quot;  //发现页面不会渲染sex这个属性</span></span><br><span class="line">      <span class="title class_">Vue</span>.<span class="title function_">set</span>(vm.<span class="property">json</span>, <span class="string">&quot;sex&quot;</span>, <span class="string">&quot;女&quot;</span>)</span><br><span class="line">&lt;/script&gt;        </span><br></pre></td></tr></table></figure>

<h5 id="二-调用Vue已经封装好的方法"><a href="#二-调用Vue已经封装好的方法" class="headerlink" title="(二)调用Vue已经封装好的方法"></a>(二)调用Vue已经封装好的方法</h5><p>push(),pop(),shift().unshift(),splice(),sort(),remove()</p>
<p>&#x2F;&#x2F; Array.prototype.splice<br>vm.items.splice(newLength)</p>
<h4 id="3-在哪个生命周期内调用异步请求"><a href="#3-在哪个生命周期内调用异步请求" class="headerlink" title="3.在哪个生命周期内调用异步请求?"></a>3.在哪个生命周期内调用异步请求?</h4><p>可以在钩子函数 created、beforeMount、mounted 中进行调用，<br>因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。<br>但是，推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li><p>能更快获取到服务端数据，减少页面 loading 时间</p>
</li>
<li><p>SSR(服务器渲染) 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性</p>
</li>
</ul>
<h4 id="4-能说下vue-router-中常用的hash-和history-路由模式实现原理吗"><a href="#4-能说下vue-router-中常用的hash-和history-路由模式实现原理吗" class="headerlink" title="4.能说下vue-router 中常用的hash 和history 路由模式实现原理吗?"></a>4.能说下vue-router 中常用的hash 和history 路由模式实现原理吗?</h4><h5 id="1-hash模式实现原理"><a href="#1-hash模式实现原理" class="headerlink" title="1. hash模式实现原理"></a>1. hash模式实现原理</h5><p>早期前端路由的实现就是基于<code>location.hash</code>来实现的，其实实现原理很简单，<code>location.hash</code>的值就是URL中#后面的内容</p>
<p>hash路由模式的实现主要是基于下面几个特性</p>
<ul>
<li>URL中hash值只是客户端的一种状态，也就是说当向服务器端发送请求时，hash部分不会被发送</li>
<li>hash值得改变，都会在浏览器的访问历史中增加一个记录，因此我们能通过浏览器的回退，前进按钮控制hash的切换</li>
<li>可以通过<router-link>标签，并设置to属性，当用户点击这个便签后，URL的hash值会发生改变；或者使用JavaScript来对<code>location.hash</code>进行赋值，改变URL的hash值</li>
<li>我们可以使用hashchange事件来监听hash值的变化，从而对页面进行跳转（渲染）</li>
</ul>
<h5 id="2-history模式的实现原理"><a href="#2-history模式的实现原理" class="headerlink" title="2. history模式的实现原理"></a>2. history模式的实现原理</h5><p>HTML5提供了History API来实现URL的变化，其中最主要的两个API有以下两个<br> history.pushState()和history.replaceState()。这两个API可以在不进行刷新的情况下，操作浏览器的历史记录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.pushState(<span class="keyword">null</span>,<span class="keyword">null</span>,path)</span><br><span class="line"><span class="built_in">window</span>.history.replaceState(<span class="keyword">null</span>,<span class="keyword">null</span>,path)</span><br></pre></td></tr></table></figure>

<p>history路由模式的主要基于存在下面几个特性：</p>
<ul>
<li>pushState和replaceState两个API操作实现URL的变化</li>
<li>我们可以使用popstate事件来监听URL的变化，从而对页面进行跳转（渲染）</li>
<li>history.pushState()和history.replaceState()不会触发popstate事件，这时我们需要手动触发页面跳转（渲染）</li>
</ul>
<h5 id="3-history的问题"><a href="#3-history的问题" class="headerlink" title="3. history的问题"></a>3. history的问题</h5><p>History路由模式虽然好看，但是这种路由模式想要玩好，还需要后台配置支持，因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器访问<code>http://outsite.com/user/id</code>返回404,这就不好看了。<br> 所以呢，你要在服务器增加一个覆盖所有情况的候选资源：如果URL匹配不到任何静态资源，则应该返回同一个index.html页面，这个页面就是你app依赖的页面。</p>
<h4 id="5-nextTick适用场景和原理"><a href="#5-nextTick适用场景和原理" class="headerlink" title="5.nextTick适用场景和原理?"></a>5.nextTick适用场景和原理?</h4><h5 id="1-使用原理"><a href="#1-使用原理" class="headerlink" title="1.使用原理"></a>1.使用原理</h5><ol>
<li>vue是异步执行dom更新的，一旦观察到数据变化，vue就会开启一个队列，然后把在同一事件循环当中观察到数据变化的watcher推送进这个队列，如果这个watcher被触发多次，只会被推送到队列一次，这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和dom操作，这样可以提高渲染效率。</li>
<li>如果要获取更新后的dom元素，可以使用vue内置的$nextTick(回调函数)方法，参数是一个函数。它的作用类似setTimeout，进行执行异步的操作。</li>
</ol>
<h5 id="2-应用"><a href="#2-应用" class="headerlink" title="2.应用"></a>2.应用</h5><p>vue中的nextTick主要用于处理数据动态变化后，DOM还未及时更新的问题，用nextTick可以获取数据更新后最新dom的变化。</p>
<h5 id="3-场景："><a href="#3-场景：" class="headerlink" title="3.场景："></a>3.场景：</h5><p>1）第三方插件，在vue生成的某些dom动态发生变化时重新应用该插件。<br>2）视图更新之后，基于新的视图进行操作。</p>
<h4 id="6-vue-cli-用自定义的组件-有遇到过哪些问题吗"><a href="#6-vue-cli-用自定义的组件-有遇到过哪些问题吗" class="headerlink" title="6.vue-cli 用自定义的组件?有遇到过哪些问题吗?"></a>6.vue-cli 用自定义的组件?有遇到过哪些问题吗?</h4><p>第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default {</p>
<p>第二步：在需要用的页面（组件）中导入：import smithButton from ‘..&#x2F;components&#x2F;smithButton.vue’</p>
<p>第三步：注入到vue的子组件的components属性上面,components:{smithButton}</p>
<p>第四步：在template视图view中使用，</p>
<p> 问题有：smithButton命名，使用的时候则smith-button。</p>
<h4 id="7-vue-delete-和delete-的区别"><a href="#7-vue-delete-和delete-的区别" class="headerlink" title="7.vue.delete 和delete 的区别."></a>7.vue.delete 和delete 的区别.</h4><p>delete和和Vue.delete都是对数组或对象进行删除的方法。这两种方法对于对象来说其实是没有区别的，使用方法会直接删除对象的属性（物理删除）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">name: &#x27;fufu&#x27;,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;</span><br><span class="line">// delete obj.age  =&gt; &#123;name: &#x27;fufu&#x27;&#125;</span><br><span class="line">// Vue.delete(obj, &#x27;age&#x27;) =&gt; &#123;name: &#x27;fufu&#x27;&#125;</span><br><span class="line">// 测试发现对于对象来说delete和Vue.delete是没有任何区别的</span><br></pre></td></tr></table></figure>

<p>但是这两种方法对于数组来说就有区别了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4,5]</span><br><span class="line">delete arr[2]  //[1,2,empty,4,5]</span><br><span class="line">Vue.delete arr[2]  //[1,2,4,5]</span><br></pre></td></tr></table></figure>

<p>delete只是被删除的元素变成了 empty&#x2F;undefined 其他的元素的键值还是不变。数组长度也不变。（逻辑删）<br>Vue.delete是直接删除该元素，长度发生变化。（物理删）</p>
<h4 id="8-Vue-中MVVM"><a href="#8-Vue-中MVVM" class="headerlink" title="8.Vue 中MVVM"></a>8.Vue 中MVVM</h4><p>MVVM其实表示的是 Model-View-ViewModel</p>
<ul>
<li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互:如data中数据</li>
<li>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面(模板)</li>
<li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁</li>
</ul>
<p>在MVVM的架构下，<strong>View层和Model层并没有直接联系，而是通过ViewModel层进行交互。</strong> ViewModel层通过<strong>双向数据绑定</strong>将View层和Model层连接了起来，使得View层和Model层的同步工作完全是自动的。<br> 因此开发者只需关注业务逻辑，无需手动操作DOM。</p>
<h4 id="9-vue的diff理解"><a href="#9-vue的diff理解" class="headerlink" title="9.vue的diff理解."></a>9.vue的diff理解.</h4><h5 id="一-定义-4"><a href="#一-定义-4" class="headerlink" title="(一)定义"></a>(一)定义</h5><p>diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom。</p>
<h5 id="二-特点"><a href="#二-特点" class="headerlink" title="(二)特点"></a>(二)特点</h5><ul>
<li>比较只会在同层级进行, 不会跨层级比较</li>
<li>在diff比较的过程中，循环从两边向中间比较</li>
</ul>
<h5 id="三-过程"><a href="#三-过程" class="headerlink" title="(三)过程"></a>(三)过程</h5><ol>
<li><p>当数据发生改变时，订阅者<code>watcher</code>就会调用<code>patch</code>给真实的<code>DOM</code>打补丁</p>
</li>
<li><p>patch函数前两个参数位为<code>oldVnode</code> 和 <code>Vnode</code> ，分别代表新的节点和之前的旧节点，主要做了四个判断：</p>
<ul>
<li>没有新节点，直接触发旧节点的<code>destory</code>钩子</li>
<li>没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 <code>createElm</code></li>
<li>旧节点和新节点自身一样，通过 <code>sameVnode</code> 判断节点是否一样，一样时，直接调用 <code>patchVnode</code>去处理这两个节点</li>
<li>旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点</li>
</ul>
</li>
<li><p>通过<code>SameVnode</code>进行判断，相同则调用<code>patchVnode</code>方法</p>
<p><code>patchVnode</code>方法做了以下操作：</p>
<ul>
<li>找到对应的真实<code>dom</code>，称为<code>el</code></li>
<li>如果都有都有文本节点且不相等，将<code>el</code>文本节点设置为<code>Vnode</code>的文本节点</li>
<li>如果<code>oldVnode</code>有子节点而<code>VNode</code>没有，则删除<code>el</code>子节点</li>
<li>如果<code>oldVnode</code>没有子节点而<code>VNode</code>有，则将<code>VNode</code>的子节点真实化后添加到<code>el</code></li>
<li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点</li>
</ul>
</li>
<li><p>updateChildren主要做了以下操作：</p>
<ul>
<li>设置新旧<code>VNode</code>的头尾指针</li>
<li>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用<code>patchVnode</code>进行<code>patch</code>重复流程、调用<code>createElem</code>创建一个新节点，从哈希表寻找 <code>key</code>一致的<code>VNode</code> 节点再分情况操作</li>
</ul>
</li>
</ol>
<h4 id="10-为什么要在列表组件中写key-其作用是什么"><a href="#10-为什么要在列表组件中写key-其作用是什么" class="headerlink" title="10.为什么要在列表组件中写key,其作用是什么?"></a>10.为什么要在列表组件中写key,其作用是什么?</h4><h5 id="1-虚拟DOM中key的作用："><a href="#1-虚拟DOM中key的作用：" class="headerlink" title="1.虚拟DOM中key的作用："></a>1.虚拟DOM中key的作用：</h5><p>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p>
<h5 id="2-对比规则："><a href="#2-对比规则：" class="headerlink" title="2.对比规则："></a>2.对比规则：</h5><p>(1).旧虚拟DOM中找到了与新虚拟DOM相同的key： </p>
<p>​        ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！ </p>
<p>​        ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。 </p>
<p>(2).旧虚拟DOM中未找到与新虚拟DOM相同的key </p>
<p>​        创建新的真实DOM，随后渲染到到页面。 </p>
<h5 id="3-用index作为key可能会引发的问题："><a href="#3-用index作为key可能会引发的问题：" class="headerlink" title="3.用index作为key可能会引发的问题："></a>3.用index作为key可能会引发的问题：</h5><ol>
<li><p>若对数据进行：逆序添加、逆序删除等破坏顺序操作: </p>
<p>​           会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。 </p>
</li>
<li><p>如果结构中还包含输入类的DOM：</p>
</li>
</ol>
<p>​                 会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题。 </p>
<h5 id="4-开发中如何选择key"><a href="#4-开发中如何选择key" class="headerlink" title="4.开发中如何选择key?:"></a>4.开发中如何选择key?:</h5><p>​		1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。 </p>
<p>​		2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示,使用index作为key是没有问题的。 </p>
<h4 id="11-为什么虚拟dom会提高性能"><a href="#11-为什么虚拟dom会提高性能" class="headerlink" title="11.为什么虚拟dom会提高性能?"></a>11.为什么虚拟dom会提高性能?</h4><p>虚拟dom(virtual dom) 其实就是一个JavaScript对象，通过这个JavaScript对象来描述真实dom。</p>
<p><strong>真实dom</strong>：以前没有虚拟dom，如果需要比较两个页面的差异，我们需要通过对真实dom进行比对。真实dom节点是非常复杂的，它里面会绑定的事件，它会有属性，背后会有各种方法，会频繁触发重排与重绘，所以两个真实dom比对，非常耗性能。</p>
<p>总损耗 &#x3D; 真实DOM完全增删改 + （可能较多的节点）重排与重绘</p>
<p><strong>虚拟dom</strong>：<strong>相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提髙性能。</strong></p>
<p>总损耗 &#x3D; 虚拟DOM增删改 + （与Diff算法效率有关）真实DOM差异增删改 + （较少的节点）重排与重绘</p>
<p>具体实现步骤如下：</p>
<ol>
<li>用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档当中;</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异;</li>
<li>把步骤2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。</li>
</ol>
<h4 id="12-怎么定义vue-router的动态路由-怎么获取传递过来的动态参数"><a href="#12-怎么定义vue-router的动态路由-怎么获取传递过来的动态参数" class="headerlink" title="12.怎么定义vue router的动态路由?怎么获取传递过来的动态参数"></a>12.怎么定义vue router的动态路由?怎么获取传递过来的动态参数</h4><p>可以通过传<strong>query</strong> ,<strong>params</strong>两种参数的方式,根据传参展示对应路由组件</p>
<h5 id="一-传query参数"><a href="#一-传query参数" class="headerlink" title="(一)传query参数"></a>(一)传query参数</h5><h6 id="1-跳转-可用path与name"><a href="#1-跳转-可用path与name" class="headerlink" title="1.跳转(可用path与name)"></a>1.跳转(可用path与name)</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 声明式导航</span><br><span class="line">&lt;router-link :to=&quot;`/users?uname=$&#123;james&#125;`&quot;&gt;按钮&lt;/router-link&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123; name: &#x27;users&#x27;, query: &#123; uname: james &#125;&#125;&quot;&gt;按钮&lt;/router-link&gt;</span><br><span class="line">// 编程式导航</span><br><span class="line">this.$router.push(&#123; name: &#x27;users&#x27;, query:&#123; uname:james &#125;&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="二-传params参数"><a href="#二-传params参数" class="headerlink" title="(二)传params参数"></a>(二)传params参数</h5><h6 id="1-声明"><a href="#1-声明" class="headerlink" title="1.声明"></a>1.声明</h6><p>在初始化路由时,声明接收params参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path:&quot;/user/:uname&quot;</span><br></pre></td></tr></table></figure>

<h6 id="2-跳转-对象写法只能用name"><a href="#2-跳转-对象写法只能用name" class="headerlink" title="2.跳转(对象写法只能用name)"></a>2.跳转(对象写法只能用name)</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 声明式</span><br><span class="line">&lt;router-link :to=&quot;`/user/$&#123;wade&#125;`&quot;&gt;按钮&lt;/router-link&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123; name: &#x27;users&#x27;, params: &#123; uname: wade &#125;&#125;&quot;&gt;按钮&lt;/router-link&gt;</span><br><span class="line">// 方法2：</span><br><span class="line">this.$router.push(&#123;name:&#x27;users&#x27;,params:&#123;uname:wade&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="三-query-和-params-之间的区别是什么？"><a href="#三-query-和-params-之间的区别是什么？" class="headerlink" title="(三)query 和 params 之间的区别是什么？"></a>(三)query 和 params 之间的区别是什么？</h5><ol>
<li>query 可用 path,name 来引入，params 需要用 name 来引入</li>
<li>接收参数时，分别是this.$route.query.name  和 this.$route.params.name (注意：是$route而不是$router)</li>
<li>query 更加类似于我们 ajax 中 get 传参，params 则类似于 post，前者在浏览器的地址中显示，params 不显示</li>
<li>params 传值一刷新就没了，query 传值刷新还存在</li>
</ol>
<h4 id="13-vue-router有哪几种导航钩子-路由守卫"><a href="#13-vue-router有哪几种导航钩子-路由守卫" class="headerlink" title="13.vue -router有哪几种导航钩子(路由守卫)?"></a>13.vue -router有哪几种导航钩子(路由守卫)?</h4><h5 id="一-全局守卫"><a href="#一-全局守卫" class="headerlink" title="(一)全局守卫"></a>(一)全局守卫</h5><h6 id="1-在router-x2F-index-js中-创建一个对象接收VueRouter"><a href="#1-在router-x2F-index-js中-创建一个对象接收VueRouter" class="headerlink" title="1.在router&#x2F;index.js中,创建一个对象接收VueRouter({})"></a>1.在router&#x2F;index.js中,创建一个对象接收VueRouter({})</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const router=new VueRouter(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="2-设置router的前-x2F-后置路由"><a href="#2-设置router的前-x2F-后置路由" class="headerlink" title="2.设置router的前&#x2F;后置路由"></a>2.设置router的前&#x2F;后置路由</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//前置路由守卫</span><br><span class="line">router.beforEach((to,from,next)=&gt;&#123;&#125;)</span><br><span class="line">//后置路由守卫,一般设置标题</span><br><span class="line">router.afterEach((to,from)=&gt;&#123;</span><br><span class="line">	if(to.meta.title)&#123;</span><br><span class="line">		document.title=to.meta.title</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		document.title=&quot;默认值&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>参数解释:</p>
<p>to<br>即将要进入的目标 路由对象（$route）</p>
<p>from<br>当前导航正要离开的路由对象（$route）</p>
<p>next<br>路由确认回调函数，类似 Promise 中的 resolve 函数，一定要确保调用 next 函数，但是后续的导航行为将依赖 next 方法的调用参数</p>
<p>next() : 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)</p>
<p>next(false) : 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址</p>
<p>next(‘&#x2F;‘) 或者 next({ path: ‘&#x2F;‘ }) : 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航</p>
<h5 id="二-独享守卫"><a href="#二-独享守卫" class="headerlink" title="(二)独享守卫"></a>(二)独享守卫</h5><p>在VueRouter({})的配置项中routers中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beforeEnter:(to,from,next)=&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三-组件守卫"><a href="#三-组件守卫" class="headerlink" title="(三)组件守卫"></a>(三)组件守卫</h5><p>在路由组件的配置项中加入</p>
<p>beforeRouteEnter:当路由解析完成，并中指定的组件渲染之前（组件 beforeCreate 之前),不能这里通过 this 访问组件实例，需要通过 next 回调来进行调用</p>
<p>beforeRouteUpdate:在当前路由改变，但是该组件被复用时调用</p>
<p>beforeRouteLeave:导航离开该组件的对应路由时调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    // 不！能！获取组件实例 `this`</span><br><span class="line">    // 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">  	next(vm =&gt; &#123;</span><br><span class="line">      // vm...</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-v-model-是什么-怎么使用"><a href="#14-v-model-是什么-怎么使用" class="headerlink" title="14.v-model 是什么?怎么使用?"></a>14.v-model 是什么?怎么使用?</h4><p>v-model 是Vue框架的一种内置的API指令，本质是一种语法糖写法。它负责监听用户的输入事件以更新数据(双向数据绑定)</p>
<p>v-model的原理:</p>
<ol>
<li>v-bind绑定value属性的值；</li>
<li>v-on绑定input事件监听到函数中，函数会获取最新的值赋值到绑定的属性中；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;id&quot;&gt;</span><br><span class="line">//等价于</span><br><span class="line">&lt;input :value=&quot;id&quot; @input=&quot;id=$event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="15-自定义指令-v-check、-v-focus-的方法有哪些-它有哪些钩子函数-有哪些钩子函数参数"><a href="#15-自定义指令-v-check、-v-focus-的方法有哪些-它有哪些钩子函数-有哪些钩子函数参数" class="headerlink" title="15.自定义指令(v-check、 v-focus) 的方法有哪些?它有哪些钩子函数?有哪些钩子函数参数?"></a>15.自定义指令(v-check、 v-focus) 的方法有哪些?它有哪些钩子函数?有哪些钩子函数参数?</h4><p>自定义指令分为<strong>局部指令</strong>与<strong>全局指令</strong>,**定义时不加 v- ,使用时加 v- **</p>
<h5 id="一-局部指令-写在配置对象的directives中"><a href="#一-局部指令-写在配置对象的directives中" class="headerlink" title="(一)局部指令(写在配置对象的directives中)"></a>(一)局部指令(写在配置对象的directives中)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">    指令名(如focus):&#123;</span><br><span class="line">	//钩子函数,钩子函数参数</span><br><span class="line">	el：指令所绑定的元素，可以用来直接操作 DOM 。</span><br><span class="line">	binding：一个对象，包含绑定元素的一些信息</span><br><span class="line">	//绑定事件触发</span><br><span class="line">	bind(el,binding)&#123;&#125;,</span><br><span class="line">	//节点插入的时候触发</span><br><span class="line">	inserted(el,binding)&#123;&#125;,</span><br><span class="line">	//组件内相关更新</span><br><span class="line">	update(el,binding)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="二-全局指令"><a href="#二-全局指令" class="headerlink" title="(二)全局指令"></a>(二)全局指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使 v-focus 在所有组件中都可用</span><br><span class="line">Vue.directive(&#x27;focus&#x27;,配置对象)</span><br></pre></td></tr></table></figure>

<h4 id="16-vue-router-是什么-怎么使用？"><a href="#16-vue-router-是什么-怎么使用？" class="headerlink" title="16.vue-router 是什么?怎么使用？"></a>16.vue-router 是什么?怎么使用？</h4><p>vue-router是一个插件库,用来实现SPA(单页web应用)</p>
<h5 id="一-使用"><a href="#一-使用" class="headerlink" title="(一)使用"></a>(一)使用</h5><p>1.下载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-router@3//vue2用3，vue3用4</span><br></pre></td></tr></table></figure>

<p>2.在src&#x2F;router&#x2F;index.js中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import VueRouter from &quot;vue-router&quot;;</span><br><span class="line">import About from &quot;../pages/About.vue&quot;</span><br><span class="line"></span><br><span class="line">export default new VueRouter(&#123;</span><br><span class="line">    routes: [&#123;</span><br><span class="line">        path:&quot;/about&quot;,</span><br><span class="line">        //路由懒加载component:()=&gt;import(&quot;../pages/About.vue&quot;),</span><br><span class="line">        component:About</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>3.在main.js中引入并应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import VueRouter from &quot;vue-router&quot;</span><br><span class="line">import router from &quot;./router&quot;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    router:router,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="17-vue的双向数据绑定原理是什么"><a href="#17-vue的双向数据绑定原理是什么" class="headerlink" title="17.vue的双向数据绑定原理是什么?"></a>17.vue的双向数据绑定原理是什么?</h4><p>vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过<strong>Object.defineProperty()<strong>来劫持各个属性的setter，getter，在</strong>数据变动时</strong>发布消息给订阅者，触发相应的监听回调来渲染视图。</p>
<h5 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h5><p>1.需要observer(观察者)的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter<br>这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p>
<p>2.compile(模板解析器)解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>
<p>3.Watcher(订阅者)是Observer和Compile之间通信的桥梁，主要做的事情是:<br>(1)在自身实例化时往属性订阅器(dep)里面添加自己<br>(2)自身必须有一个update()方法<br>(3)待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p>
<p>4.MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>
<h5 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure>

<p>obj：必需。目标对象</p>
<p>prop：必需。需定义或修改的属性的名字</p>
<p>descriptor：必需。目标属性所拥有的特性,是一个对象,包括:</p>
<p><strong>value</strong>,属性值</p>
<p><strong>writable</strong><br>属性的值是否可以被重写。设置为true可以被重写；设置为false，不能被重写。默认为false。</p>
<p><strong>enumerable</strong><br>此属性是否可以被枚举（使用for…in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。</p>
<p><strong>configurable</strong><br>是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//当有人读取obj的属性值时,getter函数被触发,返回值为obj的值</span><br><span class="line">get()&#123;return x&#125;</span><br><span class="line">//当有人修改obj的值时,setter函数被触发,且会收到修改的值</span><br><span class="line">set(value)&#123;x=value&#125;</span><br></pre></td></tr></table></figure>



<h4 id="18-v-show-和v-if指令的共同点和不同点"><a href="#18-v-show-和v-if指令的共同点和不同点" class="headerlink" title="18.v-show 和v-if指令的共同点和不同点?"></a>18.v-show 和v-if指令的共同点和不同点?</h4><h5 id="1-共同点-1"><a href="#1-共同点-1" class="headerlink" title="1.共同点"></a>1.共同点</h5><p>用来控制DOM元素的显示或隐藏</p>
<h5 id="2-区别-1"><a href="#2-区别-1" class="headerlink" title="2.区别"></a>2.区别</h5><p>v-show指令：通过控制css中的display设置为none，控制隐藏或显示；元素始终被渲染到HTML，它只是简单的伪元素设置css的style属性，当不满足条件的元素被设置style&#x3D;“display：none”的样，是通过修改元素的的CSS属性(display)来决定实现显示还是隐藏。</p>
<p>v-if指令：v-if是动态的向DOM树内添加或删除DOM元素；满足条件是会渲染到html中，不满足条件时是不会渲染到html中的，是通过操纵dom元素来进行切换显示。</p>
<h5 id="3-应用场景："><a href="#3-应用场景：" class="headerlink" title="3.应用场景："></a>3.应用场景：</h5><ul>
<li>如果要频繁切换某节点，使⽤v-show(切换开销⽐较⼩，初始开销较⼤)；</li>
<li>如果不需要频繁切换某节点使⽤v-if（初始渲染开销较⼩，切换开销⽐较⼤）。</li>
</ul>
<h4 id="19-vue-的父组件和子组件生命周期钩子执行顺序"><a href="#19-vue-的父组件和子组件生命周期钩子执行顺序" class="headerlink" title="19.vue 的父组件和子组件生命周期钩子执行顺序"></a>19.vue 的父组件和子组件生命周期钩子执行顺序</h4><p>分三部分来看：</p>
<p>加载渲染过程</p>
<p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
<p>子组件更新过程</p>
<p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
<p>销毁过程</p>
<p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
<h4 id="20-组件中的data为什么是函数"><a href="#20-组件中的data为什么是函数" class="headerlink" title="20.组件中的data为什么是函数?"></a>20.组件中的data为什么是函数?</h4><p>在我们定义好一个组件的时候，<code>vue</code>最终都会通过<code>Vue.extend()</code>构成组件实例.</p>
<p>当我们组件的date单纯的写成对象形式，这些实例用的是同一个构造函数，由于JavaScript的特性所导致，所有的组件实例共用了一个data，就会造成一个变了全都会变的结果.</p>
<p>而采用函数返回一个全新<code>data</code>形式,initData<code>时会将其作为工厂函数都会返回全新</code>data对象使每个实例对象的数据不会受到其他实例对象数据的污染</p>
<h4 id="21-vue-组件通信的方式有哪些"><a href="#21-vue-组件通信的方式有哪些" class="headerlink" title="21.vue 组件通信的方式有哪些?"></a>21.vue 组件通信的方式有哪些?</h4><h5 id="一-props"><a href="#一-props" class="headerlink" title="(一)props"></a>(一)props</h5><h6 id="适用范围-父传子"><a href="#适用范围-父传子" class="headerlink" title="适用范围:父传子"></a>适用范围:父传子</h6><h6 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h6><p>在父组件中:(发送方)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Children name=&quot;jack&quot; age=18 /&gt;  </span><br></pre></td></tr></table></figure>

<p>在子组件中:(接收方)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//单纯接收</span><br><span class="line">props:[&quot;name&quot;,&quot;age&quot;]</span><br><span class="line">//限制类型</span><br><span class="line">props:&#123;name:string,age:Number&#125;</span><br><span class="line">//限制类型,必要性,默认值</span><br><span class="line">props:&#123;</span><br><span class="line">	name:&#123;type:string,required:true,dafault:&quot;老王&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h6><p>props传来的数据不能更改,若要更改用变量接收后,更改变量</p>
<h5 id="二-自定义事件"><a href="#二-自定义事件" class="headerlink" title="(二)自定义事件"></a>(二)自定义事件</h5><h6 id="适用范围-子传父"><a href="#适用范围-子传父" class="headerlink" title="适用范围:子传父"></a>适用范围:子传父</h6><h6 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法:"></a>使用方法:</h6><p>在子组件中(发送方)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//触发事件</span><br><span class="line">this.$emit(&quot;add&quot;,this.name)</span><br><span class="line">//解绑事件,this.$off()解绑所有</span><br><span class="line">this.$off(&quot;add&quot;)</span><br></pre></td></tr></table></figure>

<p>在父组件中(接收方)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Children @add=&quot;cartAdd($event)&quot; /&gt;  </span><br><span class="line">//接收,函数</span><br><span class="line">cartAdd(event,name)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三-全局事件总线"><a href="#三-全局事件总线" class="headerlink" title="(三)全局事件总线"></a>(三)全局事件总线</h5><h6 id="适用范围-万能"><a href="#适用范围-万能" class="headerlink" title="适用范围:万能"></a>适用范围:万能</h6><h6 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法:"></a>使用方法:</h6><p>在main.js的vue配置项中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate()&#123;</span><br><span class="line">        Vue.prototype.$bus=this</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>发送方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$bus.$emit(&quot;li&quot;,this.name)</span><br></pre></td></tr></table></figure>

<p>接收方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//接收,函数</span><br><span class="line">this.$bus.$on(&quot;li&quot;,this.fun(或者箭头函数))</span><br><span class="line">//解绑</span><br><span class="line">this.$bus.$off(&quot;li&quot;)</span><br></pre></td></tr></table></figure>

<h5 id="四-消息订阅与发布"><a href="#四-消息订阅与发布" class="headerlink" title="(四)消息订阅与发布"></a>(四)消息订阅与发布</h5><h6 id="适用范围-万能-1"><a href="#适用范围-万能-1" class="headerlink" title="适用范围:万能"></a>适用范围:万能</h6><h6 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h6><p>下载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i pubsub-Js</span><br></pre></td></tr></table></figure>

<p>发送方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line"></span><br><span class="line">pubsub.publish(&#x27;li&#x27;,this.name)</span><br></pre></td></tr></table></figure>

<p>接收方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">//接收,函数的第一个参数为li,第二个才是传参</span><br><span class="line">this.pubId = pubsub.subscribe(&#x27;li&#x27;,this.fun(或者箭头函数))</span><br><span class="line">//解绑</span><br><span class="line">pubsub.unsubscribe(this.pubId)</span><br></pre></td></tr></table></figure>

<h5 id="五-Vuex"><a href="#五-Vuex" class="headerlink" title="(五)Vuex"></a>(五)Vuex</h5><h6 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围:"></a>适用范围:</h6><p>适用于任意组件间通信,在多个组件需要共享数据时使用</p>
<h6 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法:"></a>使用方法:</h6><p>下载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vuex</span><br></pre></td></tr></table></figure>

<p>在src&#x2F;store&#x2F;index.js中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//该文件用于创建Vuex中最为核心的store</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">//引入Vuex</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">//应用Vuex插件</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">//准备actions——用于响应组件中的动作</span><br><span class="line">const actions = &#123;</span><br><span class="line">    add(context,value)&#123;</span><br><span class="line">    	context.commit(&quot;ADD&quot;,value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//准备mutations——用于操作数据（state）</span><br><span class="line">const mutations = &#123;</span><br><span class="line">	ADD(state,value)&#123;</span><br><span class="line">		state.x=value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//准备state——用于存储数据</span><br><span class="line">const state = &#123;x:0,&#125;</span><br><span class="line">//准备getters——用于将state中的数据进行加工</span><br><span class="line">const getters = &#123;</span><br><span class="line">	X(state)&#123;return state.x*10&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建并暴露store</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state,</span><br><span class="line">	getter,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在main.js中引入store</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//引入store</span><br><span class="line">import store from &#x27;./store&#x27;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">	store,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在组件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//提交</span><br><span class="line">this.$store.dispatch(&quot;add&quot;,value)</span><br><span class="line">this.$store.commit(&quot;ADD&quot;,value)</span><br><span class="line">//读取</span><br><span class="line">this.$store.state.x</span><br><span class="line">this.$store.getter.X</span><br></pre></td></tr></table></figure>

<p>利用vuex自带的方法更加便利的提取与读取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mapState,mapGetters,mapMutations,mapActions&#125; from &#x27;vuex&#x27;</span><br><span class="line">computed:&#123;</span><br><span class="line">			//借助mapState生成计算属性，从state中读取数据。（数组写法）</span><br><span class="line">			...mapState([&quot;x&quot;]),</span><br><span class="line">			//借助mapGetters生成计算属性，从getters中读取数据。（数组写法）</span><br><span class="line">			...mapGetters([&quot;X&quot;])</span><br><span class="line">		&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">			//借助mapMutations生成对应的方法，方法中会调用commit去联系mutations(对象写法)</span><br><span class="line">			...mapMutations(&#123;increment:&#x27;JIA&#x27;&#125;),</span><br><span class="line">			//借助mapActions生成对应的方法，方法中会调用dispatch去联系actions(对象写法)</span><br><span class="line">			...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;&#125;)</span><br><span class="line">		&#125;,</span><br></pre></td></tr></table></figure>

<p>vuex模块化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//在模块中</span><br><span class="line">	const actions = &#123;&#125;</span><br><span class="line">	const mutations = &#123;&#125;</span><br><span class="line">	const state = &#123;&#125;</span><br><span class="line">	const getters = &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	//创建并暴露store</span><br><span class="line">	export default &#123;</span><br><span class="line">		namespaled:true,</span><br><span class="line">		actions,</span><br><span class="line">		mutations,</span><br><span class="line">		state,</span><br><span class="line">		getter,</span><br><span class="line">	&#125;</span><br><span class="line">//在store/index.js中</span><br><span class="line">	import xxx from &quot;xxx.js&quot;</span><br><span class="line">	vuex.store(&#123;</span><br><span class="line">		modules:&#123;</span><br><span class="line">			xxx,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">//在组件中</span><br><span class="line">	this.$store.dispatch(&quot;xxx/add&quot;,value)</span><br><span class="line">	this.$store.commit(&quot;xxx/ADD&quot;,value)</span><br><span class="line">	...mapstate(&#123;</span><br><span class="line">		x:state=&gt;state.xxx.x</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="22-vue-常用指令有哪些"><a href="#22-vue-常用指令有哪些" class="headerlink" title="22.vue 常用指令有哪些?"></a>22.vue 常用指令有哪些?</h4><p>v-bind指令、v-model指令,v-on指令,v-show指令、v-if指令、v-else指令、v-else-if指令、v-for指令、v-html指令、v-text指令、v-once指令、v-cloak指令、v-pre</p>
<h4 id="23-watch、-computed、-filters-的比较"><a href="#23-watch、-computed、-filters-的比较" class="headerlink" title="23.watch、 computed、 filters 的比较"></a>23.watch、 computed、 filters 的比较</h4><p>watch:监控已有属性，一旦属性发生了改变就去自动调用对应的方法</p>
<p>computed:监控已有的属性,一旦属性的依赖发生了改变，就去自动调用对应的方法</p>
<p>filter:js中为我们提供的一个方法，用来帮助我们对数据进行筛选</p>
<p>watch与computed的区别:<br>1.watch监控现有的属性,computed通过现有的属性计算出一个新的属性</p>
<p>2.watch不会缓存数据，每次打开页面都会重新加载一次，而computed如果之前进行过计算他会将计算的结果缓存，如果再次请求会从缓存中得到数据（所以computed的性能比watch更好一些）</p>
<p>filter 与 computed 的区别</p>
<ol>
<li>触发时机不同<br>computed 属性背后的处理逻辑比较复杂，依赖 Vue 的数据更新通知机制，在属性所依赖的其他数据项发生变化时才会重新触发计算。优点是计算频率相对较低；缺点是依赖于组件，难以抽取成独立逻辑，也就是复用性低。</li>
</ol>
<p>  filter 则显的简单很多，只在显式调用时触发，一般应用在模板渲染上。优点是容易在组件外抽象；缺点是每次模板渲染时都需要重新执行计算。可以通过示例 感受调用时机的区别：</p>
<h4 id="24-vue生命周期理解"><a href="#24-vue生命周期理解" class="headerlink" title="24.vue生命周期理解?"></a>24.vue生命周期理解?</h4><p>又名生命周期回调函数,生命周期钩子.是vue在关键时刻帮我们调用的一些特殊名称的函数</p>
<h5 id="生命周期有哪些"><a href="#生命周期有哪些" class="headerlink" title="生命周期有哪些"></a>生命周期有哪些</h5><table>
<thead>
<tr>
<th align="left">生命周期</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">beforeCreate</td>
<td align="left">组件实例被创建之初</td>
</tr>
<tr>
<td align="left">created</td>
<td align="left">组件实例已经完全创建</td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td align="left">组件挂载之前</td>
</tr>
<tr>
<td align="left">mounted</td>
<td align="left">组件挂载到实例上去之后</td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td align="left">组件数据发生变化，更新之前</td>
</tr>
<tr>
<td align="left">updated</td>
<td align="left">组件数据更新之后</td>
</tr>
<tr>
<td align="left">beforeDestroy</td>
<td align="left">组件实例销毁之前</td>
</tr>
<tr>
<td align="left">destroyed</td>
<td align="left">组件实例销毁之后</td>
</tr>
<tr>
<td align="left">activated</td>
<td align="left">keep-alive 缓存的组件激活时</td>
</tr>
<tr>
<td align="left">deactivated</td>
<td align="left">keep-alive 缓存的组件停用时调用</td>
</tr>
<tr>
<td align="left">errorCaptured</td>
<td align="left">捕获一个来自子孙组件的错误时被调用</td>
</tr>
</tbody></table>
<h5 id="使用场景分析"><a href="#使用场景分析" class="headerlink" title="使用场景分析"></a><strong>使用场景分析</strong></h5><table>
<thead>
<tr>
<th align="left">生命周期</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">beforeCreate</td>
<td align="left">执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td>
</tr>
<tr>
<td align="left">created</td>
<td align="left">组件初始化完毕，各种数据可以使用，常用于异步数据获取</td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td align="left">未执行渲染、更新，dom未创建</td>
</tr>
<tr>
<td align="left">mounted</td>
<td align="left">初始化结束，dom已创建，可用于获取访问数据和dom元素</td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td align="left">更新前，可用于获取更新前各种状态</td>
</tr>
<tr>
<td align="left">updated</td>
<td align="left">更新后，所有状态已是最新</td>
</tr>
<tr>
<td align="left">beforeDestroy</td>
<td align="left">销毁前，可用于一些定时器或订阅的取消</td>
</tr>
<tr>
<td align="left">destroyed</td>
<td align="left">组件已销毁，作用同上</td>
</tr>
</tbody></table>
<h5 id="数据请求在created和mouted的区别"><a href="#数据请求在created和mouted的区别" class="headerlink" title="数据请求在created和mouted的区别"></a>数据请求在created和mouted的区别</h5><p>放在<code>mounted</code>中的请求有可能导致页面闪动（因为此时页面<code>dom</code>结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在<code>created</code>生命周期当中。</p>
<h4 id="25-为什么避免v-if和v-for用在一起"><a href="#25-为什么避免v-if和v-for用在一起" class="headerlink" title="25.为什么避免v-if和v-for用在一起?"></a>25.为什么避免v-if和v-for用在一起?</h4><p>原因：<br>        因为v-for的优先级比v-if 的优先级高，所以每次渲染时都会先循环再进行条件判断，而又因为v-if 会根据渲染条件为true 或false来决定渲染与否的，所以如果将v-if 和v-for用在一起会特别消耗性能</p>
<p>解决方案：<br>       将v-if 放在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for 循环</p>
<h3 id="五-webpack"><a href="#五-webpack" class="headerlink" title="五.webpack"></a>五.webpack</h3><h4 id="1-在使用webpack时-你都做些什么"><a href="#1-在使用webpack时-你都做些什么" class="headerlink" title="1.在使用webpack时,你都做些什么?"></a>1.在使用webpack时,你都做些什么?</h4><p>webpack是一个前端的模块化打包(构建)的工具</p>
<p>1.语法转换</p>
<p>​    ES6—&gt;ES5   供浏览器的解析**(babel**)</p>
<p>​    less&#x2F;sass—-&gt;css   供浏览器的解析</p>
<p>​    TS——&gt; ES5  供浏览器的解析</p>
<p>2.文件压缩和合并</p>
<p>  js &#x2F; html &#x2F;css 文件压缩，删除所有的注释和空格，变量名简写</p>
<p>  js &#x2F; css 文件合并 ，将多个js文件或则css文件合并成一个js文件或则css文件</p>
<p>3.检测代码格式**(eslint)**,</p>
<p>4.提高代码运行性能(<strong>code split</strong>),分割文件,按需加载</p>
<p>5.<strong>模块整合能力</strong>，提高性能，可维护性，解决浏览器频繁请求文件的问题</p>
<h4 id="2-wepack-中loader和plugin的区别"><a href="#2-wepack-中loader和plugin的区别" class="headerlink" title="2.wepack 中loader和plugin的区别?"></a>2.wepack 中loader和plugin的区别?</h4><p>loader即为文件加载器，操作的是文件，将文件A通过loader转换成文件B，是一个单纯的文件转化过程。</p>
<p>plugin即为插件，是一个扩展器，丰富webpack本身，增强功能 ，针对的是在loader结束之后，webpack打包的整个过程，他并不直接操作文件，而是基于事件机制工作，监听webpack打包过程中的某些节点，执行广泛的任务。</p>
<h4 id="3-说说webpack打包的流程"><a href="#3-说说webpack打包的流程" class="headerlink" title="3.说说webpack打包的流程"></a>3.说说webpack打包的流程</h4><ul>
<li>初始化流程：从配置文件和 <code>Shell</code> 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li>
<li>编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li>
<li>输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统</li>
</ul>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>License</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>READ NEXT</span></section><section class="body fs14"><a id="next" href="/2022/08/23/HTML%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">HTML个人总结<span class="note">Older</span></a><div class="line"></div><a id="prev" href="/2022/08/30/%E5%89%8D%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">前台项目总结<span class="note">Newer</span></a></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</p>
<p>This site was deployed by <a href="http://example.com/">@李阳滨</a> using <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0" title="v1.8.0">Stellar</a>.</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0';
  stellar.config = {
    date_suffix: {
      just: 'Just',
      min: 'minutes ago',
      hour: 'hours ago',
      day: 'days ago',
      month: 'months ago',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://fastly.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://fastly.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://fastly.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
