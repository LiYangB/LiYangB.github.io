<!DOCTYPE html>
<html lang='en'>

<head>
  <meta name="generator" content="Hexo 6.2.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://fastly.jsdelivr.net'>
  <link rel="preconnect" href="https://fastly.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>前端面试题 - 个人博客</title>

  
    <meta name="description" content="文件描述:本文件包括了常见的HTML,CSS,JS,Vue,浏览器与http&#x2F;https,webpack面试题,仅供参考. 一.HTML&#x2F;HTML51.form中input可以设置为readonly与disabled,请问两者有什么区别?1)共同点:  Readonly和Disabled它们都能够做到使用户不能够更改表单域中的内容。 2)区别:   Readonly只针对inp">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题">
<meta property="og:url" content="http://example.com/2022/08/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="文件描述:本文件包括了常见的HTML,CSS,JS,Vue,浏览器与http&#x2F;https,webpack面试题,仅供参考. 一.HTML&#x2F;HTML51.form中input可以设置为readonly与disabled,请问两者有什么区别?1)共同点:  Readonly和Disabled它们都能够做到使用户不能够更改表单域中的内容。 2)区别:   Readonly只针对inp">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-08-23T12:26:09.000Z">
<meta property="article:modified_time" content="2022-09-20T05:23:17.556Z">
<meta property="article:author" content="李阳滨">
<meta property="article:tag" content="常见面试题">
<meta name="twitter:card" content="summary">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="title" href="/"><div class="main">个人博客</div></a></div>
<nav class="menu dis-select"></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">TOC</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0"><span class="toc-text">文件描述:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-HTML-x2F-HTML5"><span class="toc-text">一.HTML&#x2F;HTML5</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-form%E4%B8%ADinput%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E4%B8%BAreadonly%E4%B8%8Edisabled-%E8%AF%B7%E9%97%AE%E4%B8%A4%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">1.form中input可以设置为readonly与disabled,请问两者有什么区别?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-text">1)共同点:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8C%BA%E5%88%AB"><span class="toc-text">2)区别:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFDOCTYPE%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8"><span class="toc-text">2.什么是DOCTYPE及其作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0-%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-text">3.常见的行内元素与块级元素,以及它们的区别与转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0"><span class="toc-text">1)行内元素:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0"><span class="toc-text">2)块级元素:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">3)块级元素和内联元素的区别：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-text">4)块级元素和内联元素之间的转换：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-HTML5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">4.HTML5有哪些新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3HTML5%E7%BB%93%E6%9E%84%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-text">5.如何理解HTML5结构的语义化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE-%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">6.为什么要使用语义化标签(语义化的优点)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-src%E4%B8%8Ehref%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7.src与href的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-img-%E7%9A%84alt%E4%B8%8Etitle-%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C"><span class="toc-text">8.img 的alt与title 有何异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84%E5%9B%BE%E7%89%87-%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99-%EF%BC%8C%E5%8A%A0%E8%BD%BD%E5%BE%88%E6%85%A2%EF%BC%8C%E4%BD%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%BC%98%E5%8C%96%E8%BF%99%E4%BA%9B%E5%9B%BE%E7%89%87%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%8C%E7%BB%99%E7%94%A8%E6%88%B7%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BD%93%E9%AA%8C"><span class="toc-text">9.一个页面上有大量的图片(大型电商网站)，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E8%B0%88%E8%B0%88%E4%BB%A5%E5%89%8D%E7%AB%AF%E8%A7%92%E5%BA%A6%E5%87%BA%E5%8F%91%E5%81%9A%E5%A5%BDSEO%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E4%BB%80%E4%B9%88"><span class="toc-text">10.谈谈以前端角度出发做好SEO需要考虑什么</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%B4%E6%8A%A4%E7%BD%91%E7%AB%99%EF%BC%8C%E6%8F%90%E9%AB%98%E5%86%85%E5%AE%B9%E8%B4%A8%E9%87%8F%EF%BC%8C%E4%BF%9D%E6%8C%81%E6%9B%B4%E6%96%B0"><span class="toc-text">1.维护网站，提高内容质量，保持更新</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BD%91%E7%AB%99%E7%BB%93%E6%9E%84%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%9A%E5%B0%BD%E9%87%8F%E7%AE%80%E5%8D%95%E3%80%81%E5%BC%80%E9%97%A8%E8%A7%81%E5%B1%B1%EF%BC%8C%E6%8F%90%E5%80%A1%E6%89%81%E5%B9%B3%E5%8C%96%E7%BB%93%E6%9E%84%E3%80%82"><span class="toc-text">2.网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8E%A7%E5%88%B6%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">3.控制页面的大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%80%82%E9%87%8F%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8D%E5%92%8C%E7%BD%91%E9%A1%B5%E6%8F%8F%E8%BF%B0"><span class="toc-text">4.适量的关键词和网页描述</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">11.渐进增强和优雅降级之间的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-websocket-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E4%B8%8Ecookie"><span class="toc-text">12.websocket 本地存储与cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4iframe%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-text">13.请你说说iframe有哪些优点和缺点?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-CSS-x2F-CSS3"><span class="toc-text">二.CSS&#x2F;CSS3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-css%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E9%80%89%E6%8B%A9%E5%99%A8-%E5%AE%83%E4%BB%AC%E7%9A%84%E6%9D%83%E9%87%8D%E6%98%AF%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E7%9A%84"><span class="toc-text">1.css有哪些基本选择器?它们的权重是如何表示的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D-%E8%A7%A3%E5%86%B3%E9%AB%98%E5%BA%A6%E5%9D%8D%E5%A1%8C-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">2. 清除浮动带来的影响(解决高度坍塌)有几种方式?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%BA%E7%88%B6%E5%85%83%E7%B4%A0%E5%BC%80%E5%90%AFBFC-%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">1.为父元素开启BFC(块级格式化上下文)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AEclear"><span class="toc-text">2.设置clear</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%80%AA%E5%BC%82%E7%9B%92%E6%A8%A1%E5%9E%8Bbox-sizing-%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9B%92%E5%B8%83%E5%B1%80"><span class="toc-text">3.怪异盒模型box-sizing?弹性盒模型盒布局?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%AA%E5%BC%82%E7%9B%92%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-text">怪异盒模型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%EF%BC%9A%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88%E3%80%82"><span class="toc-text">弹性盒子：布局方案。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-transition-transform-%E5%92%8Canimation%E5%8C%BA%E5%88%AB"><span class="toc-text">4.transition,transform 和animation区别?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-transform-%E5%8F%98%E5%BD%A2"><span class="toc-text">1. transform(变形)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-transition-%E8%BF%87%E6%B8%A1"><span class="toc-text">2. transition(过渡)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-animation-%E5%8A%A8%E7%94%BB"><span class="toc-text">3. animation(动画)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-text">4.总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-css%E5%AE%9E%E7%8E%B0%E5%AD%90%E5%85%83%E7%B4%A0%E5%9C%A8%E7%88%B6%E5%85%83%E7%B4%A0%E4%B8%AD%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">5.css实现子元素在父元素中水平垂直居中的几种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-margin-auto"><span class="toc-text">方法1：使用绝对定位 + margin: auto</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-transform"><span class="toc-text">方法2：使用绝对定位 + transform</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E7%88%B6%E5%85%83%E7%B4%A0%E4%BD%BF%E7%94%A8flex%E5%B8%83%E5%B1%80%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC%E4%B8%BAcenter"><span class="toc-text">方法3：父元素使用flex布局，并设置相关的属性值为center</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%954%EF%BC%9A%E4%BD%BF%E7%94%A8table-cell%E5%AE%9E%E7%8E%B0"><span class="toc-text">方法4：使用table-cell实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A6%82%E6%9E%9C%E5%AF%B9-css%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-text">6.如果对 css进行优化，如何处理?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%86%85%E8%81%94%E9%A6%96%E5%B1%8F%E5%85%B3%E9%94%AECSS%EF%BC%88Critical-CSS%EF%BC%89"><span class="toc-text">1. 内联首屏关键CSS（Critical CSS）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDCSS"><span class="toc-text">2. 异步加载CSS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9"><span class="toc-text">3. 文件压缩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%8E%BB%E9%99%A4%E6%97%A0%E7%94%A8CSS"><span class="toc-text">4. 去除无用CSS</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-CSS3-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">7.CSS3 有哪些新特性?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-text">一、选择器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E8%BE%B9%E6%A1%86"><span class="toc-text">二.边框</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E8%83%8C%E6%99%AF"><span class="toc-text">三.背景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B-%E6%96%87%E5%AD%97"><span class="toc-text">四.文字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94-%E9%A2%9C%E8%89%B2"><span class="toc-text">五.颜色</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AD-transition-%E8%BF%87%E6%B8%A1"><span class="toc-text">六.transition 过渡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%83-transform-%E8%BD%AC%E6%8D%A2"><span class="toc-text">七.transform 转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AB-animation-%E5%8A%A8%E7%94%BB"><span class="toc-text">八.animation 动画</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%9D-%E6%B8%90%E5%8F%98"><span class="toc-text">九.渐变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%81-%E5%B8%83%E5%B1%80"><span class="toc-text">十.布局</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%A7%A3%E9%87%8A-%E4%B8%8BCSS-Sprites-%E4%BB%A5%E5%8F%8A%E4%BD%A0%E8%A6%81%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E6%88%96%E7%BD%91%E7%AB%99%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%83%E3%80%82"><span class="toc-text">8.解释 下CSS Sprites,以及你要如何在页面或网站中使用它。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%88%86%E6%9E%90%E6%AF%94%E8%BE%83opacity-0%E3%80%81visibility-hidden%E3%80%81display-none-%E4%BC%98%E5%8A%A3%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA"><span class="toc-text">9.分析比较opacity:0、visibility:hidden、display:.none 优劣和适用场</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">一.区别：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E6%80%A7%E8%83%BD%EF%BC%9A"><span class="toc-text">二.性能：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%A1%8C%E9%99%B7-x2F-%E5%A4%96%E8%BE%B9%E8%B7%9D%E6%8A%98%E5%8F%A0"><span class="toc-text">10.外边距塌陷&#x2F;外边距折叠?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-text">原因:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3-%E4%B8%BA%E5%85%83%E7%B4%A0%E5%BC%80%E5%90%AFBFC-%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">解决:为元素开启BFC(块级格式化上下文)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E9%87%8D%E6%8E%92-%E5%9B%9E%E6%B5%81-%E5%92%8C%E9%87%8D%E7%BB%98"><span class="toc-text">11.重排(回流)和重绘?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93"><span class="toc-text">一.浏览器渲染</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E5%9B%9E%E6%B5%81"><span class="toc-text">二.回流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E9%87%8D%E7%BB%98"><span class="toc-text">三.重绘</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F"><span class="toc-text">12.常用的几种布局方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9B%BA%E5%AE%9A%E5%B8%83%E5%B1%80"><span class="toc-text">1.固定布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-text">2.流式布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80"><span class="toc-text">3.弹性布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80"><span class="toc-text">4.浮动布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%AE%9A%E4%BD%8D%E5%B8%83%E5%B1%80"><span class="toc-text">5.定位布局</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-css3-%E5%AE%9E%E7%8E%B00-5px%E7%9A%84%E7%BB%86%E7%BA%BF"><span class="toc-text">13.css3 实现0.5px的细线</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E6%B8%90%E5%8F%98%E5%AE%9E%E7%8E%B0"><span class="toc-text">一.渐变实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E4%BD%BF%E7%94%A8%E7%BC%A9%E6%94%BE"><span class="toc-text">二.使用缩放</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-%E7%94%A8%E7%BA%AFCSS%E5%88%9B%E5%BB%BA-%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">14.用纯CSS创建-一个三角形的原理是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-CSS%E6%A0%B7%E5%BC%8F%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%8D%95%E4%BD%8D"><span class="toc-text">15.CSS样式中常用单位?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-px"><span class="toc-text">一.px</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E7%99%BE%E5%88%86%E5%8F%B7"><span class="toc-text">二.百分号 %</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-em"><span class="toc-text">三.em</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B-rem"><span class="toc-text">四.rem</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94-vw%EF%BC%8Cvh%EF%BC%8Cvmin%EF%BC%8Cvmax"><span class="toc-text">五.vw，vh，vmin，vmax</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%80%E4%BB%A5%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8rem-vm%E7%BB%93%E5%90%88%E5%88%B6%E4%BD%9C%E7%A7%BB%E5%8A%A8%E7%AB%AF"><span class="toc-text">所以可以使用rem+vm结合制作移动端:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-CSS3%E7%9A%84Flexbox-%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B"><span class="toc-text">16.请解释一下 CSS3的Flexbox ( 弹性盒布局模型) ?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFflex"><span class="toc-text">1.什么是flex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%B9%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">2.容器属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7"><span class="toc-text">3.项目属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-link-%E4%B8%8E-import%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">17.link 与@import的区别.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-JS"><span class="toc-text">三.JS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">1.值传递和引用传递分别是什么，有什么区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%8E%E6%A0%B7%E6%B7%BB%E5%8A%A0%E3%80%81-%E7%A7%BB%E9%99%A4%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-text">2.怎样添加、 移除、移动、复制、创建和查找节点?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-javascript-%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.javascript 中有几种数据类型?怎么判断数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E6%80%BB%E5%85%B1%E5%85%AB%E7%A7%8D"><span class="toc-text">(一)总共八种</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E9%89%B4%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="toc-text">(二)鉴定方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-var-let-%E5%92%8Cconst%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.var,let 和const之间的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-text">(一)变量提升</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="toc-text">(二)暂时性死区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">(三)块级作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B-%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E"><span class="toc-text">(四)重复声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94-%E4%BF%AE%E6%94%B9%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">(五)修改声明的变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-JavaScript-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">5.JavaScript 数组的常用方法?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%A2%9E"><span class="toc-text">(一)增</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E5%88%A0"><span class="toc-text">(二)删</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E6%94%B9"><span class="toc-text">(三)改</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B-%E6%9F%A5"><span class="toc-text">(四)查</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94-%E6%8E%92%E5%BA%8F"><span class="toc-text">(五)排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AD-%E8%BD%AC%E6%8D%A2"><span class="toc-text">(六)转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%83-%E9%81%8D%E5%8E%86"><span class="toc-text">(七)遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-ES6-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">6.ES6 的新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81let%E5%92%8Cconst"><span class="toc-text">1、let和const</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81symbol"><span class="toc-text">2、symbol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">3、模板字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E8%A7%A3%E6%9E%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">4、解构表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%AF%B9%E8%B1%A1%E6%96%B9%E9%9D%A2"><span class="toc-text">5、对象方面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%87%BD%E6%95%B0%E6%96%B9%E9%9D%A2"><span class="toc-text">6、函数方面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81class%EF%BC%88%E7%B1%BB%EF%BC%89"><span class="toc-text">7、class（类）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81promise"><span class="toc-text">8、promise</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">9、模块化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%99%AE%E9%80%9A-%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7.普通 函数和箭头函数的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E8%AF%AD%E6%B3%95%E6%9B%B4%E5%8A%A0%E7%AE%80%E6%B4%81%E3%80%81%E6%B8%85%E6%99%B0"><span class="toc-text">(一)语法更加简洁、清晰</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89-prototype-%E5%8E%9F%E5%9E%8B-%EF%BC%8C%E6%89%80%E4%BB%A5%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%AC%E8%BA%AB%E6%B2%A1%E6%9C%89this"><span class="toc-text">(二)箭头函数没有 prototype (原型)，所以箭头函数本身没有this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8D%E4%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84this"><span class="toc-text">(三)箭头函数不会创建自己的this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B-call-apply-bind-%E6%97%A0%E6%B3%95%E6%94%B9%E5%8F%98%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-text">(四)call | apply | bind 无法改变箭头函数中this的指向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8"><span class="toc-text">(五)箭头函数不能作为构造函数使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%AF%B4%E4%B8%80%E4%B8%8BPromise"><span class="toc-text">8.说一下Promise?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9A%E4%B9%89"><span class="toc-text">(一)定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E4%BD%BF%E7%94%A8"><span class="toc-text">(二)使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-API"><span class="toc-text">(三)API</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-Async-x2F-await-%E5%AF%B9%E6%AF%94promise%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">9.Async&#x2F;await 对比promise的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-JS%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%EF%BC%8C%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">10.JS中的堆和栈，栈和队列有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AE%83"><span class="toc-text">11.什么是闭包，如何使用它，为什么要使用它?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9A%E4%B9%89-1"><span class="toc-text">(一)定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6"><span class="toc-text">(二)产生条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E4%BD%9C%E7%94%A8"><span class="toc-text">(三)作用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%B0%E5%BA%95%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">12.new 操作符到底到了什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E6%94%B9%E5%8F%98this%E7%9A%84%E6%8C%87%E5%90%91%E4%B8%ADbind%E3%80%81call%E3%80%81-apply-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">13.改变this的指向中bind、call、 apply 的区别.</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-this%E6%8C%87%E5%90%91"><span class="toc-text">(一)this指向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-text">(二)三者区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-javascript-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86"><span class="toc-text">14 .javascript 对象的深度克隆?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">15.如何实现浏览器内多个标签页之间的通信?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8localStorage"><span class="toc-text">第一种——调用localStorage</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8cookie-setInterval"><span class="toc-text">第二种——调用cookie+setInterval()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">16.哪些操作会造成内存泄漏?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">(一)内存溢出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">(二)内存泄露</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E8%B0%88%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">17.谈谈垃圾回收机制方式及内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%E6%98%AF"><span class="toc-text">基本思路是:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%E4%B8%BA"><span class="toc-text">垃圾回收策略为:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">内存管理:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">18. 谈谈你对this对象的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-JS-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB-%E4%BC%AA-%E6%95%B0%E7%BB%84-%E5%A6%82%E4%BD%95%E5%B0%86%E7%B1%BB-%E4%BC%AA-%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="toc-text">19.JS 中什么是类(伪)数组?如何将类(伪)数组转化为数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9A%E4%B9%89-2"><span class="toc-text">(一)定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E8%BD%AC%E6%8D%A2"><span class="toc-text">(二)转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-text">20.什么是事件代理(事件委托) ?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9A%E4%B9%89-3"><span class="toc-text">(一)定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E5%88%86%E6%88%90%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-text">(二)事件传播分成三个阶段：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">(三)事件委托的优点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%88%B6-%E6%98%BE%E5%BC%8F-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">21.什么是强制(显式)类型转换?什么是隐式类型转换?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E8%B0%88%E4%B8%80%E8%B0%88JS%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%82"><span class="toc-text">22.谈一谈JS作用域链。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">(一)作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">(二)作用域链</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3JS%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">23.如何理解JS原型链?</span></a></li></ol></li></ol></div></div></div>


</div>


    </aside>
    <div class='l_main'>
      

      

<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a><span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a></div><div id="post-meta">Posted on&nbsp;<time datetime="2022-08-23T12:26:09.000Z">2022-08-23</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>前端面试题</span></h1>
<h3 id="文件描述"><a href="#文件描述" class="headerlink" title="文件描述:"></a>文件描述:</h3><p>本文件包括了常见的HTML,CSS,JS,Vue,浏览器与http&#x2F;https,webpack面试题,仅供参考.</p>
<h3 id="一-HTML-x2F-HTML5"><a href="#一-HTML-x2F-HTML5" class="headerlink" title="一.HTML&#x2F;HTML5"></a>一.HTML&#x2F;HTML5</h3><h4 id="1-form中input可以设置为readonly与disabled-请问两者有什么区别"><a href="#1-form中input可以设置为readonly与disabled-请问两者有什么区别" class="headerlink" title="1.form中input可以设置为readonly与disabled,请问两者有什么区别?"></a>1.form中input可以设置为readonly与disabled,请问两者有什么区别?</h4><h5 id="1-共同点"><a href="#1-共同点" class="headerlink" title="1)共同点:"></a>1)共同点:</h5><p>  Readonly和Disabled它们都能够做到使用户不能够更改表单域中的内容。</p>
<h5 id="2-区别"><a href="#2-区别" class="headerlink" title="2)区别:"></a>2)区别:</h5><p>   Readonly只针对input(text &#x2F; password)和textarea有效，而disabled对于所有的表单元素都有效，但是表单元素在使用了disabled后，当我们将表单以POST或GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去（ readonly接受值更改可以回传，disable接受改但不回传数据）。</p>
<h4 id="2-什么是DOCTYPE及其作用"><a href="#2-什么是DOCTYPE及其作用" class="headerlink" title="2.什么是DOCTYPE及其作用"></a>2.什么是DOCTYPE及其作用</h4><p>DOCTYPE是document type的简写，它是一种标记语言的文档类型声明，即告诉浏览器当前 HTML 是用什么版本编写的。</p>
<h4 id="3-常见的行内元素与块级元素-以及它们的区别与转换"><a href="#3-常见的行内元素与块级元素-以及它们的区别与转换" class="headerlink" title="3.常见的行内元素与块级元素,以及它们的区别与转换"></a>3.常见的行内元素与块级元素,以及它们的区别与转换</h4><h5 id="1-行内元素"><a href="#1-行内元素" class="headerlink" title="1)行内元素:"></a>1)行内元素:</h5><p>a - 锚点<br>select - 项目选择<br>span - 常用内联容器，定义文本内区块<br>strong - 粗体强调<br>img - 图片<br>input - 输入框<br>label - 表格标签<br>textarea - 多行文本输入框<br>br - 换行</p>
<h5 id="2-块级元素"><a href="#2-块级元素" class="headerlink" title="2)块级元素:"></a>2)块级元素:</h5><p>div<br>ul ,li 非排序列表<br>form - 交互表单<br>table - 表格<br>h1 -h6 标题<br>hr - 水平分隔线<br>p - 段落<br>dl -dt-dd - 定义列表<br>address - 地址<br>blockquote - 块引用<br>fieldset - form控制组</p>
<h5 id="3-块级元素和内联元素的区别："><a href="#3-块级元素和内联元素的区别：" class="headerlink" title="3)块级元素和内联元素的区别："></a>3)块级元素和内联元素的区别：</h5><p>  (1).块级元素，宽度默认是它容器的100%,各占据一行，垂直方向排列；内联元素，都是同一行，水平方向排列；<br>  (2).块级元素，能容纳其他块元素或者内联元素；内联元素，只能容纳文本或其他内联元素；<br>  (3).块级元素中height，line-height以及margin和padding都可以控制；行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效</p>
<h5 id="4-块级元素和内联元素之间的转换："><a href="#4-块级元素和内联元素之间的转换：" class="headerlink" title="4)块级元素和内联元素之间的转换："></a>4)块级元素和内联元素之间的转换：</h5><p>(1)display<br>  块元素默认display:block;行内非替换元素(a,span)默认为display：inline;行内替换元素(input)默认为display:inline-block;<br>a.display:none;不显示该元素，也不会保留该元素原先占有的文档流位置。<br>b.display:block;转换为块级元素。<br>c.display:inline;转换为行内元素。<br>d.display:inline-block;转换为行内块级元素。<br>(2).float<br>  当把行内元素设置完float:left&#x2F;right后，该行内元素的display属性会被赋予block值，且拥有浮动特性。行内元素去除了之间的莫名空白。<br>(3).position<br>  当为行内元素进行定位时，position:absolute与position:fixed.都会使得原先的行内元素变为块级元素。</p>
<h4 id="4-HTML5有哪些新特性"><a href="#4-HTML5有哪些新特性" class="headerlink" title="4.HTML5有哪些新特性"></a>4.HTML5有哪些新特性</h4><ul>
<li>新的语义元素，比如 [header], [footer], [article], and [section]。</li>
<li>新的表单控件，比如数字、日期、时间、日历和滑块。</li>
<li>强大的图像支持（借由 [canvas] 和 [svg]）</li>
<li>强大的多媒体支持（借由 [video] 和 [audio]）</li>
<li>强大的新 API，比如:<ul>
<li>用webStorage储存机制取代 cookie。</li>
<li>HTML5 地理定位</li>
</ul>
</li>
</ul>
<h4 id="5-如何理解HTML5结构的语义化"><a href="#5-如何理解HTML5结构的语义化" class="headerlink" title="5.如何理解HTML5结构的语义化"></a>5.如何理解HTML5结构的语义化</h4><p>HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构，如 header,footer,nav，从标签上即可以直观的知道这个标签的作用，而不是滥用div.</p>
<h4 id="6-为什么要使用语义化标签-语义化的优点"><a href="#6-为什么要使用语义化标签-语义化的优点" class="headerlink" title="6.为什么要使用语义化标签(语义化的优点)"></a>6.为什么要使用语义化标签(语义化的优点)</h4><p>为了更容易让屏幕阅读器读出内容，使网页结构更清晰，更容易被搜索引擎搜入，也为了在实际开发过程中一些团队合作的方便，HTML5新推出了一系列语义化标签如[hearder]&#x2F;[footer]&#x2F;[main]等</p>
<h4 id="7-src与href的区别"><a href="#7-src与href的区别" class="headerlink" title="7.src与href的区别"></a>7.src与href的区别</h4><p><strong>href</strong>标识超文本引用，用在<strong>link</strong>和<strong>a</strong>等元素上，<strong>href</strong>是引用和页面关联，是在当前元素和引用资源之间建立联系</p>
<p><strong>src</strong>表示引用资源，表示替换当前元素，用在<strong>img</strong>，<strong>script</strong>，<strong>iframe</strong>上，src是页面内容不可缺少的一部分。</p>
<h4 id="8-img-的alt与title-有何异同"><a href="#8-img-的alt与title-有何异同" class="headerlink" title="8.img 的alt与title 有何异同"></a>8.img 的alt与title 有何异同</h4><p>alt属性和title属性相同点：<br>    它们都会出现浮层，显示自己设置的图片相关的内容。<br>alt属性和title属性不同点：<br>    alt属性:1.当图片加载不出来的时候，就会在图片未显示的地方出现一段alt设置的属性内容。这个属性的作用是为了给未加载的图片显示提示信息，即使在网络比较差的时候，用户也可以知道图片的内容，方便用户浏览网页。同时在程序员对网站维护的时候也能更快的查找到问题。2.浏览器的搜索引擎可以通过alt属性的文字描述来获取图片。<br>    title属性：title属性可以用在任何的元素上，当用户把鼠标移动到元素上时，就会显示预先设置的title的内容，起到对图片说明的作用，实质上就是对图片的解释和备注。</p>
<h4 id="9-一个页面上有大量的图片-大型电商网站-，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验"><a href="#9-一个页面上有大量的图片-大型电商网站-，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验" class="headerlink" title="9.一个页面上有大量的图片(大型电商网站)，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验"></a>9.一个页面上有大量的图片(大型电商网站)，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</h4><p>1.图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</p>
<p>2.如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</p>
<p>3.如果图片为css图片，可以使用Base64等技术。</p>
<p>4.如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</p>
<h4 id="10-谈谈以前端角度出发做好SEO需要考虑什么"><a href="#10-谈谈以前端角度出发做好SEO需要考虑什么" class="headerlink" title="10.谈谈以前端角度出发做好SEO需要考虑什么"></a>10.谈谈以前端角度出发做好SEO需要考虑什么</h4><h5 id="1-维护网站，提高内容质量，保持更新"><a href="#1-维护网站，提高内容质量，保持更新" class="headerlink" title="1.维护网站，提高内容质量，保持更新"></a>1.维护网站，提高内容质量，保持更新</h5><p>搜索引擎会考评网站的质量，保持网站的经常更新，使网站拥有大量的、有用的、可读性强的优质信息。网站的权重会相应的提升。为了保持更新频率而去抄袭并不可取。</p>
<h5 id="2-网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。"><a href="#2-网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。" class="headerlink" title="2.网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。"></a>2.网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。</h5><p>一般而言，建立的网站结构层次越少，越容易被“蜘蛛”抓取，也就容易被收录。一般中小型网站目录结构超过三级，“蜘蛛”便不愿意往下爬，并且根据相关调查：访客如果经过跳转3次还没找到需要的信息，很可能离开。因此，三层目录结构也是体验的需要。</p>
<h5 id="3-控制页面的大小"><a href="#3-控制页面的大小" class="headerlink" title="3.控制页面的大小"></a>3.控制页面的大小</h5><p>减少http请求，提高网站的加载速度。当速度很慢时，用户体验不好，留不住访客，并且一旦超时，“蜘蛛”也会离开</p>
<h5 id="4-适量的关键词和网页描述"><a href="#4-适量的关键词和网页描述" class="headerlink" title="4.适量的关键词和网页描述"></a>4.适量的关键词和网页描述</h5><p>1.title标题：只强调重点即可，尽量把重要的关键词放在前面，关键词不要重复出现，尽量做到每个页面的title标题中不要设置相同的内容。</p>
<p>2.meta keywords标签：关键词，列举出几个页面的重要关键字即可，切记过分堆砌。</p>
<p>3.meta description标签：网页描述，需要高度概括网页内容，切记不能太长，过分堆砌关键词，每个页面也要有所不同。</p>
<p>4.a标签：页内链接，要加 “title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上 el&#x3D;”nofollow” 属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。</p>
<p>5.img应使用 “alt” 属性加以说明。为图片加上alt属性,当网络速度很慢，或者图片地址失效的时候，就可以体现出alt属性的作用，他可以让用户在图片没有显示的时候知道这个图片的作用。</p>
<h4 id="11-渐进增强和优雅降级之间的区别"><a href="#11-渐进增强和优雅降级之间的区别" class="headerlink" title="11.渐进增强和优雅降级之间的区别?"></a>11.渐进增强和优雅降级之间的区别?</h4><p>渐进增强 ： 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
<p>优雅降级 ： 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<p>区别： 优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</p>
<h4 id="12-websocket-本地存储与cookie"><a href="#12-websocket-本地存储与cookie" class="headerlink" title="12.websocket 本地存储与cookie"></a>12.websocket 本地存储与cookie</h4><p>通过本地存储（Local Storage），web 应用程序能够在用户浏览器中对数据进行本地的存储。存放数据大小为一般为5MB,.只能存储字符串类型,对于复杂的对象可以使用JS提供的JSON对象的stringify和parse来处理。</p>
<p>1.localStorage 对象存储的是没有截止日期的数据。当浏览器被关闭时数据不会被删除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;lastname&quot;</span>, <span class="string">&quot;Gates&quot;</span>);</span><br><span class="line"><span class="comment">// 取回</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;result&quot;</span>).<span class="property">innerHTML</span> = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;lastname&quot;</span>);</span><br><span class="line"><span class="comment">//移除</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&quot;lastname&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>2.sessionStorage 对象等同 localStorage 对象，不同之处在于只对一个 session 存储数据。如果用户关闭具体的浏览器标签页，数据也会被删除。</p>
<p>3.cookie为HTTP请求发送Set-Cookie HTTP头作为响应的一部分。生命期为只在设置的cookie过期时间之前一直有效(一般默认是浏览器关闭失效,可以自己设置失效时间)，即使窗口或浏览器关闭。 存放数据大小为4K左右 。</p>
<h4 id="13-请你说说iframe有哪些优点和缺点"><a href="#13-请你说说iframe有哪些优点和缺点" class="headerlink" title="13.请你说说iframe有哪些优点和缺点?"></a>13.请你说说iframe有哪些优点和缺点?</h4><p><strong>优点</strong> <strong>:</strong>  </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.iframe</span>能够把嵌入的网页原样展现出来；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.模块分离，便于更改，如果有多个网页引用<span class="selector-tag">iframe</span>，只需要修改<span class="selector-tag">iframe</span>的内容，就可以实现调用的每一个页面内容的更改，方便快捷；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用<span class="selector-tag">iframe</span>来嵌套，增加代码的可重用；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由<span class="selector-tag">iframe</span>来解决；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.重载页面时不需要重载整个页面，只需要重载页面中的一个框架页；</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.方便制作导航栏。</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong> <strong>:</strong>  </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.样式和脚本需要额外链入，调用外部页面,需要额外调用css,增加页面额外的请求次数，增加服务器的http请求；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.代码复杂，在网页中使用框架结构最大的弊病是搜索引擎的“蜘蛛”程序无法解读这种页面，会影响搜索引擎优化，不利于网站排名；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.框架结构有时会让人感到迷惑，滚动条除了会挤占有限的页面空间外会使<span class="selector-tag">iframe</span>布局混乱，还会分散访问者的注意力，影响用户体验；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.链接导航疑问。运用框架结构时，必须保证正确配置所有的导航链接，否则，会给访问者带来很大的麻烦。比如被链接的页面出现在导航框架内，这种情况下访问者便被陷住了，因为此时他没有其他地点可去； </span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.产生多个页面，不易管理；</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.多数小型的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。</span><br></pre></td></tr></table></figure>

<h3 id="二-CSS-x2F-CSS3"><a href="#二-CSS-x2F-CSS3" class="headerlink" title="二.CSS&#x2F;CSS3"></a>二.CSS&#x2F;CSS3</h3><h4 id="1-css有哪些基本选择器-它们的权重是如何表示的"><a href="#1-css有哪些基本选择器-它们的权重是如何表示的" class="headerlink" title="1.css有哪些基本选择器?它们的权重是如何表示的?"></a>1.css有哪些基本选择器?它们的权重是如何表示的?</h4><table>
<thead>
<tr>
<th>id 选择器</th>
<th>0,1,0,0</th>
<th>2</th>
</tr>
</thead>
<tbody><tr>
<td>类、伪类、属性选择器</td>
<td>0,0,1,0</td>
<td>3</td>
</tr>
<tr>
<td>标签、伪元素选择器</td>
<td>0,0,0,1</td>
<td>4</td>
</tr>
<tr>
<td>通配符选择器</td>
<td>0,0,0,0</td>
<td>5</td>
</tr>
</tbody></table>
<p><strong>后代选择器、子选择器、兄弟选择器、交集选择器</strong>：所有的基础选择器的权重相加</p>
<p><strong>并集选择器</strong>：相当于多个选择器一起设置样式，权重分开计算即可。</p>
<h4 id="2-清除浮动带来的影响-解决高度坍塌-有几种方式"><a href="#2-清除浮动带来的影响-解决高度坍塌-有几种方式" class="headerlink" title="2. 清除浮动带来的影响(解决高度坍塌)有几种方式?"></a>2. 清除浮动带来的影响(解决高度坍塌)有几种方式?</h4><h5 id="1-为父元素开启BFC-块级格式化上下文"><a href="#1-为父元素开启BFC-块级格式化上下文" class="headerlink" title="1.为父元素开启BFC(块级格式化上下文)"></a>1.为父元素开启BFC(块级格式化上下文)</h5><h6 id="1-BFC特点"><a href="#1-BFC特点" class="headerlink" title="1)BFC特点:"></a>1)BFC特点:</h6><p>①开启BFC的元素不会被浮动元素覆盖</p>
<p>②开启BFC的父元素与其子元素外边距不会重叠(可以用来解决外边距重叠问题)</p>
<p>③开启BFC的元素可以包含浮动的子元素</p>
<h6 id="2-如何开启BFC"><a href="#2-如何开启BFC" class="headerlink" title="2)如何开启BFC"></a>2)如何开启BFC</h6><p>1、float的值不是none。<br>2、position的值不是static或者relative。<br>3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex<br>4、overflow的值不是visible</p>
<h5 id="2-设置clear"><a href="#2-设置clear" class="headerlink" title="2.设置clear"></a>2.设置clear</h5><p>1).原理:（给子元素设置clear:both相当于给它自动设置了1个mrgin-top外边距从而可以撑开父盒子高度）</p>
<p>2)实现:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//给父元素设置一个clearfix的class</span><br><span class="line"><span class="selector-class">.clearfix</span>::brfore,</span><br><span class="line">.clearfix::after&#123;</span><br><span class="line">	<span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">	dispaly:table;</span><br><span class="line">	<span class="attribute">clear</span>:both</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-怪异盒模型box-sizing-弹性盒模型盒布局"><a href="#3-怪异盒模型box-sizing-弹性盒模型盒布局" class="headerlink" title="3.怪异盒模型box-sizing?弹性盒模型盒布局?"></a>3.怪异盒模型box-sizing?弹性盒模型盒布局?</h4><h5 id="怪异盒模型："><a href="#怪异盒模型：" class="headerlink" title="怪异盒模型："></a>怪异盒模型：</h5><p>   box-sizing:<br>        属性值：<br>            box-sizing:content-box;  常规盒模型<br>            box-sizing:border-box:   怪异盒模型（IE盒模型）<br>        怪异盒模型特点：padding和border都会在元素的宽高的内部，不会把盒子撑大。</p>
<h5 id="弹性盒子：布局方案。"><a href="#弹性盒子：布局方案。" class="headerlink" title="弹性盒子：布局方案。"></a>弹性盒子：布局方案。</h5><p>​        作用：控制离它最近的一层子元素的布局方式。<br>​        特点：<br>​            a：弹性盒子里面的离它最近的一层子元素都可以添加大小。<br>​            b: 如果想让弹性盒子里面的一个子元素左右上下居中，只需要给子元素添加margin:auto即可<br>​            c: 弹性盒子里面的子元素都是沿着“主轴”排列</p>
<p>一：触发弹性盒子：<br>        display:flex;</p>
<p>二：改变主轴的方向：<br>        flex-direction:<br>            属性值：<br>                row     (默认值：X轴(自左向右)为主轴)<br>                row-reverse    (以X轴为主轴反向排列)<br>                column  (Y轴(自上向下)为主轴)<br>                column-reverse    (以Y轴为主轴反向排列)</p>
<p>三：改变主轴的对齐方式：<br>        justify-content:<br>            属性值：<br>                flex-start   默认状态：在弹性盒子开始的地方显示<br>                flex-end     在弹性盒子末端对齐<br>                center        居中对齐<br>                space-between    两端对齐<br>                space-around     自动分配间距<br>    四：侧轴的对齐方式:<br>        align-items:<br>            flex-start    侧轴开始的位置<br>            flex-end      侧轴结束的位置<br>            center        侧轴居中的位置<br>            baseline      基线（flex-start等效）<br>            stretch（默认值）   拉伸<br>    五：控制弹性盒子里面的子元素（灵活元素）换行处理：<br>        flex-wrap:<br>            wrap         换行<br>            nowrap       不换行<br>            wrap-reverse   反向换行<br>    六：控制行与行的对齐方式：<br>        align-content:<br>                flex-start   默认状态：行与行之间不存在默认的行间距<br>                flex-end     在弹性盒子末端对齐<br>                center        居中对齐<br>                space-between    两端对齐<br>                space-around     自动分配间距<br>    七：补充：flex-direction 和 flex-wrap简写：<br>        flex-flow:;<br>    注：以上7个属性全部添加在父元素弹性盒子上面！！！！！！！！！！！！！</p>
<p>添加在子元素上面的属性：</p>
<p>一：控制弹性盒子里面 某个 灵活元素 在侧轴的对齐方式。<br>        align-self:<br>            auto  默认值。元素继承了它的父容器的 align-items 属性。如果没有父容器则为 “stretch”。<br>            Stretch 元素被拉伸以适应容器。<br>            Center 元素位于容器的中心。<br>            flex-start 元素位于容器的开头。<br>            flex-end 元素位于容器的结尾。<br>    二：控制子元素的排列顺序：<br>        order: 数值越大越往后排列。支持负数。<br>    三：剩余空间的分配：<br>        flex:1;  分配主轴剩余空间。<br>    flex:1;  简写形式。</p>
<p>flex-grow:;      扩展的量<br>            flex-shrink:;    收缩的量<br>            flex-basis:;     元素的大小<br>    记住：flex-shrink:0;  不压缩。<br> 多列属性：</p>
<p>1：列数：<br>            column-count:;</p>
<p>2:列间距：<br>            column-gap:;</p>
<p>3:列分割线：<br>            column-rule:</p>
<p>4:控制每一列的列的高度是否统一：<br>            column-fill:;<br>                auto     列高度自适应内容<br>                balance  有列的高度以其中最高的一列统一</p>
<p>5:跨列：<br>            column-span:all;</p>
<p>6:列宽<br>            column-width:</p>
<p>7:columns: 7<br>            column-count 和 column-width  简写</p>
<h4 id="4-transition-transform-和animation区别"><a href="#4-transition-transform-和animation区别" class="headerlink" title="4.transition,transform 和animation区别?"></a>4.transition,transform 和animation区别?</h4><h5 id="1-transform-变形"><a href="#1-transform-变形" class="headerlink" title="1. transform(变形)"></a>1. transform(变形)</h5><h6 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义:"></a>1.1 定义:</h6><p>transform<code>主要用于给元素做变换,主要由以下几种变换,</code>rotate<code>(旋转),</code>scale<code>(缩放),</code>skew<code>(扭曲),</code>translate<code>(移动)和</code>matrix&#96;(矩阵变换).</p>
<h6 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h6><p>1)使用<code>transition</code>和<code>position: absolute;</code>结合实现水平垂直居中:</p>
<p>2)定义放大,旋转,倾斜,矩阵变换等交互效果:</p>
<h5 id="2-transition-过渡"><a href="#2-transition-过渡" class="headerlink" title="2. transition(过渡)"></a>2. transition(过渡)</h5><h6 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h6><p>用来定义某个css属性或者多个css属性的变化的过渡效果.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: property duration timing-function delay;</span><br></pre></td></tr></table></figure>

<p>属性定义及使用说明:</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transition-property</td>
<td>指定CSS属性的name，transition效果: 大小,位置,扭曲等</td>
</tr>
<tr>
<td>transition-duration</td>
<td>规定完成过渡效果需要花费的时间（以秒或毫秒计）。 默认值是 0，意味着不会有效果。</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>指定transition效果的转速曲线</td>
</tr>
<tr>
<td>transition-delay</td>
<td>定义transition效果开始的时候</td>
</tr>
</tbody></table>
<h6 id="2-2-使用场景"><a href="#2-2-使用场景" class="headerlink" title="2.2 使用场景"></a>2.2 使用场景</h6><p>1)实现激活状态的过渡效果(宽度和透明度变化):</p>
<p>2)transition和transform结合实现动画过渡</p>
<h5 id="3-animation-动画"><a href="#3-animation-动画" class="headerlink" title="3. animation(动画)"></a>3. animation(动画)</h5><h6 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h6><p>animation动画的定义,先通过@(-webkit-)keyframes定义动画名称及动画的行为,然后再通过animation的相关属性定义动画的执行效果.</p>
<p><strong>语法:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation: name duration timing-function delay iteration-count direction fill-mode play-state;</span><br></pre></td></tr></table></figure>

<p>用来定义多个中间态的一系列的动画过渡效果.</p>
<p><strong>属性定义及使用说明:</strong></p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>animation-name</td>
<td>指定要绑定到选择器的关键帧的名称</td>
</tr>
<tr>
<td>animation-duration</td>
<td>规动画指定需要多少秒或毫秒完成</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>设置动画将如何完成一个周期</td>
</tr>
<tr>
<td>animation-delay</td>
<td>设置动画在启动前的延迟间隔</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>定义动画的播放次数</td>
</tr>
<tr>
<td>animation-direction</td>
<td>指定是否应该轮流反向播放动画</td>
</tr>
<tr>
<td>animation-fill-mode</td>
<td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式</td>
</tr>
<tr>
<td>animation-play-state</td>
<td>指定动画是否正在运行或已暂停</td>
</tr>
</tbody></table>
<h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h5><p>transform, transition 和animation的区别:</p>
<ul>
<li>transform本身是没有过渡效果的,它只是对元素做大小,旋转,倾斜等各种变换,通过和transition或者animation相结合,可以让这一变换过程具有动画的效果,它通常只有一个到达态,中间态的过渡可以通过和transition或者animation相结合实现,也可以通过js设置定时器来实现.</li>
<li>transition一般是定义单个或多个css属性发生变化时的过渡动画,比如width,opacity等.当定义的css属性发生变化的时候才会执行过渡动画,animation动画一旦定义,就会在页面加载完成后自动执行.</li>
<li>transition定义的动画触发一次执行一次,想要再次执行想要再次触发.animation定义的动画可以指定播放次数或者无限循环播放. transition: 需要用户操作,执行次数固定.</li>
<li>transition定义的动画只有两个状态,开始态和结束态,animation可以定义多个动画中间态,且可以控制多个复杂动画的有序执行.</li>
</ul>
<h4 id="5-css实现子元素在父元素中水平垂直居中的几种方法"><a href="#5-css实现子元素在父元素中水平垂直居中的几种方法" class="headerlink" title="5.css实现子元素在父元素中水平垂直居中的几种方法"></a>5.css实现子元素在父元素中水平垂直居中的几种方法</h4><h5 id="方法1：使用绝对定位-margin-auto"><a href="#方法1：使用绝对定位-margin-auto" class="headerlink" title="方法1：使用绝对定位 + margin: auto"></a>方法1：使用绝对定位 + margin: auto</h5><p>适用于:父子元素宽高都未知时。</p>
<p>父元素开启定位,给子元素添加如下样式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">margin</span>:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法2：使用绝对定位-transform"><a href="#方法2：使用绝对定位-transform" class="headerlink" title="方法2：使用绝对定位 + transform"></a>方法2：使用绝对定位 + transform</h5><p>适用于:父子元素都不确定宽高的情况。</p>
<p>父元素开启定位,给子元素添加如下样式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="方法3：父元素使用flex布局，并设置相关的属性值为center"><a href="#方法3：父元素使用flex布局，并设置相关的属性值为center" class="headerlink" title="方法3：父元素使用flex布局，并设置相关的属性值为center"></a>方法3：父元素使用flex布局，并设置相关的属性值为center</h5><p>这种方式要求父元素的高度是确定的，百分比形式的高度将不能生效。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="方法4：使用table-cell实现"><a href="#方法4：使用table-cell实现" class="headerlink" title="方法4：使用table-cell实现"></a>方法4：使用table-cell实现</h5><p>这种方式需要父元素的宽高都是确定的，才能保证子元素在父元素中垂直水平都居中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">    height: 500px;</span><br><span class="line">    width: 500px;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line">.son&#123;</span><br><span class="line">    margin:0 auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-如果对-css进行优化，如何处理"><a href="#6-如果对-css进行优化，如何处理" class="headerlink" title="6.如果对 css进行优化，如何处理?"></a>6.如果对 css进行优化，如何处理?</h4><h5 id="1-内联首屏关键CSS（Critical-CSS）"><a href="#1-内联首屏关键CSS（Critical-CSS）" class="headerlink" title="1. 内联首屏关键CSS（Critical CSS）"></a>1. 内联首屏关键CSS（Critical CSS）</h5><p>性能优化中有一个重要的指标——<strong>首次有效绘制</strong>（First Meaningful Paint，简称FMP）即指页面的首要内容（primary content）出现在屏幕上的时间。这一指标影响用户看到页面前所需等待的时间，而<strong>内联首屏关键CSS（即Critical CSS，可以称之为首屏关键CSS）</strong>能减少这一时间。</p>
<p>实现:</p>
<p>我们应当<strong>只将渲染首屏内容所需的关键CSS内联到HTML中</strong>。</p>
<h5 id="2-异步加载CSS"><a href="#2-异步加载CSS" class="headerlink" title="2. 异步加载CSS"></a>2. 异步加载CSS</h5><p>CSS会阻塞渲染，在CSS文件请求、下载、解析完成之前，浏览器将不会渲染任何已处理的内容。有时，这种阻塞是必须的，因为我们并不希望在所需的CSS加载之前，浏览器就开始渲染页面。那么将首屏关键CSS内联后，剩余的CSS内容的阻塞渲染就不是必需的了，可以使用外部CSS，并且异步加载。</p>
<p>实现:</p>
<p>将link元素的<code>media</code>属性设置为用户浏览器不匹配的媒体类型（或媒体查询），如完全不存在的类型<code>media=&quot;noexist&quot;</code>。对浏览器来说，如果样式表不适用于当前媒体类型，其优先级会被放低，会在不阻塞页面渲染的情况下再进行下载。当然，这么做只是为了实现CSS的异步加载，别忘了在文件加载完成之后，将<code>media</code>的值设为<code>screen</code>或<code>all</code>，从而让浏览器开始解析CSS。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;mystyles.css&quot;</span> media=<span class="string">&quot;noexist&quot;</span> <span class="literal">on</span>load=<span class="string">&quot;this.media=&#x27;all&#x27;&quot;</span>]</span><br></pre></td></tr></table></figure>

<h5 id="3-文件压缩"><a href="#3-文件压缩" class="headerlink" title="3. 文件压缩"></a>3. 文件压缩</h5><h5 id="4-去除无用CSS"><a href="#4-去除无用CSS" class="headerlink" title="4. 去除无用CSS"></a>4. 去除无用CSS</h5><h6 id="1-有选择地使用选择器"><a href="#1-有选择地使用选择器" class="headerlink" title="1).有选择地使用选择器"></a>1).有选择地使用选择器</h6><ul>
<li>保持简单，不要使用嵌套过多过于复杂的选择器。</li>
<li>通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。</li>
<li>不要使用类选择器和ID选择器修饰元素标签，如h3#markdown-content，这样多此一举，还会降低效率。</li>
<li>不要为了追求速度而放弃可读性与可维护性。</li>
</ul>
<h6 id="2-减少使用昂贵的属性"><a href="#2-减少使用昂贵的属性" class="headerlink" title="2).减少使用昂贵的属性"></a>2).减少使用昂贵的属性</h6><p>在浏览器绘制屏幕时，<strong>所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价</strong>。当页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写CSS时，我们应该尽量减少使用昂贵属性，如<code>box-shadow</code>&#x2F;<code>border-radius</code>&#x2F;<code>filter</code>&#x2F;透明度&#x2F;<code>:nth-child</code>等。</p>
<h6 id="3-优化重排与重绘"><a href="#3-优化重排与重绘" class="headerlink" title="3) 优化重排与重绘"></a>3) 优化重排与重绘</h6><p>在网站的使用过程中，某些操作会导致样式的改变，这时浏览器需要检测这些改变并重新渲染，其中有些操作所耗费的性能更多。</p>
<p>3.1 减少重排</p>
<p>重排会导致浏览器重新计算整个文档，重新构建渲染树，这一过程会降低浏览器的渲染速度。如下所示，有很多操作会触发重排，我们应该避免频繁触发这些操作。</p>
<ul>
<li>改变<code>font-size</code>和<code>font-family</code></li>
<li>改变元素的内外边距</li>
<li>通过JS改变CSS类</li>
<li>通过JS获取DOM元素的位置相关属性（如width&#x2F;height&#x2F;left等）</li>
<li>CSS伪类激活</li>
<li>滚动滚动条或者改变窗口大小</li>
</ul>
<p>值得一提的是，某些CSS属性具有更好的重排性能。如使用<code>Flex</code>时，比使用<code>inline-block</code>和<code>float</code>时重排更快，所以在布局时可以优先考虑<code>Flex</code>。</p>
<p>3.2 避免不必要的重绘</p>
<p>当元素的外观（如color，background，visibility等属性）发生改变时，会触发重绘。在网站的使用过程中，<strong>重绘是无法避免的</strong>。不过，浏览器对此做了优化，它会将多次的重排、重绘操作合并为一次执行。不过我们仍需要<strong>避免不必要的重绘</strong>，如页面滚动时触发的hover事件，可以在滚动的时候禁用hover事件，这样页面在滚动时会更加流畅。</p>
<h6 id="4-不要使用-import"><a href="#4-不要使用-import" class="headerlink" title="4.不要使用@import"></a>4.不要使用@import</h6><p>首先，使用@import引入CSS会影响浏览器的并行下载。使用@import引用的CSS文件只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作。这就导致浏览器无法并行下载所需的样式文件。</p>
<p>其次，多个@import会导致下载顺序紊乱。在IE中，@import会引发资源文件的下载顺序被打乱，即<strong>排列在@import后面的js文件先于@import下载，并且打乱甚至破坏@import自身的并行下载</strong>。</p>
<p>所以不要使用这一方法，使用link标签就行了。</p>
<h4 id="7-CSS3-有哪些新特性"><a href="#7-CSS3-有哪些新特性" class="headerlink" title="7.CSS3 有哪些新特性?"></a>7.CSS3 有哪些新特性?</h4><h5 id="一、选择器"><a href="#一、选择器" class="headerlink" title="一、选择器"></a>一、选择器</h5><p>css3中新增了一些选择器:</p>
<p>1.关系选择器中兄弟选择器</p>
<p>2.部分属性选择器</p>
<p>3.部分伪类选择器</p>
<h5 id="二-边框"><a href="#二-边框" class="headerlink" title="二.边框"></a>二.边框</h5><p><code>css3</code>新增了三个边框属性，分别是：</p>
<ul>
<li>border-radius：创建圆角边框</li>
<li>box-shadow：为元素添加阴影</li>
<li>border-image：使用图片来绘制边框</li>
</ul>
<h5 id="三-背景"><a href="#三-背景" class="headerlink" title="三.背景"></a>三.背景</h5><p>新增了几个关于背景的属性，分别是<code>background-clip</code>、<code>background-origin</code>、<code>background-size</code>和<code>background-break</code></p>
<h6 id="1-background-clip"><a href="#1-background-clip" class="headerlink" title="1.background-clip"></a>1.background-clip</h6><p>用于确定背景画区，有以下几种可能的属性：</p>
<ul>
<li>background-clip: border-box; 背景从border开始显示</li>
<li>background-clip: padding-box; 背景从padding开始显示</li>
<li>background-clip: content-box; 背景显content区域开始显示</li>
<li>background-clip: no-clip; 默认属性，等同于border-box</li>
</ul>
<p>通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围</p>
<h6 id="2-background-origin"><a href="#2-background-origin" class="headerlink" title="2.background-origin"></a>2.background-origin</h6><p>当我们设置背景图片时，图片是会以左上角对齐，但是是以<code>border</code>的左上角对齐还是以<code>padding</code>的左上角或者<code>content</code>的左上角对齐? <code>border-origin</code>正是用来设置这个的</p>
<ul>
<li>background-origin: border-box; 从border开始计算background-position</li>
<li>background-origin: padding-box; 从padding开始计算background-position</li>
<li>background-origin: content-box; 从content开始计算background-position</li>
</ul>
<p>默认情况是<code>padding-box</code>，即以<code>padding</code>的左上角为原点</p>
<h6 id="3-background-size"><a href="#3-background-size" class="headerlink" title="3.background-size"></a>3.background-size</h6><p>background-size属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：</p>
<ul>
<li>background-size: contain; 缩小图片以适合元素（维持像素长宽比）</li>
<li>background-size: cover; 扩展元素以填补元素（维持像素长宽比）</li>
<li>background-size: 100px 100px; 缩小图片至指定的大小</li>
<li>background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸</li>
</ul>
<h6 id="4-background-break"><a href="#4-background-break" class="headerlink" title="4.background-break"></a>4.background-break</h6><p>元素可以被分成几个独立的盒子（如使内联元素span跨越多行），<code>background-break</code> 属性用来控制背景怎样在这些不同的盒子中显示</p>
<ul>
<li>background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）</li>
<li>background-break: bounding-box; 把盒之间的距离计算在内；</li>
<li>background-break: each-box; 为每个盒子单独重绘背景</li>
</ul>
<h5 id="四-文字"><a href="#四-文字" class="headerlink" title="四.文字"></a>四.文字</h5><h6 id="1-word-wrap"><a href="#1-word-wrap" class="headerlink" title="1.word-wrap"></a>1.word-wrap</h6><p>语法：<code>word-wrap: normal|break-word</code></p>
<ul>
<li>normal：使用浏览器默认的换行</li>
<li>break-all：允许在单词内换行</li>
</ul>
<h6 id="x3D-x3D-2-text-overflow-x3D-x3D-可以用来裁剪文字过多"><a href="#x3D-x3D-2-text-overflow-x3D-x3D-可以用来裁剪文字过多" class="headerlink" title="&#x3D;&#x3D;2.text-overflow&#x3D;&#x3D;(可以用来裁剪文字过多)"></a>&#x3D;&#x3D;2.text-overflow&#x3D;&#x3D;(可以用来裁剪文字过多)</h6><p><code>text-overflow</code>设置或检索当当前行超过指定容器的边界时如何显示，属性有两个值选择：</p>
<ul>
<li>clip：修剪文本</li>
<li>ellipsis：显示省略符号来代表被修剪的文本</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">	//网页如何处理空白,不换行</span><br><span class="line">	<span class="attribute">white-space</span>:nowrap;</span><br><span class="line">	<span class="attribute">overflow</span>:hidden;</span><br><span class="line">	<span class="attribute">text-overflow</span>:ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-text-shadow"><a href="#3-text-shadow" class="headerlink" title="3.text-shadow"></a>3.text-shadow</h6><p><code>text-shadow</code>可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色</p>
<h6 id="4-text-decoration"><a href="#4-text-decoration" class="headerlink" title="4.text-decoration"></a>4.text-decoration</h6><p>CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：</p>
<ul>
<li>text-fill-color: 设置文字内部填充颜色</li>
<li>text-stroke-color: 设置文字边界填充颜色</li>
<li>text-stroke-width: 设置文字边界宽度</li>
</ul>
<h5 id="五-颜色"><a href="#五-颜色" class="headerlink" title="五.颜色"></a>五.颜色</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">css3`新增了新的颜色表示方式`rgba`与`hsla</span><br></pre></td></tr></table></figure>

<ul>
<li>rgba分为两部分，rgb为颜色值，a为透明度</li>
<li>hala分为四部分，h为色相，s为饱和度，l为亮度，a为透明度</li>
</ul>
<h5 id="六-transition-过渡"><a href="#六-transition-过渡" class="headerlink" title="六.transition 过渡"></a>六.transition 过渡</h5><p><code>transition</code>属性可以被指定为一个或多个<code>CSS</code>属性的过渡效果，多个属性之间用逗号进行分隔，必须规定两项内容：</p>
<ul>
<li>过度效果</li>
<li>持续时间</li>
</ul>
<h5 id="七-transform-转换"><a href="#七-transform-转换" class="headerlink" title="七.transform 转换"></a>七.transform 转换</h5><p><code>transform</code>属性允许你旋转，缩放，倾斜或平移给定元素</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform-origin</span>`：转换元素的位置（围绕那个点进行转换），默认值为`(x,y,z):(<span class="number">50%</span>,<span class="number">50%</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<ul>
<li>transform: translate(120px, 50%)：位移</li>
<li>transform: scale(2, 0.5)：缩放</li>
<li>transform: rotate(0.5turn)：旋转</li>
<li>transform: skew(30deg, 20deg)：倾斜</li>
</ul>
<h5 id="八-animation-动画"><a href="#八-animation-动画" class="headerlink" title="八.animation 动画"></a>八.animation 动画</h5><p>动画这个平常用的也很多，主要是做一个预设的动画。和一些页面交互的动画效果，结果和过渡应该一样，让页面不会那么生硬</p>
<p>animation也有很多的属性</p>
<ul>
<li>animation-name：动画名称</li>
<li>animation-duration：动画持续时间</li>
<li>animation-timing-function：动画时间函数</li>
<li>animation-delay：动画延迟时间</li>
<li>animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环</li>
<li>animation-direction：动画执行方向</li>
<li>animation-paly-state：动画播放状态</li>
<li>animation-fill-mode：动画填充模式</li>
</ul>
<h5 id="九-渐变"><a href="#九-渐变" class="headerlink" title="九.渐变"></a>九.渐变</h5><p>颜色渐变是指在两个颜色之间平稳的过渡，<code>css3</code>渐变包括</p>
<ul>
<li>linear-gradient：线性渐变</li>
</ul>
<blockquote>
<p>background-image: linear-gradient(direction, color-stop1, color-stop2, …);</p>
</blockquote>
<ul>
<li>radial-gradient：径向渐变</li>
</ul>
<blockquote>
<p>linear-gradient(0deg, red, green);</p>
</blockquote>
<h5 id="十-布局"><a href="#十-布局" class="headerlink" title="十.布局"></a>十.布局</h5><p>关于<code>css3</code>其他的新特性还包括<code>flex</code>弹性布局、<code>Grid</code>栅格布局，这两个布局在以前就已经讲过，这里就不再展示</p>
<p>除此之外，还包括多列布局、媒体查询、混合模式等等……</p>
<h4 id="8-解释-下CSS-Sprites-以及你要如何在页面或网站中使用它。"><a href="#8-解释-下CSS-Sprites-以及你要如何在页面或网站中使用它。" class="headerlink" title="8.解释 下CSS Sprites,以及你要如何在页面或网站中使用它。"></a>8.解释 下CSS Sprites,以及你要如何在页面或网站中使用它。</h4><p>CSS Sprites(雪碧图,精灵图)其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位.</p>
<p>作用:</p>
<p>1.解决了图片闪烁问题</p>
<p>2.减少了向服务器多次请求,加快访问速度</p>
<h4 id="9-分析比较opacity-0、visibility-hidden、display-none-优劣和适用场"><a href="#9-分析比较opacity-0、visibility-hidden、display-none-优劣和适用场" class="headerlink" title="9.分析比较opacity:0、visibility:hidden、display:.none 优劣和适用场"></a>9.分析比较opacity:0、visibility:hidden、display:.none 优劣和适用场</h4><h5 id="一-区别："><a href="#一-区别：" class="headerlink" title="一.区别："></a>一.区别：</h5><p> display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击， </p>
<p>visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击 </p>
<p>opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击</p>
<h5 id="二-性能："><a href="#二-性能：" class="headerlink" title="二.性能："></a>二.性能：</h5><p>displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大 </p>
<p>visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容 </p>
<p>opacity: 0 ： 修改元素会造成重绘，性能消耗较少</p>
<h4 id="10-外边距塌陷-x2F-外边距折叠"><a href="#10-外边距塌陷-x2F-外边距折叠" class="headerlink" title="10.外边距塌陷&#x2F;外边距折叠?"></a>10.外边距塌陷&#x2F;外边距折叠?</h4><h5 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h5><p>相邻的垂直方向外边距会发生重叠现象</p>
<h5 id="解决-为元素开启BFC-块级格式化上下文"><a href="#解决-为元素开启BFC-块级格式化上下文" class="headerlink" title="解决:为元素开启BFC(块级格式化上下文)"></a>解决:为元素开启BFC(块级格式化上下文)</h5><h6 id="1-BFC特点-1"><a href="#1-BFC特点-1" class="headerlink" title="1)BFC特点:"></a>1)BFC特点:</h6><p>①开启BFC的元素不会被浮动元素覆盖</p>
<p>②开启BFC的父元素与其子元素外边距不会重叠(可以用来解决外边距重叠问题)</p>
<p>③开启BFC的元素可以包含浮动的子元素</p>
<h6 id="2-如何开启BFC-1"><a href="#2-如何开启BFC-1" class="headerlink" title="2)如何开启BFC"></a>2)如何开启BFC</h6><p>1、float的值不是none。<br>2、position的值不是static或者relative。<br>3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex<br>4、overflow的值不是visible</p>
<h4 id="11-重排-回流-和重绘"><a href="#11-重排-回流-和重绘" class="headerlink" title="11.重排(回流)和重绘?"></a>11.重排(回流)和重绘?</h4><h5 id="一-浏览器渲染"><a href="#一-浏览器渲染" class="headerlink" title="一.浏览器渲染"></a>一.浏览器渲染</h5><p>浏览器在渲染页面的时候，大致是以下几个步骤：</p>
<ol>
<li>解析html生成DOM树，解析css，生成CSSOM树，将DOM树和CSSOM树结合，生成渲染树；</li>
<li>根据渲染树，浏览器可以计算出网页中有哪些节点，各节点的CSS以及从属关系 - 回流</li>
<li>根据渲染树以及回流得到的节点信息，计算出每个节点在屏幕中的位置 - 重绘</li>
<li>最后将得到的节点位置信息交给浏览器的图形处理程序，让浏览器中显示页面</li>
</ol>
<h5 id="二-回流"><a href="#二-回流" class="headerlink" title="二.回流"></a>二.回流</h5><p>回流：英文叫reflow，指的是当渲染树中的节点信息发生了大小、边距等问题，需要重新计算各节点和css具体的大小和位置。</p>
<p>例：在css中对一个div修饰的样式中，使用了宽度50%，此时需要将50%转换为具体的像素，这个计算的过程，就是回流的过程。</p>
<h5 id="三-重绘"><a href="#三-重绘" class="headerlink" title="三.重绘"></a>三.重绘</h5><p>重绘：英文叫repaint，当节点的部分属性发生变化，但不影响布局，只需要重新计算节点在屏幕中的绝对位置并渲染的过程，就叫重绘。比如：改变元素的背景颜色、字体颜色等操作会造成重绘。</p>
<p>回流的过程在重绘的过程前面，所以回流一定会重绘，但重绘不一定会引起回流。</p>
<h4 id="12-常用的几种布局方式"><a href="#12-常用的几种布局方式" class="headerlink" title="12.常用的几种布局方式"></a>12.常用的几种布局方式</h4><h5 id="1-固定布局"><a href="#1-固定布局" class="headerlink" title="1.固定布局"></a>1.固定布局</h5><blockquote>
<p>宽度，高度固定，页面被一个固定网页包裹，容器不能移动，页面的宽高不随页面的变化而变化，这种布局大家比较熟悉，这种方式一度成为页面布局的主流方式，这样布局设计简单，更容易定义，但是由于屏幕尺寸的不同，特别是移动端各个设备的不同，这种布局在灵活性方式可用度不高。</p>
</blockquote>
<h5 id="2-流式布局"><a href="#2-流式布局" class="headerlink" title="2.流式布局"></a>2.流式布局</h5><blockquote>
<p>以百分比为主要形式，让屏幕自适应，这种布局方式定义灵活，能够根据屏幕的情况变化，但是这种方式设计的效果不太容易控制，一般移动端结合rem用的比较多，pc端用的不是非常多</p>
</blockquote>
<h5 id="3-弹性布局"><a href="#3-弹性布局" class="headerlink" title="3.弹性布局"></a>3.弹性布局</h5><blockquote>
<p>浮动部分和清楚浮动部分主要是兼容添加的一些代码，重点看弹性布局的部分，弹性布局相对前两种出现的比较晚些，但是弹性布局功能还是很强大的，布局也非常方便，但是此布局形式在pc端并不推荐使用，ie9以下浏览器均不支持，另外火狐等一些浏览器也需要做兼容，移动端目前绝大部分浏览器都已经支持弹性布局，在移动端大家可以尝试使用。</p>
</blockquote>
<h5 id="4-浮动布局"><a href="#4-浮动布局" class="headerlink" title="4.浮动布局"></a>4.浮动布局</h5><blockquote>
<p>浮动布局关键词，float，可以设置left或者right，他使元素脱离文档流进而达到布局的目的，也是目前一个比较主流的布局方式，但是使用浮动的结束以后，别忘记清除浮动哦。</p>
</blockquote>
<h5 id="5-定位布局"><a href="#5-定位布局" class="headerlink" title="5.定位布局"></a>5.定位布局</h5><blockquote>
<p>定位布局也是目前比较常用的一种布局方式，关键词： position: fixed;固定布局，将元素固定在一个位置，不随页面移动而移动，position: relative;相对定位，相对于元素自身定位，不脱离文档流，相当于定义一个参照物，一般和绝对定位结合使用，position: absolute;绝对定位，脱离文档流，一般和相对定位结合使用，如果不定义相对定义，将会相对于整个浏览器定位，所以定位布局，一般情况下都是相对定位和绝对定位结合着来，相当定位相当于划定一个势力范围，制定一个封闭的容器块，然后绝对定位就行对于相对定位来定位，从而达到有效的布局。</p>
</blockquote>
<h4 id="13-css3-实现0-5px的细线"><a href="#13-css3-实现0-5px的细线" class="headerlink" title="13.css3 实现0.5px的细线"></a>13.css3 实现0.5px的细线</h4><h5 id="一-渐变实现"><a href="#一-渐变实现" class="headerlink" title="一.渐变实现"></a>一.渐变实现</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">0deg</span>, transparent <span class="number">50%</span>, <span class="number">#e0e0e0</span> <span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="二-使用缩放"><a href="#二-使用缩放" class="headerlink" title="二.使用缩放"></a>二.使用缩放</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;  &quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e0e0e0</span>;</span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">scaleY</span>(.<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="14-用纯CSS创建-一个三角形的原理是什么"><a href="#14-用纯CSS创建-一个三角形的原理是什么" class="headerlink" title="14.用纯CSS创建-一个三角形的原理是什么"></a>14.用纯CSS创建-一个三角形的原理是什么</h4><p>盒子模型的border就是由三角形组成的，我们可以通过设置元素的宽高为0，然后修改border的宽度，并且修改其颜色，来达到绘制三角形的目的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">0px</span>;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">0px</span>;</span><br><span class="line">	<span class="attribute">border</span>:solid <span class="number">9px</span> transparent;</span><br><span class="line">	<span class="attribute">border-top</span>:none;</span><br><span class="line">	<span class="attribute">border-bottom-color</span>:red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-CSS样式中常用单位"><a href="#15-CSS样式中常用单位" class="headerlink" title="15.CSS样式中常用单位?"></a>15.CSS样式中常用单位?</h4><h5 id="一-px"><a href="#一-px" class="headerlink" title="一.px"></a>一.px</h5><p>px 是图像显示的基本单元，是 viewport 像素，是相对单位。同样都是 1px，在不同设备上的显示有可能是不一样的。</p>
<h5 id="二-百分号"><a href="#二-百分号" class="headerlink" title="二.百分号 %"></a>二.百分号 %</h5><p>% 是相对于父元素的尺寸来计算的。</p>
<h5 id="三-em"><a href="#三-em" class="headerlink" title="三.em"></a>三.em</h5><p>em 是相对于父元素的 font-size 来计算的。</p>
<h5 id="四-rem"><a href="#四-rem" class="headerlink" title="四.rem"></a>四.rem</h5><p>rem 是相对于根元素 [html&gt; 的 font-size 来计算的(注意,谷歌浏览器最小font-size为10px,其他12px.浏览器默认大小为16px)，比如说你设置了1.2rem，根元素的font-size是100px，那么这个元素动态算出来的px数就是120px。</p>
<h5 id="五-vw，vh，vmin，vmax"><a href="#五-vw，vh，vmin，vmax" class="headerlink" title="五.vw，vh，vmin，vmax"></a>五.vw，vh，vmin，vmax</h5><p>vw、vh、vmin、vmax 是一种视窗单位，也是相对单位。是由视窗（Viewport）大小来决定的，单位 1，代表类似于 1%。<br>视窗(Viewport)是你的浏览器实际显示内容的区域（不包括工具栏和按钮）。</p>
<p>具体描述如下：</p>
<p>vw：视窗宽度的百分比（1vw 代表视窗的宽度为 1%）<br>vh：视窗高度的百分比<br>vmin：当前 vw 和 vh 中较小的一个值<br>vmax：当前 vw 和 vh 中较大的一个值<br>（3）vmin、vmax 用处<br>做移动页面开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的。<br>由于 vmin 和 vmax 是当前较小的 vw 和 vh 和当前较大的 vw 和 vh。这里就可以用到 vmin 和 vmax。使得文字大小在横竖屏下保持一致。</p>
<h5 id="所以可以使用rem-vm结合制作移动端"><a href="#所以可以使用rem-vm结合制作移动端" class="headerlink" title="所以可以使用rem+vm结合制作移动端:"></a>所以可以使用rem+vm结合制作移动端:</h5><p>在980px设计图中</p>
<p>​	100vm&#x3D;980px&#x3D;&gt;0.102vm&#x3D;1px;</p>
<p>​	所以将浏览器的font-size设为10.2vm,此时1rem&#x3D;100px</p>
<h4 id="16-请解释一下-CSS3的Flexbox-弹性盒布局模型"><a href="#16-请解释一下-CSS3的Flexbox-弹性盒布局模型" class="headerlink" title="16.请解释一下 CSS3的Flexbox ( 弹性盒布局模型) ?"></a>16.请解释一下 CSS3的Flexbox ( 弹性盒布局模型) ?</h4><h5 id="1-什么是flex"><a href="#1-什么是flex" class="headerlink" title="1.什么是flex"></a>1.什么是flex</h5><p>flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。块级元素只需要display属性为flex即可。行内元素也可以使用 Flex 布局。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: inline-flex; </span><br><span class="line">&#125;。</span><br><span class="line">//Webkit 内核的浏览器，必须加上-webkit前缀</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">&#125;。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。 它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。 项目默认沿主轴排列。</p>
<h5 id="2-容器属性"><a href="#2-容器属性" class="headerlink" title="2.容器属性"></a>2.容器属性</h5><p>flex-direction属性决定主轴的方向（即项目的排列方向）。<br>flex-wrap属性定义，如果一条轴线排不下，如何换行。默认情况下，项目都排在一条线（又称”轴线”）上。<br>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap                                       flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小                                    justify-content属性定义了项目在主轴上的对齐方式。<br>align-items属性定义项目在交叉轴上如何对齐。<br>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<h5 id="3-项目属性"><a href="#3-项目属性" class="headerlink" title="3.项目属性"></a>3.项目属性</h5><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小<br>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br>flex属性是以上三个的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。<br>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</p>
<h4 id="17-link-与-import的区别"><a href="#17-link-与-import的区别" class="headerlink" title="17.link 与@import的区别."></a>17.link 与@import的区别.</h4><p>一.link属于html标签。@import在css中使用表示导入外部样式表；</p>
<p>二.页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</p>
<p>三.import只在IE5以上才能识别，而link是HTML标签，无兼容问题;</p>
<p>四.link方式的样式的权重 高于@import的权重；</p>
<p>五.link 支持使用javascript改变样式 （document.styleSheets），后者不可</p>
<h3 id="三-JS"><a href="#三-JS" class="headerlink" title="三.JS"></a>三.JS</h3><h4 id="1-值传递和引用传递分别是什么，有什么区别"><a href="#1-值传递和引用传递分别是什么，有什么区别" class="headerlink" title="1.值传递和引用传递分别是什么，有什么区别?"></a>1.值传递和引用传递分别是什么，有什么区别?</h4><p>值传递：传递的是实际参数的一个副本。基本数据类型Undefined，Null，Boolean，Number、String都是值传递。</p>
<p>引用传递：传递的是实际参数的地址。引用数据类型Object，Array，Date， Function等都是引用传递。</p>
<h4 id="2-怎样添加、-移除、移动、复制、创建和查找节点"><a href="#2-怎样添加、-移除、移动、复制、创建和查找节点" class="headerlink" title="2.怎样添加、 移除、移动、复制、创建和查找节点?"></a>2.怎样添加、 移除、移动、复制、创建和查找节点?</h4><p>1.添加：appendChild();语法:父节点.appendChild(子节点)</p>
<p>2.移除：removeChild();语法:父节点.removeChild(子节点)</p>
<p>3.移动(插入,向指定子节点前插入节点)：insertBefore();语法:父节点.insertBefore(新节点,旧节点)</p>
<p>4.复制：cloneNode() ;</p>
<p>语法:如果您需要克隆所有后代，请把 deep 参数设置 true，否则设置为 false。要克隆的节点.cloneNode(false)</p>
<p>5.创建：createElement();语法:</p>
<p>6.查找：getElementsByTag</p>
<h4 id="3-javascript-中有几种数据类型-怎么判断数据类型"><a href="#3-javascript-中有几种数据类型-怎么判断数据类型" class="headerlink" title="3.javascript 中有几种数据类型?怎么判断数据类型"></a>3.javascript 中有几种数据类型?怎么判断数据类型</h4><h5 id="一-总共八种"><a href="#一-总共八种" class="headerlink" title="(一)总共八种"></a>(一)总共八种</h5><p>1.七种基本数据类型</p>
<p>1)Number</p>
<p>2)String</p>
<p>3)Boolean</p>
<p>4)Undefined</p>
<p>5)Null</p>
<p>6)Symbol</p>
<p>7)Bigint</p>
<p>2.一种引用数据类型</p>
<p>1).Object(包括Array Function 等)</p>
<h5 id="二-鉴定方法"><a href="#二-鉴定方法" class="headerlink" title="(二)鉴定方法"></a>(二)鉴定方法</h5><p>1.typeof(typeof XXX)</p>
<p>可鉴别 Number,String,Boolean,Undefined,Symbol,Bigint,function</p>
<p>2.&#x3D;&#x3D;&#x3D;</p>
<p>可鉴别undefined,null</p>
<p>3.instanceof(a instanceof Array)</p>
<p>判断对象具体类型,返回true&#x2F;false</p>
<h4 id="4-var-let-和const之间的区别"><a href="#4-var-let-和const之间的区别" class="headerlink" title="4.var,let 和const之间的区别"></a>4.var,let 和const之间的区别</h4><p><code>var</code>、<code>let</code>、<code>const</code>三者区别可以围绕下面五点展开：</p>
<h5 id="一-变量提升"><a href="#一-变量提升" class="headerlink" title="(一)变量提升"></a>(一)变量提升</h5><p>var<code>声明的变量存在变量提升，即变量可以在声明之前调用，值为</code>undefined</p>
<p><code>let</code>和<code>const</code>不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</p>
<h5 id="二-暂时性死区"><a href="#二-暂时性死区" class="headerlink" title="(二)暂时性死区"></a>(二)暂时性死区</h5><p><code>var</code>不存在暂时性死区</p>
<p><code>let</code>和<code>const</code>存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p>
<h5 id="三-块级作用域"><a href="#三-块级作用域" class="headerlink" title="(三)块级作用域"></a>(三)块级作用域</h5><p><code>var</code>不存在块级作用域</p>
<p><code>let</code>和<code>const</code>存在块级作用域</p>
<h5 id="四-重复声明"><a href="#四-重复声明" class="headerlink" title="(四)重复声明"></a>(四)重复声明</h5><p><code>var</code>允许重复声明变量</p>
<p><code>let</code>和<code>const</code>在同一作用域不允许重复声明变量</p>
<h5 id="五-修改声明的变量"><a href="#五-修改声明的变量" class="headerlink" title="(五)修改声明的变量"></a>(五)修改声明的变量</h5><p><code>var</code>和<code>let</code>可以</p>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变</p>
<h4 id="5-JavaScript-数组的常用方法"><a href="#5-JavaScript-数组的常用方法" class="headerlink" title="5.JavaScript 数组的常用方法?"></a>5.JavaScript 数组的常用方法?</h4><h5 id="一-增"><a href="#一-增" class="headerlink" title="(一)增"></a>(一)增</h5><p>下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响</p>
<ul>
<li><p>push()</p>
<p>向尾部添加</p>
</li>
<li><p>unshift()</p>
<p>向头部添加</p>
</li>
<li><p>splice()</p>
<p>将指定元素从原数组中删除。传入三个参数,(开始位置、要删除的元素数量,插入的元素)。返回删除值</p>
</li>
<li><p>concat()</p>
<p>连接两个或多个数组,并将新的数组返回</p>
</li>
</ul>
<h5 id="二-删"><a href="#二-删" class="headerlink" title="(二)删"></a>(二)删</h5><p>下面三种都会影响原数组，最后一项不影响原数组：</p>
<ul>
<li><p>pop()</p>
<p>删除最后一个元素</p>
</li>
<li><p>shift()</p>
<p>删除第一个元素</p>
</li>
<li><p>splice()</p>
<p>将指定元素从原数组中删除。传入三个参数,(开始位置、要删除的元素数量,插入的元素)。返回删除值</p>
</li>
<li><p>slice()</p>
<p>用于创建一个包含原有数组中一个或多个元素的新数组,传入三个参数,(开始位置、结束位置)</p>
</li>
</ul>
<h5 id="三-改"><a href="#三-改" class="headerlink" title="(三)改"></a>(三)改</h5><p>slice():用于创建一个包含原有数组中一个或多个元素的新数组,传入三个参数,(开始位置、结束位置)</p>
<h5 id="四-查"><a href="#四-查" class="headerlink" title="(四)查"></a>(四)查</h5><p>即查找元素，返回元素坐标或者元素值,多不会改变原数组</p>
<ul>
<li><p>indexOf()</p>
<p>返回要查找的元素在数组中的位置，如果没找到则返回 -1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>includes()</p>
<p>返回要查找的元素在数组中的位置，找到返回<code>true</code>，否则<code>false</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">includes</span>(<span class="number">4</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>find()</p>
<p>返回第一个匹配的元素</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">27</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line">people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>) <span class="comment">// // &#123;name: &quot;Matt&quot;, age: 27&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="五-排序"><a href="#五-排序" class="headerlink" title="(五)排序"></a>(五)排序</h5><p>数组有两个方法可以用来对元素重新排序,多改变原数组：</p>
<ul>
<li><p>reverse()</p>
<p>将数组元素方向反转</p>
</li>
<li><p>sort()</p>
<p>sort()方法(默认按照unicode编码排序)接受一个比较函数,需要两个形参,根据返回值判断顺序。</p>
<p>如果返回值&gt;0则元素交换位置,&lt;&#x3D;0则不变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.<span class="title function_">sort</span>(compare);</span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 0,1,5,10,15</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="六-转换"><a href="#六-转换" class="headerlink" title="(六)转换"></a>(六)转换</h5><ul>
<li>join() 方法将数组转换为字符串,接收一个参数，即字符串分隔符，返回包含所有项的字符串</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">alert(colors.join(&quot;,&quot;)); // red,green,blue</span><br><span class="line">alert(colors.join(&quot;||&quot;)); // red||green||blue</span><br></pre></td></tr></table></figure>

<ul>
<li><p>from()方法 从具有 length 属性或可迭代对象的任何对象返回 Array 对象。(将伪数组转换为数组)</p>
<p>Array.from(object,mapFunction,thisValue);<br>参数说明：</p>
<ol>
<li><code>object</code>：必须，要转换为数组的对象。</li>
<li><code>mapFunction</code>：可选，数组中每个元素要调用的函数。</li>
<li><code>thisValue</code>：可选，映射函数（mapFunction）中的this对象</li>
</ol>
</li>
</ul>
<h5 id="七-遍历"><a href="#七-遍历" class="headerlink" title="(七)遍历"></a>(七)遍历</h5><p>常用来迭代数组的方法（都不改变原数组）有如下：</p>
<ul>
<li><p>some()</p>
<p>对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> someResult = numbers.<span class="title function_">some</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(someResult) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>every()</p>
<p>对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> everyResult = numbers.<span class="title function_">every</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(everyResult) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>forEach()</p>
<p>对数组每一项都运行传入的函数，没有返回值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>filter()</p>
<p>对数组每一项都运行传入的函数，函数返回 <code>true</code> 的项会组成数组之后返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filterResult); <span class="comment">// 3,4,5,4,3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>map()</p>
<p>对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapResult) <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-ES6-的新特性"><a href="#6-ES6-的新特性" class="headerlink" title="6.ES6 的新特性"></a>6.ES6 的新特性</h4><h5 id="1、let和const"><a href="#1、let和const" class="headerlink" title="1、let和const"></a>1、let和const</h5><h5 id="2、symbol"><a href="#2、symbol" class="headerlink" title="2、symbol"></a>2、symbol</h5><h5 id="3、模板字符串"><a href="#3、模板字符串" class="headerlink" title="3、模板字符串"></a>3、模板字符串</h5><p>​	3.1 字符串新方法（补充）</p>
<h5 id="4、解构表达式"><a href="#4、解构表达式" class="headerlink" title="4、解构表达式"></a>4、解构表达式</h5><p>​	4.1 数组解构<br>​	4.2 对象解构</p>
<h5 id="5、对象方面"><a href="#5、对象方面" class="headerlink" title="5、对象方面"></a>5、对象方面</h5><p>​	5.1 Map和Set<br>​		5.1.1 Map<br>​		5.1.2 Set<br>​	5.3 数组的新方法<br>​		5.3.1 Array.from()方法<br>​		5.3.2 includes()方法<br>​		5.3.3 map()、filter() 方法<br>​		5.3.4 forEach()方法<br>​		5.3.4 find()方法<br>​		5.3.6 some()、every() 方法<br>​	5.4 object的新方法<br>​		5.4.1 Object.is()<br>​		5.4.2 Object.assign()<br>​		5.4.3 Object.keys()、Object.values()、Object.entries()<br>​	5.5 对象声明简写<br>​	5.6 …(对象扩展符)</p>
<h5 id="6、函数方面"><a href="#6、函数方面" class="headerlink" title="6、函数方面"></a>6、函数方面</h5><p>​	6.1 参数默认值<br>​	6.2 箭头函数<br>​	6.3 箭头函数和普通函数最大的区别在于其内部this永远指向其父级对象的this。(重点)</p>
<h5 id="7、class（类）"><a href="#7、class（类）" class="headerlink" title="7、class（类）"></a>7、class（类）</h5><h5 id="8、promise"><a href="#8、promise" class="headerlink" title="8、promise"></a>8、promise</h5><h5 id="9、模块化"><a href="#9、模块化" class="headerlink" title="9、模块化"></a>9、模块化</h5><h4 id="7-普通-函数和箭头函数的区别"><a href="#7-普通-函数和箭头函数的区别" class="headerlink" title="7.普通 函数和箭头函数的区别"></a>7.普通 函数和箭头函数的区别</h4><h5 id="一-语法更加简洁、清晰"><a href="#一-语法更加简洁、清晰" class="headerlink" title="(一)语法更加简洁、清晰"></a>(一)语法更加简洁、清晰</h5><p>从上面的箭头函数基本语法示例中可以看出，箭头函数的定义要比普通函数定义简洁、清晰得多，很快捷。</p>
<h5 id="二-箭头函数没有-prototype-原型-，所以箭头函数本身没有this"><a href="#二-箭头函数没有-prototype-原型-，所以箭头函数本身没有this" class="headerlink" title="(二)箭头函数没有 prototype (原型)，所以箭头函数本身没有this"></a>(二)箭头函数没有 prototype (原型)，所以箭头函数本身没有this</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// &#123;constructor:f&#125;复制代码</span></span><br></pre></td></tr></table></figure>

<h5 id="三-箭头函数不会创建自己的this"><a href="#三-箭头函数不会创建自己的this" class="headerlink" title="(三)箭头函数不会创建自己的this"></a>(三)箭头函数不会创建自己的this</h5><p>箭头函数没有自己的this，箭头函数的this指向在定义（<strong>注意：</strong>是定义时，不是调用时）的时候继承自外层第一个普通函数的this。所以，箭头函数中 <code>this </code>的指向在它被定义的时候就已经确定了，之后永远不会改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">// undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">// 10</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// &#123;a: 10, b: ƒ, c: ƒ&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">b</span>(); </span><br><span class="line">obj.<span class="title function_">c</span>();复制代码</span><br></pre></td></tr></table></figure>

<h5 id="四-call-apply-bind-无法改变箭头函数中this的指向"><a href="#四-call-apply-bind-无法改变箭头函数中this的指向" class="headerlink" title="(四)call | apply | bind 无法改变箭头函数中this的指向"></a>(四)call | apply | bind 无法改变箭头函数中this的指向</h5><p><code>call | apply | bind</code>方法可以用来动态修改函数执行时this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数<code>this</code>的指向。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="number">10</span>;</span><br><span class="line">let <span class="function"><span class="keyword">fun</span> = <span class="params">()</span></span> =&gt; &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span></span>;     <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">fun</span>.call(&#123; id: <span class="number">20</span> &#125;);     <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">fun</span>.apply(&#123; id: <span class="number">20</span> &#125;);    <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">fun</span>.bind(&#123; id: <span class="number">20</span> &#125;)();   <span class="comment">// 10复制代码</span></span><br></pre></td></tr></table></figure>

<h5 id="五-箭头函数不能作为构造函数使用"><a href="#五-箭头函数不能作为构造函数使用" class="headerlink" title="(五)箭头函数不能作为构造函数使用"></a>(五)箭头函数不能作为构造函数使用</h5><p>我们先了解一下构造函数的new都做了些什么？简单来说，分为四步： ① JS内部首先会先生成一个对象； ② 再把函数中的this指向该对象； ③ 然后执行构造函数中的语句； ④ 最终返回该对象实例。</p>
<p>但是！！因为箭头函数没有自己的<code>this</code>，它的<code>this</code>其实是继承了外层执行环境中的<code>this</code>，且<code>this</code>指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用new调用时会报错！</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let <span class="attr">Fun</span> = (name, age) =&gt; &#123;</span><br><span class="line">    <span class="attr">this.name</span> = name<span class="comment">;</span></span><br><span class="line">    <span class="attr">this.age</span> = age<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">let <span class="attr">p</span> = new Fun(<span class="string">&#x27;dingFY&#x27;</span>, <span class="number">24</span>)<span class="comment">;复制代码</span></span><br></pre></td></tr></table></figure>

<h4 id="8-说一下Promise"><a href="#8-说一下Promise" class="headerlink" title="8.说一下Promise?"></a>8.说一下Promise?</h4><h5 id="一-定义"><a href="#一-定义" class="headerlink" title="(一)定义"></a>(一)定义</h5><p>Promise本质上只是一个构造函数,使用Promise new出来的实例对象可以用来封装一个异步操作,并可以获取其成功&#x2F;失败的结果.可以用来解决异步编程(回调地狱)</p>
<h5 id="二-使用"><a href="#二-使用" class="headerlink" title="(二)使用"></a>(二)使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p=<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//Promise三种状态:</span></span><br><span class="line">	<span class="comment">//Pending  			未定义</span></span><br><span class="line">	<span class="comment">//Resolved/fulfilled 成功</span></span><br><span class="line">	<span class="comment">//Rejected 			失败</span></span><br><span class="line">	<span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">		<span class="comment">//成功传值i</span></span><br><span class="line">		<span class="title function_">resolve</span>(i)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//失败传值j</span></span><br><span class="line">		<span class="title function_">reject</span>(j)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;&#125;)<span class="comment">//value==i;reason==j</span></span><br></pre></td></tr></table></figure>

<h5 id="三-API"><a href="#三-API" class="headerlink" title="(三)API"></a>(三)API</h5><p><code>Promise</code>构建出来的实例存在以下方法：</p>
<ul>
<li><p>then()</p>
<p><code>then</code>是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例，也就是<code>promise</code>能链式书写的原因</p>
</li>
<li><p>catch()</p>
<p><code>catch()</code>方法用于指定发生错误时的回调函数,<code>Promise</code>对象的错误存在异常穿透，会一直向后传递，直到被捕获为止。所以常常使用<code>catch</code>方法代替<code>then()</code>第二个参数</p>
</li>
<li><p>resolve()</p>
<p>快速返回一个成功&#x2F;失败的Promise对象</p>
</li>
<li><p>reject()</p>
<p>快速返回一个失败的Promise对象</p>
</li>
<li><p>all()</p>
<p><code>Promise.all()</code>方法用于将多个 <code>Promise</code>实例，返回一个新的 <code>Promise</code>实例,只有所有多成功,其才成功.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>接受一个数组（迭代对象）作为参数，数组成员都应为<code>Promise</code>实例</p>
</li>
<li><p>race()</p>
<p>返回一个新的Promise对象,接收promise对象数组,第一个完成的promise对象状态为其状态</p>
</li>
</ul>
<h4 id="9-Async-x2F-await-对比promise的优缺点"><a href="#9-Async-x2F-await-对比promise的优缺点" class="headerlink" title="9.Async&#x2F;await 对比promise的优缺点"></a>9.Async&#x2F;await 对比promise的优缺点</h4><p>async&#x2F;await优点：<br>a. 它做到了真正的串行的同步写法，代码阅读相对容易<br>b. 对于条件语句和其他流程语句比较友好，可以直接写到判断条件里面<br>c. 处理复杂流程时，在代码清晰度方面有优势</p>
<p>async&#x2F;await缺点：<br>a. 无法处理promise返回的reject对象，要借助try…catch…<br>b. 用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。<br>c. try…catch…内部的变量无法传递给下一个try…catch…,Promise和then&#x2F;catch内部定义的变量，能通过then链条的参数传递到下一个then&#x2F;catch，但是async&#x2F;await的try内部的变量，如果用let和const定义则无法传递到下一个try…catch…，只能在外层作用域先定义好。</p>
<p>promise的一些问题：<br>a. 一旦执行，无法中途取消，链式调用多个then中间不能随便跳出来<br>b. 错误无法在外部被捕捉到，只能在内部进行预判处理，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部<br>c. Promise内部如何执行，监测起来很难，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</p>
<h4 id="10-JS中的堆和栈，栈和队列有什么区别"><a href="#10-JS中的堆和栈，栈和队列有什么区别" class="headerlink" title="10.JS中的堆和栈，栈和队列有什么区别"></a>10.JS中的堆和栈，栈和队列有什么区别</h4><p>堆：堆是一种树形数据结构，读取相对复杂。堆是动态分配内存，内存大小不一，也不会自动释放。栈中的数据长度不定，且占空间比较大。便于开辟内存空间，更加方便存储。<strong>引用类型</strong>是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用。</p>
<p>栈：栈是一种线性的数据结构，读取规则是<strong>先进后出</strong>。栈中的数据占用的内存空间的大小是确定的，便于代码执行时的入栈、出栈操作，并由系统自动分配和自动释放内存可以及时得到回收，相对于堆来说，更加容易管理内存空间. <strong>基本类型</strong>是保存在栈内存中的简单数据段，它们的值都有固定的大小，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放，通过按值访问。</p>
<p>队列:队列是一种<strong>先进先出</strong>的数据结构。 队列在列表的末端增加项，在首端移除项。它允许在表的首端（队列头）进行删除操作，在表的末端（队列尾）进行插入操作；(回调队列)</p>
<h4 id="11-什么是闭包，如何使用它，为什么要使用它"><a href="#11-什么是闭包，如何使用它，为什么要使用它" class="headerlink" title="11.什么是闭包，如何使用它，为什么要使用它?"></a>11.什么是闭包，如何使用它，为什么要使用它?</h4><h5 id="一-定义-1"><a href="#一-定义-1" class="headerlink" title="(一)定义"></a>(一)定义</h5><p>闭包是一个存在于<strong>被外部函数嵌套</strong>的内部函数中的包含被引用变量的<strong>对象</strong></p>
<h5 id="二-产生条件"><a href="#二-产生条件" class="headerlink" title="(二)产生条件"></a>(二)产生条件</h5><p>1.函数存在嵌套</p>
<p>2.内部函数引用了外部函数的数据</p>
<p>3.外部函数被调用(内部函数被定义就会产生闭包,不需要调用内部函数)</p>
<h5 id="三-作用"><a href="#三-作用" class="headerlink" title="(三)作用"></a>(三)作用</h5><p>1.正常情况下,函数执行完后内部声明的局部变量不会存在。但是闭包可以让这些变量的值始终保持在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中。</p>
<p>2.正常情况下,函数外部不可以直接访问函数内部的局部变量。但是闭包可以读取函数内部的变量；</p>
<h4 id="12-new-操作符到底到了什么"><a href="#12-new-操作符到底到了什么" class="headerlink" title="12.new 操作符到底到了什么"></a>12.new 操作符到底到了什么</h4><p>new操作符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
<p>语法：new constructor[([arguments])]</p>
<p>其中，constructor是一个指定对象实例的类型的类或函数，arguments是一个用来被constructor调用的参数列表。 </p>
<p>var  a &#x3D; new A();</p>
<p>假设我们要创建一个构造函数A()的实例a，则必须使用new操作符。会经历以下4个步骤：</p>
<p>（1）创建一个空对象（var o&#x3D;new Object();）</p>
<p>（2）将空对象的原型赋值为构造函数A的原型（o.<strong>proto</strong>&#x3D;A.prototype;）</p>
<p>（3）执行构造函数中的代码，为空对象添加属性（A.call(o);），也可以理解为将构造器函数内部this指向新建的空对象。</p>
<p>（4）返回添加属性后的对象。</p>
<h4 id="13-改变this的指向中bind、call、-apply-的区别"><a href="#13-改变this的指向中bind、call、-apply-的区别" class="headerlink" title="13.改变this的指向中bind、call、 apply 的区别."></a>13.改变this的指向中bind、call、 apply 的区别.</h4><h5 id="一-this指向"><a href="#一-this指向" class="headerlink" title="(一)this指向"></a>(一)this指向</h5><ul>
<li>直接调用函数时，this指向window。</li>
<li>以方法的形式调用时，this指向包含调用方法的那个对象。</li>
<li>当以构造函数的形式调用时,this就是新创建的那个对象</li>
<li>使用call(),apply(),bind()调用时,this就是指向方法中的对象</li>
</ul>
<h5 id="二-三者区别"><a href="#二-三者区别" class="headerlink" title="(二)三者区别"></a>(二)三者区别</h5><p>接收参数的方式不同</p>
<h6 id="1-call"><a href="#1-call" class="headerlink" title="1.call()"></a>1.call()</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,a+b);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">       <span class="keyword">var</span> obj = &#123;</span><br><span class="line">       <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">      fn1.<span class="title function_">call</span>(obj,<span class="number">10</span>,<span class="number">20</span>); <span class="comment">// obj,30</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">fn2</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h6 id="2-apply"><a href="#2-apply" class="headerlink" title="2.apply()"></a>2.apply()</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">        <span class="comment">// arguments把a,b的1,2传给fn1。</span></span><br><span class="line">       fn1.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>); <span class="comment">// 3</span></span><br><span class="line">       fn1.<span class="title function_">apply</span>(<span class="variable language_">this</span>,[<span class="number">20</span>,<span class="number">30</span>]); <span class="comment">// 50</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn2</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h6 id="3-bind"><a href="#3-bind" class="headerlink" title="3.bind()"></a>3.bind()</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">       <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> a = fn1.<span class="title function_">bind</span>(obj);</span><br><span class="line">   <span class="comment">//此时this指向obj.  this.color则为obj的属性blue</span></span><br><span class="line">   <span class="title function_">a</span>(); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure>

<h4 id="14-javascript-对象的深度克隆"><a href="#14-javascript-对象的深度克隆" class="headerlink" title="14 .javascript 对象的深度克隆?"></a>14 .javascript 对象的深度克隆?</h4><p>1、浅克隆</p>
<p>浅克隆之所以被称为浅克隆，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.</p>
<p>2.深克隆</p>
<p>2.1 JSON.parse方法</p>
<p>JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(oldObj));</span><br></pre></td></tr></table></figure>

<p>缺点</p>
<ul>
<li>1.他无法实现对函数 、RegExp等特殊对象的克隆;</li>
<li>2.会抛弃对象的constructor,所有的构造函数会指向Object;</li>
<li>3.对象有循环引用,会报错;</li>
</ul>
<p>2.2<a target="_blank" rel="noopener" href="https://www.delftstack.com/zh/howto/javascript/javascript-deep-clone-an-object/#%E5%9C%A8-javascript-%E4%B8%AD%E4%BD%BF%E7%94%A8-lodash-%E5%BA%93%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1">在 JavaScript 中使用 Lodash 库深度克隆对象</a></p>
<p>Lodash 库具有浅拷贝和深拷贝的函数，即 <code>clone</code> 和 <code>clonedeep</code>。这是一个很棒的库，它允许我们仅导入所需的功能，而不导入完整的库。<code>clonedeep</code> 方法的工作方式是递归地复制值，然后保留所有对象继承，从而创建对象的真实副本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lodashClonedeep = <span class="built_in">require</span>(<span class="string">&#x27;lodash.clonedeep&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">c</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> deepClone = <span class="title function_">lodashClonedeep</span>(obj);</span><br></pre></td></tr></table></figure>

<p>在这里，我们从 lodash 加载 <code>clonedeep</code> 函数，并使用它来深克隆对象。它是一个经过良好测试和维护的库，但只能与 Node.js 一起使用，不能与 Vanilla JavaScript 一起使用。</p>
<h4 id="15-如何实现浏览器内多个标签页之间的通信"><a href="#15-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="15.如何实现浏览器内多个标签页之间的通信?"></a>15.如何实现浏览器内多个标签页之间的通信?</h4><h5 id="第一种——调用localStorage"><a href="#第一种——调用localStorage" class="headerlink" title="第一种——调用localStorage"></a>第一种——调用localStorage</h5><p>在一个标签页里面使用 localStorage.setItem(key,value)添加（修改、删除）内容；<br>在另一个标签页里面监听 storage 事件(这个事件可以通过更新localstorage来触发，而且当前在同一个浏览器下打开的所有同源页面都可以监听得到！)。<br>即可得到 localstorge 存储的值，实现不同标签页之间的通信。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存入</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;storage&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;    </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">key</span> + <span class="string">&quot;=&quot;</span> + event.<span class="property">newValue</span>);    </span><br><span class="line">        &#125;);    </span><br></pre></td></tr></table></figure>

<h5 id="第二种——调用cookie-setInterval"><a href="#第二种——调用cookie-setInterval" class="headerlink" title="第二种——调用cookie+setInterval()"></a>第二种——调用cookie+setInterval()</h5><p>将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//存入</span><br><span class="line">document.cookie = `客户端B发送的消息:$&#123;num++&#125;`</span><br><span class="line">//监听</span><br><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">    //加入定时器，让函数每一秒就调用一次，实现页面刷新</span><br><span class="line">    console.log(&quot;cookie&quot;,document.cookie)</span><br><span class="line">  &#125;, 1000);</span><br></pre></td></tr></table></figure>

<h4 id="16-哪些操作会造成内存泄漏"><a href="#16-哪些操作会造成内存泄漏" class="headerlink" title="16.哪些操作会造成内存泄漏?"></a>16.哪些操作会造成内存泄漏?</h4><h5 id="一-内存溢出"><a href="#一-内存溢出" class="headerlink" title="(一)内存溢出"></a>(一)内存溢出</h5><p>一种程序运行时出现的错误,当程序运行需要的内存超过了剩余内存时,就抛出内存溢出错误</p>
<h5 id="二-内存泄露"><a href="#二-内存泄露" class="headerlink" title="(二)内存泄露"></a>(二)内存泄露</h5><p>占用的内存没有及时释放,内存泄露记录就会产生内存溢出</p>
<p>操作:</p>
<ul>
<li>意外的全局变量: 无法被回收</li>
<li>定时器: 未被正确关闭，导致所引用的外部变量无法被释放</li>
<li>闭包</li>
</ul>
<h4 id="17-谈谈垃圾回收机制方式及内存管理"><a href="#17-谈谈垃圾回收机制方式及内存管理" class="headerlink" title="17.谈谈垃圾回收机制方式及内存管理"></a>17.谈谈垃圾回收机制方式及内存管理</h4><p>JS是使用垃圾回收的语言.</p>
<h5 id="基本思路是"><a href="#基本思路是" class="headerlink" title="基本思路是:"></a>基本思路是:</h5><p>确定哪个变量不会在使用,然后释放它占用的内存。这个过程是周期的。</p>
<h5 id="垃圾回收策略为"><a href="#垃圾回收策略为" class="headerlink" title="垃圾回收策略为:"></a>垃圾回收策略为:</h5><p>当变量进入上下文,比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑上讲.水远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。</p>
<h5 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理:"></a>内存管理:</h5><p>在使用垃圾回收机制的编程环境中,开发者一般不用关系内存管理.不过js运行在浏览器上,而浏览器的内存通常比软件的小(避免运行大量的网页耗尽系统内存使操作系统崩溃).所以优化内存占用的最好办法是保证执行代码时只保存必要数据,如果数据不在需要就设置为null触发垃圾回收机制</p>
<h4 id="18-谈谈你对this对象的理解"><a href="#18-谈谈你对this对象的理解" class="headerlink" title="18. 谈谈你对this对象的理解"></a>18. 谈谈你对this对象的理解</h4><p>this 是执行上下文中的一个属性，它指向一个对象</p>
<ul>
<li>直接调用函数时，this指向window。</li>
<li>以方法的形式调用时，this指向包含调用方法的那个对象。</li>
<li>当以构造函数的形式调用时,this就是新创建的那个对象</li>
<li>使用call(),apply(),bind()调用时,this就是指向方法中的对象</li>
</ul>
<h4 id="19-JS-中什么是类-伪-数组-如何将类-伪-数组转化为数组"><a href="#19-JS-中什么是类-伪-数组-如何将类-伪-数组转化为数组" class="headerlink" title="19.JS 中什么是类(伪)数组?如何将类(伪)数组转化为数组"></a>19.JS 中什么是类(伪)数组?如何将类(伪)数组转化为数组</h4><h5 id="一-定义-2"><a href="#一-定义-2" class="headerlink" title="(一)定义"></a>(一)定义</h5><p>伪数组也是对象，伪数组一般具有以下特点：</p>
<ul>
<li>按索引方式存储数据；</li>
<li>具有length属性；</li>
<li>没有数组的push、shift、pop等方法;</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj=&#123;</span><br><span class="line">    <span class="string">&quot;0&quot;</span>:<span class="string">&quot;dai&quot;</span>,</span><br><span class="line">    <span class="string">&quot;1&quot;</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="attr">length</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二-转换"><a href="#二-转换" class="headerlink" title="(二)转换"></a>(二)转换</h5><h6 id="1-使用Array-prototype-slice-call"><a href="#1-使用Array-prototype-slice-call" class="headerlink" title="1.使用Array.prototype.slice.call()"></a>1.使用Array.prototype.slice.call()</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nodeList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//通过`Array`数组构造函数调用原型对象中的`slice()`方法，并通过`call()`方法改变其`slice()`方法的内部this指向，修改为`arguments`，即伪数组对象。通过这样的方法，我们就可以返回一个数组对象，这样就将伪数组转换为标准数组了</span></span><br><span class="line">               <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> arr = <span class="title function_">nodeList</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<h6 id="2-使用Array-from"><a href="#2-使用Array-from" class="headerlink" title="2.使用Array.from()"></a>2.使用Array.from()</h6><p>Array.from(object,mapFunction,thisValue);<br>参数说明：</p>
<ol>
<li><code>object</code>：必须，要转换为数组的对象。</li>
<li><code>mapFunction</code>：可选，数组中每个元素要调用的函数。</li>
<li><code>thisValue</code>：可选，映射函数（mapFunction）中的this对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nodeList</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> arr = <span class="title function_">nodeList</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<h4 id="20-什么是事件代理-事件委托"><a href="#20-什么是事件代理-事件委托" class="headerlink" title="20.什么是事件代理(事件委托) ?"></a>20.什么是事件代理(事件委托) ?</h4><h5 id="一-定义-3"><a href="#一-定义-3" class="headerlink" title="(一)定义"></a>(一)定义</h5><p>事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown……）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。</p>
<h5 id="二-事件传播分成三个阶段："><a href="#二-事件传播分成三个阶段：" class="headerlink" title="(二)事件传播分成三个阶段："></a>(二)事件传播分成三个阶段：</h5><p>捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件；</p>
<p>目标阶段：在目标节点上触发，称为“目标阶段”</p>
<p>冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；</p>
<h5 id="三-事件委托的优点"><a href="#三-事件委托的优点" class="headerlink" title="(三)事件委托的优点"></a>(三)事件委托的优点</h5><p>【1】可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件就非常棒</p>
<p>【2】可以实现当新增子对象时无需再次对其绑定（动态绑定事件）</p>
<h4 id="21-什么是强制-显式-类型转换-什么是隐式类型转换"><a href="#21-什么是强制-显式-类型转换-什么是隐式类型转换" class="headerlink" title="21.什么是强制(显式)类型转换?什么是隐式类型转换?"></a>21.什么是强制(显式)类型转换?什么是隐式类型转换?</h4><h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><p>会自动根据运算符进行类型转换。隐式类型转换的情况主要有以下几种</p>
<ul>
<li>如果表达式中同时存在字符串类型和数字类型的操作数，而使用加号+，会自动将数字转换成字符串。</li>
<li>如果表达式运算符为-、*、&#x2F;、%中的任意一个，此时 JavaScript 会自动将字符串转换成数字，对无法转换为数字的则转换为 NaN。</li>
<li>运算符为++或–时，JavaScript 会自动将字符串转换成数字，对无法转换为数字的则转换为 NaN。</li>
<li>运算符为&gt;或&lt;时，当两个操作数一个为字符串，一个为数字时，JavaScript 会自动将字符串转换成数字。</li>
<li>运算符为 &#x3D;&#x3D; ， 先转换类型再比较，&#x3D;&#x3D;&#x3D; 先判断类型，如果不是同一类型直接为false。</li>
<li>逻辑运算符(&amp;&amp;,||,!)自动转为布尔值(五大假值:0,NAN,空串,null,undefined)</li>
</ul>
<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>主要针对功能的需要或为了使代码变得清晰易读，人为地进行类型的转换。在 JavaScript 中，强制类型转换主要是通过调用全局函数 Number()、parseInt() 和 parseFloat() 来实现。</p>
<p><strong>注意null转为number为0,undefined转为number为NAN</strong></p>
<h4 id="22-谈一谈JS作用域链。"><a href="#22-谈一谈JS作用域链。" class="headerlink" title="22.谈一谈JS作用域链。"></a>22.谈一谈JS作用域链。</h4><h5 id="一-作用域"><a href="#一-作用域" class="headerlink" title="(一)作用域"></a>(一)作用域</h5><h6 id="1-分类"><a href="#1-分类" class="headerlink" title="1.分类"></a>1.分类</h6><ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域(es6才有let与const)</li>
</ul>
<h6 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h6><p>隔离变量,不同作用域下同名变量不会有冲突</p>
<h5 id="二-作用域链"><a href="#二-作用域链" class="headerlink" title="(二)作用域链"></a>(二)作用域链</h5><h6 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h6><p>函数能够形成作用域，如果函数被嵌套在另一个函数中，嵌套的函数也有自己的作用域，从这个函数的作用域往外形成的一条链， 这个链叫做作用域链。</p>
<h6 id="2-作用-1"><a href="#2-作用-1" class="headerlink" title="2.作用"></a>2.作用</h6><p>查找变量就是沿着作用域链查找,向上查找没有就报错</p>
<h4 id="23-如何理解JS原型链"><a href="#23-如何理解JS原型链" class="headerlink" title="23.如何理解JS原型链?"></a>23.如何理解JS原型链?</h4>

<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>License</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>READ NEXT</span></section><section class="body fs14"><a id="next" href="/2022/08/23/HTML%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">HTML个人总结<span class="note">Older</span></a><div class="line"></div><a id="prev" href="/2022/08/30/%E5%89%8D%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">前台项目总结<span class="note">Newer</span></a></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</p>
<p>This site was deployed by <a href="http://example.com/">@李阳滨</a> using <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0" title="v1.8.0">Stellar</a>.</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0';
  stellar.config = {
    date_suffix: {
      just: 'Just',
      min: 'minutes ago',
      hour: 'hours ago',
      day: 'days ago',
      month: 'months ago',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://fastly.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://fastly.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://fastly.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
