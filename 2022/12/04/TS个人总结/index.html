<!DOCTYPE html>
<html lang='en'>

<head>
  <meta name="generator" content="Hexo 6.2.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://fastly.jsdelivr.net'>
  <link rel="preconnect" href="https://fastly.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>TS个人总结 - 个人博客</title>

  
    <meta name="description" content="TS个人总结参考文件：TypeScript 入门教程 (xcatliu.com)与 typeScript_小满zs的博客-CSDN博客 个人感悟:感觉TS作用就是在JS的基础上对JS变量进行类型的限制,方便审查,不会有莫名其妙的变量或者属性(方法)产生.把握这一点感觉可以更加快速的入门TS 一.原始数据类型(一)布尔值在 TypeScript 中，使用 boolean 定义布尔值类型 1let i">
<meta property="og:type" content="article">
<meta property="og:title" content="TS个人总结">
<meta property="og:url" content="http://example.com/2022/12/04/TS%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="TS个人总结参考文件：TypeScript 入门教程 (xcatliu.com)与 typeScript_小满zs的博客-CSDN博客 个人感悟:感觉TS作用就是在JS的基础上对JS变量进行类型的限制,方便审查,不会有莫名其妙的变量或者属性(方法)产生.把握这一点感觉可以更加快速的入门TS 一.原始数据类型(一)布尔值在 TypeScript 中，使用 boolean 定义布尔值类型 1let i">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-12-04T10:26:16.000Z">
<meta property="article:modified_time" content="2022-12-04T10:26:51.367Z">
<meta property="article:author" content="李阳滨">
<meta property="article:tag" content="个人总结">
<meta name="twitter:card" content="summary">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="title" href="/"><div class="main">个人博客</div></a></div>
<nav class="menu dis-select"></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">TOC</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">一.原始数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-text">(一)布尔值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E6%95%B0%E5%80%BC"><span class="toc-text">(二)数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">(三)字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E7%A9%BA%E5%80%BC"><span class="toc-text">(四)空值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%EF%BC%89Null"><span class="toc-text">(五）Null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%EF%BC%89Undefined"><span class="toc-text">(六）Undefined</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E4%BB%BB%E6%84%8F%E5%80%BC"><span class="toc-text">二.任意值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-any"><span class="toc-text">(一)any</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-unknown"><span class="toc-text">(二)unknown</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">三.对象的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E6%8E%A5%E5%8F%A3"><span class="toc-text">(一)接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-text">1.可选属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7"><span class="toc-text">2.任意属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">3.只读属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-object%E3%80%81Object-%E4%BB%A5%E5%8F%8A"><span class="toc-text">(二)object、Object 以及{}</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-object"><span class="toc-text">1.object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Object"><span class="toc-text">2.Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3"><span class="toc-text">3.{}</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">四.数组的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E3%80%8C%E7%B1%BB%E5%9E%8B-%E6%96%B9%E6%8B%AC%E5%8F%B7%E3%80%8D%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">(一)「类型 + 方括号」表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E6%95%B0%E7%BB%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">(二)数组泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%A1%A8%E7%A4%BA%E6%95%B0%E7%BB%84"><span class="toc-text">(三)用接口表示数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">五.函数的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">(一)定义函数的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">1.函数表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-text">2.函数声明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-text">(二)可选参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-text">(三)参数默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-text">(四)剩余参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E9%87%8D%E8%BD%BD"><span class="toc-text">(五)重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA"><span class="toc-text">六.类型推论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">七.联合类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-text">八.类型断言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E8%AF%AD%E6%B3%95"><span class="toc-text">(一)语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-text">(二)类型断言的用途</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B0%86%E4%B8%80%E4%B8%AA%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%B8%BA%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.将一个联合类型断言为其中一个类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B0%86%E4%B8%80%E4%B8%AA%E7%88%B6%E7%B1%BB%E6%96%AD%E8%A8%80%E4%B8%BA%E6%9B%B4%E5%8A%A0%E5%85%B7%E4%BD%93%E7%9A%84%E5%AD%90%E7%B1%BB"><span class="toc-text">2.将一个父类断言为更加具体的子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B0%86%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%B8%BA-any"><span class="toc-text">3.将任何一个类型断言为 any</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B0%86-any-%E6%96%AD%E8%A8%80%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%85%B7%E4%BD%93%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.将 any 断言为一个具体的类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">(三)类型断言的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E5%8F%8C%E9%87%8D%E6%96%AD%E8%A8%80"><span class="toc-text">(四)双重断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80-vs-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">(五)类型断言 vs 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80-vs-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text">(六)类型断言 vs 类型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80-vs-%E6%B3%9B%E5%9E%8B"><span class="toc-text">(六)类型断言 vs 泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-text">九.声明文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-npm-%E5%8C%85"><span class="toc-text">(一)npm 包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-export"><span class="toc-text">1.export</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B7%B7%E7%94%A8-declare-%E5%92%8C-export"><span class="toc-text">2.混用 declare 和 export</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-export-namespace"><span class="toc-text">3.export namespace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-export-default"><span class="toc-text">4.export default</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-export"><span class="toc-text">5.export &#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-UMD-%E5%BA%93"><span class="toc-text">(二)UMD 库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-export-as-namespace"><span class="toc-text">1.export as namespace</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E7%9B%B4%E6%8E%A5%E6%89%A9%E5%B1%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">(三)直接扩展全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E5%9C%A8-npm-%E5%8C%85%E6%88%96-UMD-%E5%BA%93%E4%B8%AD%E6%89%A9%E5%B1%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">(四)在 npm 包或 UMD 库中扩展全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-declare-global"><span class="toc-text">1.declare global</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E6%A8%A1%E5%9D%97%E6%8F%92%E4%BB%B6"><span class="toc-text">(五)模块插件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-declare-module"><span class="toc-text">1.declare module</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="toc-text">(六)声明文件中的依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%89%E6%96%9C%E7%BA%BF%E6%8C%87%E4%BB%A4"><span class="toc-text">1.三斜线指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B9%A6%E5%86%99%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-text">2.书写一个全局变量的声明文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BE%9D%E8%B5%96%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-text">3.依赖一个全局变量的声明文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8B%86%E5%88%86%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-text">4.拆分声明文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%85%B6%E4%BB%96%E4%B8%89%E6%96%9C%E7%BA%BF%E6%8C%87%E4%BB%A4"><span class="toc-text">5.其他三斜线指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-text">十.内置对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-ECMAScript-%E7%9A%84%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-text">(一)ECMAScript 的内置对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-DOM-%E5%92%8C-BOM-%E7%9A%84%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-text">(二)DOM 和 BOM 的内置对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-TypeScript-%E6%A0%B8%E5%BF%83%E5%BA%93%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6"><span class="toc-text">(三)TypeScript 核心库的定义文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E7%94%A8-TypeScript-%E5%86%99-Node-js"><span class="toc-text">(四)用 TypeScript 写 Node.js</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-text">十一.类型别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">十二.字符串字面量类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-%E5%85%83%E7%BB%84"><span class="toc-text">十三.元组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">简单的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%8A%E7%95%8C%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">越界的元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B-%E6%9E%9A%E4%B8%BE"><span class="toc-text">十四.枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">(一)简单的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E6%89%8B%E5%8A%A8%E8%B5%8B%E5%80%BC"><span class="toc-text">(二)手动赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E5%B8%B8%E6%95%B0%E9%A1%B9%E5%92%8C%E8%AE%A1%E7%AE%97%E6%89%80%E5%BE%97%E9%A1%B9"><span class="toc-text">(三)常数项和计算所得项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E5%B8%B8%E6%95%B0%E6%9E%9A%E4%B8%BE"><span class="toc-text">(四)常数枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E5%A4%96%E9%83%A8%E6%9E%9A%E4%B8%BE"><span class="toc-text">(五)外部枚举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94-%E7%B1%BB"><span class="toc-text">十五.类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#readonly"><span class="toc-text">readonly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">类的类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AD-%E6%B3%9B%E5%9E%8B"><span class="toc-text">十六.泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E6%A1%88%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">(一)案例说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E5%A4%9A%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-text">(二)多类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-text">(三)泛型约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">(四)泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94-%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%9E%8B"><span class="toc-text">(五)泛型参数的默认类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%83-tsconfig-json%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">十七.tsconfig.json配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84"><span class="toc-text">介绍几个常用的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%9A%84"><span class="toc-text">详细的</span></a></li></ol></li></ol></li></ol></div></div></div>


</div>


    </aside>
    <div class='l_main'>
      

      

<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a><span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a></div><div id="post-meta">Posted on&nbsp;<time datetime="2022-12-04T10:26:16.000Z">2022-12-04</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>TS个人总结</span></h1>
<h1 id="TS个人总结"><a href="#TS个人总结" class="headerlink" title="TS个人总结"></a>TS个人总结</h1><p>参考文件：<a target="_blank" rel="noopener" href="https://ts.xcatliu.com/">TypeScript 入门教程 (xcatliu.com)</a>与<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq1195566313/category_11559497.html?spm=1001.2014.3001.5482"> typeScript_小满zs的博客-CSDN博客</a></p>
<p>个人感悟:感觉TS作用就是在JS的基础上对JS变量进行类型的限制,方便审查,不会有莫名其妙的变量或者属性(方法)产生.把握这一点感觉可以更加快速的入门TS</p>
<h2 id="一-原始数据类型"><a href="#一-原始数据类型" class="headerlink" title="一.原始数据类型"></a>一.原始数据类型</h2><h3 id="一-布尔值"><a href="#一-布尔值" class="headerlink" title="(一)布尔值"></a>(一)布尔值</h3><p>在 TypeScript 中，使用 boolean 定义布尔值类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let isDone: boolean = false;</span><br></pre></td></tr></table></figure>

<p>使用构造函数Boolean 创造的对象不是布尔值</p>
<h3 id="二-数值"><a href="#二-数值" class="headerlink" title="(二)数值"></a>(二)数值</h3><p>使用 number 定义数值类型：</p>
<p>let decLiteral: number &#x3D; 6; </p>
<p>ES6 中的二进制和八进制表示法，它们会被编译为十进制数字</p>
<h3 id="三-字符串"><a href="#三-字符串" class="headerlink" title="(三)字符串"></a>(三)字符串</h3><p>使用 string 定义字符串类型：</p>
<p>let myName: string &#x3D; ‘Tom’;</p>
<h3 id="四-空值"><a href="#四-空值" class="headerlink" title="(四)空值"></a>(四)空值</h3><p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用void表示没有任何返回值的函数：</p>
<p>function alertName(): void {</p>
<pre><code>alert(&#39;My name is Tom&#39;);
</code></pre>
<p>}声明一个 void类型的变量没有什么用，因为你只能将它赋值为undefined和null只在 strictNullChecks 未指定时）</p>
<h3 id="五）Null"><a href="#五）Null" class="headerlink" title="(五）Null"></a>(五）Null</h3><h3 id="六）Undefined"><a href="#六）Undefined" class="headerlink" title="(六）Undefined"></a>(六）Undefined</h3><p>在 TypeScript 中，可以使用 null和undefined来定义这两个原始数据类型：</p>
<p>let u: undefined &#x3D; undefined;</p>
<p>let n: null &#x3D; null;</p>
<p>与void的区别是:</p>
<p>undefined和null是所有类型的子类型。</p>
<p>也就是说undefined,null类型的变量，可以赋值给number类型的变量：</p>
<p>而void类型的变量不能赋值给number类型的变量：</p>
<h2 id="二-任意值"><a href="#二-任意值" class="headerlink" title="二.任意值"></a>二.任意值</h2><h3 id="一-any"><a href="#一-any" class="headerlink" title="(一)any"></a>(一)any</h3><p>任意值（Any）用来表示允许赋值为任意类型;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: any = &#x27;seven&#x27;;</span><br><span class="line"></span><br><span class="line">myFavoriteNumber = 7;</span><br></pre></td></tr></table></figure>

<p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</p>
<h3 id="二-unknown"><a href="#二-unknown" class="headerlink" title="(二)unknown"></a>(二)unknown</h3><p>TypeScript 3.0中引入的 unknown 类型,也允许赋值为任意类型</p>
<p>不同点:unknow类型比any更加严格</p>
<ul>
<li>any可以赋值给其他任何类型,而unknown类型不能赋值给其他类型,其赋值对象只有unknown 和 any</li>
<li>any类型在对象没有这个属性的时候还在获取是不会报错的,而unknow 是不能调用对象的属性和方法</li>
</ul>
<h2 id="三-对象的类型"><a href="#三-对象的类型" class="headerlink" title="三.对象的类型"></a>三.对象的类型</h2><h3 id="一-接口"><a href="#一-接口" class="headerlink" title="(一)接口"></a>(一)接口</h3><p>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br><span class="line">//如果存在两个Person的话,两个接口中的属性会合并到一个接口中(简称声明合并)</span><br></pre></td></tr></table></figure>

<p>赋值的时候，变量的类型，数量必须和接口的类型，数量保持一致</p>
<h4 id="1-可选属性"><a href="#1-可选属性" class="headerlink" title="1.可选属性"></a>1.可选属性</h4><p>有时我们希望一个变量可存在可不存在，那么可以用可选属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-任意属性"><a href="#2-任意属性" class="headerlink" title="2.任意属性"></a>2.任意属性</h4><p>有时候我们希望一个接口允许有任意的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any; </span><br><span class="line">&#125;</span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[propName: string]定义了任意属性取 string类型的值。</p>
<p>需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: string;</span><br><span class="line">&#125;</span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">//报错,[propName: string]定义去string类型的值,但是age为number,所以报错.</span><br><span class="line">//解决方法:    [propName: string]: string | number;</span><br></pre></td></tr></table></figure>

<h4 id="3-只读属性"><a href="#3-只读属性" class="headerlink" title="3.只读属性"></a>3.只读属性</h4><p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly定义只读属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    id: 89757,</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：所以初始化tom时就要给id赋值,后面在赋值就会报两个错误:</p>
<p>第一处是在对tom进行赋值的时候，没有给 id赋值。</p>
<p>第二处是在给tom.id赋值的时候，由于它是只读属性，所以报错了。</p>
<h3 id="二-object、Object-以及"><a href="#二-object、Object-以及" class="headerlink" title="(二)object、Object 以及{}"></a>(二)<code>object</code>、<code>Object</code> 以及<code>&#123;&#125;</code></h3><h4 id="1-object"><a href="#1-object" class="headerlink" title="1.object"></a>1.object</h4><p>ts2.2新规定的声明对象的方式,只可以声明引用类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let o:object = &#123;&#125;//正确</span><br><span class="line">let o1:object = []//正确</span><br><span class="line">let o2:object = ()=&gt;123 //正确</span><br><span class="line">let b:object = &#x27;123&#x27; //错误</span><br><span class="line">let c:object = 123 //错误</span><br></pre></td></tr></table></figure>

<h4 id="2-Object"><a href="#2-Object" class="headerlink" title="2.Object"></a>2.Object</h4><p>声明所有对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let o:object = &#123;&#125;//正确</span><br><span class="line">let o1:object = []//正确</span><br><span class="line">let o2:object = ()=&gt;123 //正确</span><br><span class="line">let b:object = &#x27;123&#x27; //正确</span><br><span class="line">let c:object = 123 //正确</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3"><a href="#3" class="headerlink" title="3.{}"></a>3.{}</h4><p>与Object一致,但是使用{},声明后无法对变量进行改变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a:&#123;&#125; = &#123;name:1&#125;</span><br><span class="line">a.age = 18 //错误</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="四-数组的类型"><a href="#四-数组的类型" class="headerlink" title="四.数组的类型"></a>四.数组的类型</h2><h3 id="一-「类型-方括号」表示法"><a href="#一-「类型-方括号」表示法" class="headerlink" title="(一)「类型 + 方括号」表示法"></a>(一)「类型 + 方括号」表示法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr: number[] = [1, 1, 2, 3, 5];</span><br><span class="line">//数组的项中不允许出现其他的类型：</span><br><span class="line"></span><br><span class="line">//多维数组</span><br><span class="line">let data:number[][] = [[1,2], [3,4]];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二-数组泛型"><a href="#二-数组泛型" class="headerlink" title="(二)数组泛型"></a>(二)数组泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr: Array&lt;number&gt; = [1, 1, 2, 3, 5];</span><br><span class="line">//多维数组</span><br><span class="line">let arr: Array&lt;Array&lt;number | string&gt;&gt; = [[1,2], [3,4]];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三-用接口表示数组"><a href="#三-用接口表示数组" class="headerlink" title="(三)用接口表示数组"></a>(三)用接口表示数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface NumberArray &#123;</span><br><span class="line"></span><br><span class="line">	[index: number]: number;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let fibonacci: NumberArray = [1, 1, 2, 3, 5];</span><br><span class="line"></span><br><span class="line">//NumberArray 表示：只要索引的类型是数字时，那么值的类型必须是数字。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="五-函数的类型"><a href="#五-函数的类型" class="headerlink" title="五.函数的类型"></a>五.函数的类型</h2><h3 id="一-定义函数的方式"><a href="#一-定义函数的方式" class="headerlink" title="(一)定义函数的方式"></a>(一)定义函数的方式</h3><h4 id="1-函数表达式"><a href="#1-函数表达式" class="headerlink" title="1.函数表达式"></a>1.函数表达式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 函数表达式（Function Expression）</span><br><span class="line">let mySum = function (x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//ts写法</span><br><span class="line">let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br><span class="line">//不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。</span><br><span class="line">//在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-函数声明"><a href="#2-函数声明" class="headerlink" title="2.函数声明"></a>2.函数声明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明（Function Declaration）</span><br><span class="line">function sum(x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ts写法</span><br><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输入多余的（或者少于要求的）参数，是不被允许的</strong>：</p>
<h3 id="二-可选参数"><a href="#二-可选参数" class="headerlink" title="(二)可选参数"></a>(二)可选参数</h3><p>前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？</p>
<p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sum(x: number, y？: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">//注意：可选参数后面不允许再出现必需参数了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三-参数默认值"><a href="#三-参数默认值" class="headerlink" title="(三)参数默认值"></a>(三)参数默认值</h3><p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string = &#x27;Tom&#x27;, lastName: string) &#123;</span><br><span class="line">    return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">&#125;</span><br><span class="line">//此时就不受「可选参数必须接在必需参数后面」的限制了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="四-剩余参数"><a href="#四-剩余参数" class="headerlink" title="(四)剩余参数"></a>(四)剩余参数</h3><p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function push(array, ...items) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//事实上，items 是一个数组。所以我们可以用数组的类型来定义</span><br><span class="line">function push(array: any[], ...items: any[]) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="五-重载"><a href="#五-重载" class="headerlink" title="(五)重载"></a>(五)重载</h3><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function reverse(x: number | string): number | string | void &#123;</span><br><span class="line">    if (typeof x === &#x27;number&#x27;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));</span><br><span class="line">    &#125; else if (typeof x === &#x27;string&#x27;) &#123;</span><br><span class="line">        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//然而这样不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。应该如下写,前二者是规则,后者是输出</span><br><span class="line">function reverse(x: number): number;</span><br><span class="line">function reverse(x: string): string;</span><br><span class="line">function reverse(x: number | string): number | string | void &#123;</span><br><span class="line">    if (typeof x === &#x27;number&#x27;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));</span><br><span class="line">    &#125; else if (typeof x === &#x27;string&#x27;) &#123;</span><br><span class="line">        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="六-类型推论"><a href="#六-类型推论" class="headerlink" title="六.类型推论"></a>六.类型推论</h2><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p>
<p>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成any类型而完全不被类型检查：</p>
<h2 id="七-联合类型"><a href="#七-联合类型" class="headerlink" title="七.联合类型"></a>七.联合类型</h2><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>联合类型使用  “ | “  分隔每个类型。</p>
<h2 id="八-类型断言"><a href="#八-类型断言" class="headerlink" title="八.类型断言"></a>八.类型断言</h2><p>类型断言（Type Assertion）可以用来手动指定一个值的类型。</p>
<h3 id="一-语法"><a href="#一-语法" class="headerlink" title="(一)语法"></a>(一)语法</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">值 <span class="keyword">as</span> 类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt;值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 tsx 语法（React 的 jsx 语法的 ts 版）中必须使用前者，即 <code>值 as 类型</code>。</p>
<p>形如 <code>&lt;Foo&gt;</code> 的语法在 tsx 中表示的是一个 <code>ReactNode</code>，在 ts 中除了表示类型断言之外，也可能是表示一个<a target="_blank" rel="noopener" href="http://ts.xcatliu.com/advanced/generics.html">泛型</a>。</p>
<p>故建议大家在使用类型断言时，统一使用 <code>值 as 类型</code> 这样的语法.</p>
<h3 id="二-类型断言的用途"><a href="#二-类型断言的用途" class="headerlink" title="(二)类型断言的用途"></a>(二)类型断言的用途</h3><h4 id="1-将一个联合类型断言为其中一个类型"><a href="#1-将一个联合类型断言为其中一个类型" class="headerlink" title="1.将一个联合类型断言为其中一个类型"></a>1.将一个联合类型断言为其中一个类型</h4><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型中共有的属性或方法</strong>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">swim</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params">animal: Cat | Fish</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">swim</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">animal: Cat | Fish</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> animal.<span class="property">swim</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts:11:23 - error TS2339: Property &#x27;swim&#x27; does not exist on type &#x27;Cat | Fish&#x27;.</span></span><br><span class="line"><span class="comment">//   Property &#x27;swim&#x27; does not exist on type &#x27;Cat&#x27;.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中，获取 <code>animal.swim</code> 的时候会报错。</p>
<p>此时可以使用类型断言，将 <code>animal</code> 断言成 <code>Fish</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">swim</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">animal: Cat | Fish</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (animal <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就可以解决访问 <code>animal.swim</code> 时报错的问题了。</p>
<p>需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">swim</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swim</span>(<span class="params">animal: Cat | Fish</span>) &#123;</span><br><span class="line">    (animal <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="title function_">swim</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tom</span>: <span class="title class_">Cat</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="title function_">run</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;run&#x27;</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">swim</span>(tom);</span><br><span class="line"><span class="comment">// Uncaught TypeError: animal.swim is not a function`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子编译时不会报错，但在运行时会报错：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: animal.swim is <span class="literal">not</span> a function`</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原因是 <code>(animal as Fish).swim()</code> 这段代码隐藏了 <code>animal</code> 可能为 <code>Cat</code> 的情况，将 <code>animal</code> 直接断言为 <code>Fish</code> 了，而 TypeScript 编译器信任了我们的断言，故在调用 <code>swim()</code> 时没有编译错误。</p>
<p>可是 <code>swim</code> 函数接受的参数是 <code>Cat | Fish</code>，一旦传入的参数是 <code>Cat</code> 类型的变量，由于 <code>Cat</code> 上没有 <code>swim</code> 方法，就会导致运行时错误了。</p>
<p>总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。</p>
<h4 id="2-将一个父类断言为更加具体的子类"><a href="#2-将一个父类断言为更加具体的子类" class="headerlink" title="2.将一个父类断言为更加具体的子类"></a>2.将一个父类断言为更加具体的子类</h4><p>当类之间有继承关系时，类型断言也是很常见的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApiError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    <span class="attr">statusCode</span>: <span class="built_in">number</span> = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isApiError</span>(<span class="params">error: <span class="built_in">Error</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (error <span class="keyword">as</span> <span class="title class_">ApiError</span>).<span class="property">code</span> === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们声明了函数 <code>isApiError</code>，它用来判断传入的参数是不是 <code>ApiError</code> 类型，为了实现这样一个函数，它的参数的类型肯定得是比较抽象的父类 <code>Error</code>，这样的话这个函数就能接受 <code>Error</code> 或它的子类作为参数了。</p>
<p>但是由于父类 <code>Error</code> 中没有 <code>code</code> 属性，故直接获取 <code>error.code</code> 会报错，需要使用类型断言获取 <code>(error as ApiError).code</code>。</p>
<h4 id="3-将任何一个类型断言为-any"><a href="#3-将任何一个类型断言为-any" class="headerlink" title="3.将任何一个类型断言为 any"></a>3.将任何一个类型断言为 <code>any</code></h4><p>理想情况下，TypeScript 的类型系统运转良好，每个值的类型都具体而精确。</p>
<p>当我们引用一个在此类型上不存在的属性或方法时，就会报错：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">foo</span>: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">foo.<span class="property">length</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts:2:5 - error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中，数字类型的变量 <code>foo</code> 上是没有 <code>length</code> 属性的，故 TypeScript 给出了相应的错误提示。</p>
<p>这种错误提示显然是非常有用的。</p>
<p>但有的时候，我们非常确定这段代码不会出错，比如下面这个例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">foo</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts:1:8 - error TS2339: Property &#x27;foo&#x27; does not exist on type &#x27;Window &amp; typeof globalThis&#x27;.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们需要将 <code>window</code> 上添加一个属性 <code>foo</code>，但 TypeScript 编译时会报错，提示我们 <code>window</code> 上不存在 <code>foo</code> 属性。</p>
<p>此时我们可以使用 <code>as any</code> 临时将 <code>window</code> 断言为 <code>any</code> 类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">foo</span> = <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 <code>any</code> 类型的变量上，访问任何属性都是允许的。</p>
<p>需要注意的是，将一个变量断言为 <code>any</code> 可以说是解决 TypeScript 中类型问题的最后一个手段。</p>
<p><strong>它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 <code>as any</code>。</strong></p>
<p>上面的例子中，我们也可以通过扩展 window 的类型解决这个错误，不过如果只是临时的增加 <code>foo</code> 属性，<code>as any</code> 会更加方便。</p>
<p>总之，<strong>一方面不能滥用 <code>as any</code>，另一方面也不要完全否定它的作用，我们需要在类型的严格性和开发的便利性之间掌握平衡</strong>（这也是 [TypeScript 的设计理念]之一），才能发挥出 TypeScript 最大的价值。</p>
<h4 id="4-将-any-断言为一个具体的类型"><a href="#4-将-any-断言为一个具体的类型" class="headerlink" title="4.将 any 断言为一个具体的类型"></a>4.将 <code>any</code> 断言为一个具体的类型</h4><p>在日常的开发中，我们不可避免的需要处理 <code>any</code> 类型的变量，它们可能是由于第三方库未能定义好自己的类型，也有可能是历史遗留的或其他人编写的烂代码，还可能是受到 TypeScript 类型系统的限制而无法精确定义类型的场景。</p>
<p>遇到 <code>any</code> 类型的变量时，我们可以选择无视它，任由它滋生更多的 <code>any</code>。</p>
<p>我们也可以选择改进它，通过类型断言及时的把 <code>any</code> 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。</p>
<h3 id="三-类型断言的限制"><a href="#三-类型断言的限制" class="headerlink" title="(三)类型断言的限制"></a>(三)类型断言的限制</h3><p>并不是任何一个类型都可以被断言为任何另一个类型。</p>
<p>具体来说，若 <code>A</code> 兼容 <code>B</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>
<p>下面我们通过一个简化的例子，来理解类型断言的限制：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Cat</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">run</span>: <span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;run&#x27;</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">animal</span>: <span class="title class_">Animal</span> = tom;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们知道，TypeScript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系。</p>
<p>在上面的例子中，<code>Cat</code> 包含了 <code>Animal</code> 中的所有属性，除此之外，它还有一个额外的方法 <code>run</code>。TypeScript 并不关心 <code>Cat</code> 和 <code>Animal</code> 之间定义时是什么关系，而只会看它们最终的结构有什么关系——所以它与 <code>Cat extends Animal</code> 是等价的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么也不难理解为什么 <code>Cat</code> 类型的 <code>tom</code> 可以赋值给 <code>Animal</code> 类型的 <code>animal</code> 了——就像面向对象编程中我们可以将子类的实例赋值给类型为父类的变量。</p>
<p>我们把它换成 TypeScript 中更专业的说法，即：<code>Animal</code> 兼容 <code>Cat</code>。</p>
<p>当 <code>Animal</code> 兼容 <code>Cat</code> 时，它们就可以互相进行类型断言了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testAnimal</span>(<span class="params">animal: Animal</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (animal <span class="keyword">as</span> <span class="title class_">Cat</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testCat</span>(<span class="params">cat: Cat</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (cat <span class="keyword">as</span> <span class="title class_">Animal</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样的设计其实也很容易就能理解：</p>
<ul>
<li>允许 <code>animal as Cat</code> 是因为「父类可以被断言为子类」，这个前面已经学习过了</li>
<li>允许 <code>cat as Animal</code> 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有任何问题，故「子类可以被断言为父类」</li>
</ul>
<p>需要注意的是，这里我们使用了简化的父类子类的关系来表达类型的兼容性，而实际上 TypeScript 在判断类型的兼容性时，比这种情况复杂很多，详细请参考[类型的兼容性（TODO)][]章节。</p>
<p>总之，若 <code>A</code> 兼容 <code>B</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>
<p>同理，若 <code>B</code> 兼容 <code>A</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>
<p>所以这也可以换一种说法：</p>
<p>要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可，这也是为了在类型断言时的安全考虑，毕竟毫无根据的断言是非常危险的。</p>
<p>综上所述：</p>
<ul>
<li>联合类型可以被断言为其中一个类型</li>
<li>父类可以被断言为子类</li>
<li>任何类型都可以被断言为 any</li>
<li>any 可以被断言为任何类型</li>
<li>要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可</li>
</ul>
<p>其实前四种情况都是最后一个的特例。</p>
<h3 id="四-双重断言"><a href="#四-双重断言" class="headerlink" title="(四)双重断言"></a>(四)双重断言</h3><p>既然：</p>
<ul>
<li>任何类型都可以被断言为 any</li>
<li>any 可以被断言为任何类型</li>
</ul>
<p>那么我们是不是可以使用双重断言 <code>as any as Foo</code> 来将任何一个类型断言为任何另一个类型呢？</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="title function_">swim</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testCat</span>(<span class="params">cat: Cat</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (cat <span class="keyword">as</span> <span class="built_in">any</span> <span class="keyword">as</span> <span class="title class_">Fish</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，若直接使用 <code>cat as Fish</code> 肯定会报错，因为 <code>Cat</code> 和 <code>Fish</code> 互相都不兼容。</p>
<p>但是若使用双重断言，则可以打破「要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可」的限制，将任何一个类型断言为任何另一个类型。</p>
<p>若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。</p>
<p><strong>除非迫不得已，千万别用双重断言。</strong></p>
<h3 id="五-类型断言-vs-类型转换"><a href="#五-类型断言-vs-类型转换" class="headerlink" title="(五)类型断言 vs 类型转换"></a>(五)类型断言 vs 类型转换</h3><p>类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toBoolean</span>(<span class="params">something: <span class="built_in">any</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> something <span class="keyword">as</span> <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">toBoolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回值为 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，将 <code>something</code> 断言为 <code>boolean</code> 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toBoolean</span>(<span class="params">something</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">toBoolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回值为 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以类型断言不是类型转换，它不会真的影响到变量的类型。</p>
<p>若要进行类型转换，需要直接调用类型转换的方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toBoolean</span>(<span class="params">something: <span class="built_in">any</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Boolean</span>(something);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">toBoolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回值为 true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="六-类型断言-vs-类型声明"><a href="#六-类型断言-vs-类型声明" class="headerlink" title="(六)类型断言 vs 类型声明"></a>(六)类型断言 vs 类型声明</h3><p>在这个例子中：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCacheData</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">cache</span>[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = <span class="title function_">getCacheData</span>(<span class="string">&#x27;tom&#x27;</span>) <span class="keyword">as</span> <span class="title class_">Cat</span>;</span><br><span class="line">tom.<span class="title function_">run</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们使用 <code>as Cat</code> 将 <code>any</code> 类型断言为了 <code>Cat</code> 类型。</p>
<p>但实际上还有其他方式可以解决这个问题：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCacheData</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">cache</span>[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tom</span>: <span class="title class_">Cat</span> = <span class="title function_">getCacheData</span>(<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line">tom.<span class="title function_">run</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们通过类型声明的方式，将 <code>tom</code> 声明为 <code>Cat</code>，然后再将 <code>any</code> 类型的 <code>getCacheData(&#39;tom&#39;)</code> 赋值给 <code>Cat</code> 类型的 <code>tom</code>。</p>
<p>这和类型断言是非常相似的，而且产生的结果也几乎是一样的——<code>tom</code> 在接下来的代码中都变成了 <code>Cat</code> 类型。</p>
<p>它们的区别，可以通过这个例子来理解：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">animal</span>: <span class="title class_">Animal</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> tom = animal <span class="keyword">as</span> <span class="title class_">Cat</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，由于 <code>Animal</code> 兼容 <code>Cat</code>，故可以将 <code>animal</code> 断言为 <code>Cat</code> 赋值给 <code>tom</code>。</p>
<p>但是若直接声明 <code>tom</code> 为 <code>Cat</code> 类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">animal</span>: <span class="title class_">Animal</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Cat</span> = animal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts:12:5 - error TS2741: Property &#x27;run&#x27; is missing in type &#x27;Animal&#x27; but required in type &#x27;Cat&#x27;.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>则会报错，不允许将 <code>animal</code> 赋值为 <code>Cat</code> 类型的 <code>tom</code>。</p>
<p>这很容易理解，<code>Animal</code> 可以看作是 <code>Cat</code> 的父类，当然不能将父类的实例赋值给类型为子类的变量。</p>
<p>深入的讲，它们的核心区别就在于：</p>
<ul>
<li><code>animal</code> 断言为 <code>Cat</code>，只需要满足 <code>Animal</code> 兼容 <code>Cat</code> 或 <code>Cat</code> 兼容 <code>Animal</code> 即可</li>
<li><code>animal</code> 赋值给 <code>tom</code>，需要满足 <code>Cat</code> 兼容 <code>Animal</code> 才行</li>
</ul>
<p>但是 <code>Cat</code> 并不兼容 <code>Animal</code>。</p>
<p>而在前一个例子中，由于 <code>getCacheData(&#39;tom&#39;)</code> 是 <code>any</code> 类型，<code>any</code> 兼容 <code>Cat</code>，<code>Cat</code> 也兼容 <code>any</code>，故</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tom = <span class="title function_">getCacheData</span>(<span class="string">&#x27;tom&#x27;</span>) <span class="keyword">as</span> <span class="title class_">Cat</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">tom</span>: <span class="title class_">Cat</span> = <span class="title function_">getCacheData</span>(<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>知道了它们的核心区别，就知道了类型声明是比类型断言更加严格的。</p>
<p>所以为了增加代码的质量，我们最好优先使用类型声明，这也比类型断言的 <code>as</code> 语法更加优雅。</p>
<h3 id="六-类型断言-vs-泛型"><a href="#六-类型断言-vs-泛型" class="headerlink" title="(六)类型断言 vs 泛型"></a>(六)类型断言 vs 泛型</h3><blockquote>
<p>本小节的前置知识点：<a target="_blank" rel="noopener" href="http://ts.xcatliu.com/advanced/generics.html">泛型</a></p>
</blockquote>
<p>还是这个例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCacheData</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">cache</span>[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = <span class="title function_">getCacheData</span>(<span class="string">&#x27;tom&#x27;</span>) <span class="keyword">as</span> <span class="title class_">Cat</span>;</span><br><span class="line">tom.<span class="title function_">run</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们还有第三种方式可以解决这个问题，那就是泛型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getCacheData&lt;T&gt;(<span class="attr">key</span>: <span class="built_in">string</span>): T &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">cache</span>[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = getCacheData&lt;<span class="title class_">Cat</span>&gt;(<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line">tom.<span class="title function_">run</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过给 <code>getCacheData</code> 函数添加了一个泛型 <code>&lt;T&gt;</code>，我们可以更加规范的实现对 <code>getCacheData</code> 返回值的约束，这也同时去除掉了代码中的 <code>any</code>，是最优的一个解决方案。</p>
<h2 id="九-声明文件"><a href="#九-声明文件" class="headerlink" title="九.声明文件"></a>九.声明文件</h2><h3 id="一-npm-包"><a href="#一-npm-包" class="headerlink" title="(一)npm 包"></a>(一)npm 包</h3><p>一般我们通过 <code>import foo from &#39;foo&#39;</code> 导入一个 npm 包，这是符合 ES6 模块规范的。</p>
<p>在我们尝试给一个 npm 包创建声明文件之前，需要先看看它的声明文件是否已经存在。一般来说，npm 包的声明文件可能存在于两个地方：</p>
<ol>
<li>与该 npm 包绑定在一起。判断依据是 <code>package.json</code> 中有 <code>types</code> 字段，或者有一个 <code>index.d.ts</code> 声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建 npm 包的时候，最好也将声明文件与 npm 包绑定在一起。</li>
<li>发布到 <code>@types</code> 里。我们只需要尝试安装一下对应的 <code>@types</code> 包就知道是否存在该声明文件，安装命令是 <code>npm install @types/foo --save-dev</code>。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 <code>@types</code> 里了。</li>
</ol>
<p>假如以上两种方式都没有找到对应的声明文件，那么我们就需要自己为它写声明文件了。由于是通过 <code>import</code> 语句导入的模块，所以声明文件存放的位置也有所约束，一般有两种方案：</p>
<ol>
<li>创建一个 <code>node_modules/@types/foo/index.d.ts</code> 文件，存放 <code>foo</code> 模块的声明文件。这种方式不需要额外的配置，但是 <code>node_modules</code> 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。</li>
<li>创建一个 <code>types</code> 目录，专门用来管理自己写的声明文件，将 <code>foo</code> 的声明文件放到 <code>types/foo/index.d.ts</code> 中。这种方式需要配置下 <code>tsconfig.json</code> 中的 <code>paths</code> 和 <code>baseUrl</code> 字段。</li>
</ol>
<p>目录结构：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/path/<span class="keyword">to</span>/project</span><br><span class="line">├── src</span><br><span class="line">|  └── index.ts</span><br><span class="line">├── types</span><br><span class="line">|  └── foo</span><br><span class="line">|     └── index.d.ts</span><br><span class="line">└── tsconfig.json</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tsconfig.json</code> 内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;types/*&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如此配置之后，通过 <code>import</code> 导入 <code>foo</code> 的时候，也会去 <code>types</code> 目录下寻找对应的模块的声明文件了。</p>
<p>注意 <code>module</code> 配置可以有很多种选项，不同的选项会影响模块的导入导出模式。这里我们使用了 <code>commonjs</code> 这个最常用的选项，后面的教程也都默认使用的这个选项。</p>
<p>npm 包的声明文件主要有以下几种语法：</p>
<ul>
<li>[<code>export</code>]导出变量</li>
<li>[<code>export namespace</code>]导出（含有子属性的）对象</li>
<li>[<code>export default</code>]ES6 默认导出</li>
<li>[<code>export =</code>]commonjs 导出模块</li>
</ul>
<h4 id="1-export"><a href="#1-export" class="headerlink" title="1.export"></a>1.<code>export</code></h4><p>npm 包的声明文件与全局变量的声明文件有很大区别。在 npm 包的声明文件中，使用 <code>declare</code> 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 <code>export</code> 导出，然后在使用方 <code>import</code> 导入后，才会应用到这些类型声明。</p>
<p><code>export</code> 的语法与普通的 ts 中的语法类似，区别仅在于声明文件中禁止定义具体的实现<a target="_blank" rel="noopener" href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/15-export">15</a>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">sayHi</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Options</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应的导入和使用模块应该是这样：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; name, getName, <span class="title class_">Animal</span>, <span class="title class_">Directions</span>, <span class="title class_">Options</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line"><span class="keyword">let</span> myName = <span class="title function_">getName</span>();</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> directions = [<span class="title class_">Directions</span>.<span class="property">Up</span>, <span class="title class_">Directions</span>.<span class="property">Down</span>, <span class="title class_">Directions</span>.<span class="property">Left</span>, <span class="title class_">Directions</span>.<span class="property">Right</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">options</span>: <span class="title class_">Options</span> = &#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-混用-declare-和-export"><a href="#2-混用-declare-和-export" class="headerlink" title="2.混用 declare 和 export"></a>2.混用 <code>declare</code> 和 <code>export</code></h4><p>我们也可以使用 <code>declare</code> 先声明多个变量，最后再用 <code>export</code> 一次性导出：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">sayHi</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Options</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; name, getName, <span class="title class_">Animal</span>, <span class="title class_">Directions</span>, <span class="title class_">Options</span> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，与全局变量的声明文件类似，<code>interface</code> 前是不需要 <code>declare</code> 的。</p>
<h4 id="3-export-namespace"><a href="#3-export-namespace" class="headerlink" title="3.export namespace"></a><code>3.export namespace</code></h4><p>与 <code>declare namespace</code> 类似，<code>export namespace</code> 用来导出一个拥有子属性的对象<a target="_blank" rel="noopener" href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/17-export-namespace">17</a>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">namespace</span> bar &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>): <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">name</span>);</span><br><span class="line">foo.<span class="property">bar</span>.<span class="title function_">baz</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-export-default"><a href="#4-export-default" class="headerlink" title="4.export default"></a><code>4.export default</code></h4><p>在 ES6 模块系统中，使用 <code>export default</code> 可以导出一个默认值，使用方可以用 <code>import foo from &#39;foo&#39;</code> 而不是 <code>import &#123; foo &#125; from &#39;foo&#39;</code> 来导入这个默认值。</p>
<p>在类型声明文件中，<code>export default</code> 用来导出默认值的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，只有 <code>function</code>、<code>class</code> 和 <code>interface</code> 可以直接默认导出，其他的变量需要先定义出来，再默认导出：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line"><span class="comment">// ERROR: Expression expected.</span></span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例中 <code>export default enum</code> 是错误的语法，需要使用 <code>declare enum</code> 定义出来，然后使用 <code>export default</code> 导出：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Directions</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>针对这种默认导出，我们一般会将导出语句放在整个声明文件的最前面：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Directions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-export"><a href="#5-export" class="headerlink" title="5.export ="></a><code>5.export =</code></h4><p>在 commonjs 规范中，我们用以下方式来导出一个模块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体导出</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = foo;</span><br><span class="line"><span class="comment">// 单个导出</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">bar</span> = bar;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 ts 中，针对这种模块导出，有多种方式可以导入，第一种方式是 <code>const ... = require</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 单个导入</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="property">bar</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种方式是 <code>import ... from</code>，注意针对整体导出，需要使用 <code>import * as</code> 来导入：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="comment">// 单个导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三种方式是 <code>import ... require</code>，这也是 ts 官方推荐的方式：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">import</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 单个导入</span></span><br><span class="line"><span class="keyword">import</span> bar = foo.<span class="property">bar</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于这种使用 commonjs 规范的库，假如要为它写类型声明文件的话，就需要使用到 <code>export =</code> 这种语法了<a target="_blank" rel="noopener" href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/21-export-equal">21</a>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，上例中使用了 <code>export =</code> 之后，就不能再单个导出 <code>export &#123; bar &#125;</code> 了。所以我们通过声明合并，使用 <code>declare namespace foo</code> 来将 <code>bar</code> 合并到 <code>foo</code> 里。</p>
<p>准确地讲，<code>export =</code> 不仅可以用在声明文件中，也可以用在普通的 ts 文件中。实际上，<code>import ... require</code> 和 <code>export =</code> 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法，由于并不常用也不推荐使用，所以这里就不详细介绍了，感兴趣的可以看[官方文档]。</p>
<p>由于很多第三方库是 commonjs 规范的，所以声明文件也就不得不用到 <code>export =</code> 这种语法了。但是还是需要再强调下，相比与 <code>export =</code>，我们更推荐使用 ES6 标准的 <code>export default</code> 和 <code>export</code>。</p>
<h3 id="二-UMD-库"><a href="#二-UMD-库" class="headerlink" title="(二)UMD 库"></a>(二)UMD 库</h3><p>既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 <code>import</code> 导入的库，称为 UMD 库。相比于 npm 包的类型声明文件，我们需要额外声明一个全局变量，为了实现这种方式，ts 提供了一个新语法 <code>export as namespace</code>。</p>
<h4 id="1-export-as-namespace"><a href="#1-export-as-namespace" class="headerlink" title="1.export as namespace"></a><code>1.export as namespace</code></h4><p>一般使用 <code>export as namespace</code> 时，都是先有了 npm 包的声明文件，再基于它添加一条 <code>export as namespace</code> 语句，即可将声明好的一个变量声明为全局变量，举例如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> foo;</span><br><span class="line">export = foo;</span><br><span class="line"></span><br><span class="line">declare function foo(): string;</span><br><span class="line">declare <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然它也可以与 <code>export default</code> 一起使用：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> foo;</span><br><span class="line">export default foo;</span><br><span class="line"></span><br><span class="line">declare function foo(): string;</span><br><span class="line">declare <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三-直接扩展全局变量"><a href="#三-直接扩展全局变量" class="headerlink" title="(三)直接扩展全局变量"></a>(三)直接扩展全局变量</h3><p>有的第三方库扩展了一个全局变量，可是此全局变量的类型却没有相应的更新过来，就会导致 ts 编译错误，此时就需要扩展全局变量的类型。比如扩展 <code>String</code> 类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="title function_">prependHello</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;foo&#x27;</span>.<span class="title function_">prependHello</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过声明合并，使用 <code>interface String</code> 即可给 <code>String</code> 添加属性或方法。</p>
<p>也可以使用 <code>declare namespace</code> 给已有的命名空间添加类型声明：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/jquery-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">JQuery</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">CustomOptions</span> &#123;</span><br><span class="line">        <span class="attr">bar</span>: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">JQueryStatic</span> &#123;</span><br><span class="line">    <span class="title function_">foo</span>(<span class="attr">options</span>: <span class="title class_">JQuery</span>.<span class="property">CustomOptions</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery.<span class="title function_">foo</span>(&#123;</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="四-在-npm-包或-UMD-库中扩展全局变量"><a href="#四-在-npm-包或-UMD-库中扩展全局变量" class="headerlink" title="(四)在 npm 包或 UMD 库中扩展全局变量"></a>(四)在 npm 包或 UMD 库中扩展全局变量</h3><p>如之前所说，对于一个 npm 包或者 UMD 库的声明文件，只有 <code>export</code> 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 <code>declare global</code>。</p>
<h4 id="1-declare-global"><a href="#1-declare-global" class="headerlink" title="1.declare global"></a><code>1.declare global</code></h4><p>使用 <code>declare global</code> 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">String</span> &#123;</span><br><span class="line">        <span class="title function_">prependHello</span>(): <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;bar&#x27;</span>.<span class="title function_">prependHello</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意即使此声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件。</p>
<h3 id="五-模块插件"><a href="#五-模块插件" class="headerlink" title="(五)模块插件"></a>(五)模块插件</h3><p>有时通过 <code>import</code> 导入一个模块插件，可以改变另一个原有模块的结构。此时如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。ts 提供了一个语法 <code>declare module</code>，它可以用来扩展原有模块的类型。</p>
<h4 id="1-declare-module"><a href="#1-declare-module" class="headerlink" title="1.declare module"></a><code>1.declare module</code></h4><p>如果是需要扩展原有模块的话，需要在类型声明文件中先引用原有模块，再使用 <code>declare module</code> 扩展原有模块：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/moment-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;moment&#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): moment.<span class="property">CalendarKey</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;moment-plugin&#x27;</span>;</span><br><span class="line"></span><br><span class="line">moment.<span class="title function_">foo</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>declare module</code> 也可用于在一个文件中一次性声明多个模块的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo-bar.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;foo&#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="attr">foo</span>: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;bar&#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Foo</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bar <span class="keyword">from</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f</span>: <span class="title class_">Foo</span>;</span><br><span class="line">bar.<span class="title function_">bar</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="六-声明文件中的依赖"><a href="#六-声明文件中的依赖" class="headerlink" title="(六)声明文件中的依赖"></a>(六)声明文件中的依赖</h3><p>一个声明文件有时会依赖另一个声明文件中的类型，比如在前面的 <code>declare module</code> 的例子中，我们就在声明文件中导入了 <code>moment</code>，并且使用了 <code>moment.CalendarKey</code> 这个类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/moment-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;moment&#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): moment.<span class="property">CalendarKey</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了可以在声明文件中通过 <code>import</code> 导入另一个声明文件中的类型之外，还有一个语法也可以用来导入另一个声明文件，那就是三斜线指令。</p>
<h4 id="1-三斜线指令"><a href="#1-三斜线指令" class="headerlink" title="1.三斜线指令"></a>1.三斜线指令</h4><p>与 <code>namespace</code> 类似，三斜线指令也是 ts 在早期版本中为了描述模块之间的依赖关系而创造的语法。随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的三斜线指令来声明模块之间的依赖关系了。</p>
<p>但是在声明文件中，它还是有一定的用武之地。</p>
<p>类似于声明文件中的 <code>import</code>，它可以用来导入另一个声明文件。与 <code>import</code> 的区别是，当且仅当在以下几个场景下，我们才需要使用三斜线指令替代 <code>import</code>：</p>
<ul>
<li>当我们在<strong>书写</strong>一个全局变量的声明文件时</li>
<li>当我们需要<strong>依赖</strong>一个全局变量的声明文件时</li>
</ul>
<h4 id="2-书写一个全局变量的声明文件"><a href="#2-书写一个全局变量的声明文件" class="headerlink" title="2.书写一个全局变量的声明文件"></a>2.书写一个全局变量的声明文件</h4><p>这些场景听上去很拗口，但实际上很好理解——在全局变量的声明文件中，是不允许出现 <code>import</code>, <code>export</code> 关键字的。一旦出现了，那么他就会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了。故当我们在书写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/jquery-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference types=&quot;jquery&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">options: JQuery.AjaxSettings</span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(&#123;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>三斜线指令的语法如上，<code>///</code> 后面使用 xml 的格式添加了对 <code>jquery</code> 类型的依赖，这样就可以在声明文件中使用 <code>JQuery.AjaxSettings</code> 类型了。</p>
<p>注意，三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释。</p>
<h4 id="3-依赖一个全局变量的声明文件"><a href="#3-依赖一个全局变量的声明文件" class="headerlink" title="3.依赖一个全局变量的声明文件"></a>3.依赖一个全局变量的声明文件</h4><p>在另一个场景下，当我们需要依赖一个全局变量的声明文件时，由于全局变量不支持通过 <code>import</code> 导入，当然也就必须使用三斜线指令来引入了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/node-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference types=&quot;node&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">p: NodeJS.Process</span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;node-plugin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="variable language_">global</span>.<span class="property">process</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们通过三斜线指引入了 <code>node</code> 的类型，然后在声明文件中使用了 <code>NodeJS.Process</code> 这个类型。最后在使用到 <code>foo</code> 的时候，传入了 <code>node</code> 中的全局变量 <code>process</code>。</p>
<p>由于引入的 <code>node</code> 中的类型都是全局变量的类型，它们是没有办法通过 <code>import</code> 来导入的，所以这种场景下也只能通过三斜线指令来引入了。</p>
<p>以上两种使用场景下，都是由于需要书写或需要依赖全局变量的声明文件，所以必须使用三斜线指令。在其他的一些不是必要使用三斜线指令的情况下，就都需要使用 <code>import</code> 来导入。</p>
<h4 id="4-拆分声明文件"><a href="#4-拆分声明文件" class="headerlink" title="4.拆分声明文件"></a>4.拆分声明文件</h4><p>当我们的全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。比如 <code>jQuery</code> 的声明文件就是这样的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules/@types/jquery/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference types=&quot;sizzle&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = jQuery;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中用到了 <code>types</code> 和 <code>path</code> 两种不同的指令。它们的区别是：<code>types</code> 用于声明对另一个库的依赖，而 <code>path</code> 用于声明对另一个文件的依赖。</p>
<p>上例中，<code>sizzle</code> 是与 <code>jquery</code> 平行的另一个库，所以需要使用 <code>types=&quot;sizzle&quot;</code> 来声明对它的依赖。而其他的三斜线指令就是将 <code>jquery</code> 的声明拆分到不同的文件中了，然后在这个入口文件中使用 <code>path=&quot;foo&quot;</code> 将它们一一引入。</p>
<h4 id="5-其他三斜线指令"><a href="#5-其他三斜线指令" class="headerlink" title="5.其他三斜线指令"></a>5.其他三斜线指令</h4><p>除了这两种三斜线指令之外，还有其他的三斜线指令，比如 <code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code>, <code>/// &lt;amd-module /&gt;</code> 等，但它们都是废弃的语法，故这里就不介绍了，详情可见<a target="_blank" rel="noopener" href="http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html">官网</a>。</p>
<h2 id="十-内置对象"><a href="#十-内置对象" class="headerlink" title="十.内置对象"></a>十.内置对象</h2><p>JavaScript 中有很多[内置对象]，它们可以直接在 TypeScript 中当做定义好了的类型。</p>
<p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p>
<h3 id="一-ECMAScript-的内置对象"><a href="#一-ECMAScript-的内置对象" class="headerlink" title="(一)ECMAScript 的内置对象"></a>(一)ECMAScript 的内置对象</h3><p>ECMAScript 标准提供的内置对象有：</p>
<p><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等。</p>
<p>我们可以在 TypeScript 中将变量定义为这些类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="title class_">Boolean</span> = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span>: <span class="title class_">Error</span> = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Error occurred&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="attr">d</span>: <span class="title class_">Date</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="attr">r</span>: <span class="title class_">RegExp</span> = <span class="regexp">/[a-z]/</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更多的内置对象，可以查看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">MDN 的文档</a>。</p>
<p>而他们的定义文件，则在 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库的定义文件</a>中。</p>
<h3 id="二-DOM-和-BOM-的内置对象"><a href="#二-DOM-和-BOM-的内置对象" class="headerlink" title="(二)DOM 和 BOM 的内置对象"></a>(二)DOM 和 BOM 的内置对象</h3><p>DOM 和 BOM 提供的内置对象有：</p>
<p><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</p>
<p>TypeScript 中会经常用到这些类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">body</span>: <span class="title class_">HTMLElement</span> = <span class="variable language_">document</span>.<span class="property">body</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">allDiv</span>: <span class="title class_">NodeList</span> = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e: MouseEvent</span>) &#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它们的定义文件同样在 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库的定义文件</a>中。</p>
<h3 id="三-TypeScript-核心库的定义文件"><a href="#三-TypeScript-核心库的定义文件" class="headerlink" title="(三)TypeScript 核心库的定义文件"></a>(三)TypeScript 核心库的定义文件</h3><p><a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库的定义文件</a>中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。</p>
<p>当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,14): error TS2345: Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>Math.pow</code> 必须接受两个 <code>number</code> 类型的参数。事实上 <code>Math.pow</code> 的类型定义如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Math</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of a base expression taken to a specified power.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x The base value of the expression.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y The exponent value of the expression.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">pow</span>(<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再举一个 DOM 中的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">targetCurrent</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,17): error TS2339: Property &#x27;targetCurrent&#x27; does not exist on type &#x27;MouseEvent&#x27;.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>addEventListener</code> 方法是在 TypeScript 核心库中定义的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> <span class="keyword">extends</span> <span class="title class_">Node</span>, <span class="title class_">GlobalEventHandlers</span>, <span class="title class_">NodeSelector</span>, <span class="title class_">DocumentEvent</span> &#123;</span><br><span class="line">    <span class="title function_">addEventListener</span>(<span class="attr">type</span>: <span class="built_in">string</span>, <span class="attr">listener</span>: <span class="function">(<span class="params">ev: MouseEvent</span>) =&gt;</span> <span class="built_in">any</span>, useCapture?: <span class="built_in">boolean</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以 <code>e</code> 被推断成了 <code>MouseEvent</code>，而 <code>MouseEvent</code> 是没有 <code>targetCurrent</code> 属性的，所以报错了。</p>
<p>注意，TypeScript 核心库的定义中不包含 Node.js 部分。</p>
<h3 id="四-用-TypeScript-写-Node-js"><a href="#四-用-TypeScript-写-Node-js" class="headerlink" title="(四)用 TypeScript 写 Node.js"></a>(四)用 TypeScript 写 Node.js</h3><p>Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/node --save-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="十一-类型别名"><a href="#十一-类型别名" class="headerlink" title="十一.类型别名"></a>十一.类型别名</h2><p>类型别名用来给一个类型起个新名字。</p>
<p>简单的例子</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameResolver</span> = <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameOrResolver</span> = <span class="title class_">Name</span> | <span class="title class_">NameResolver</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title class_">Name</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">n</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例中，我们使用 <code>type</code> 创建类型别名。</p>
<p>类型别名常用于联合类型。</p>
<h2 id="十二-字符串字面量类型"><a href="#十二-字符串字面量类型" class="headerlink" title="十二.字符串字面量类型"></a>十二.字符串字面量类型</h2><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p>
<p>简单的例子</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EventNames</span> = <span class="string">&#x27;click&#x27;</span> | <span class="string">&#x27;scroll&#x27;</span> | <span class="string">&#x27;mousemove&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleEvent</span>(<span class="params">ele: Element, event: EventNames</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">handleEvent</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hello&#x27;</span>), <span class="string">&#x27;scroll&#x27;</span>);  <span class="comment">// 没问题</span></span><br><span class="line"><span class="title function_">handleEvent</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;world&#x27;</span>), <span class="string">&#x27;dblclick&#x27;</span>); <span class="comment">// 报错，event 不能为 &#x27;dblclick&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(7,47): error TS2345: Argument of type &#x27;&quot;dblclick&quot;&#x27; is not assignable to parameter of type &#x27;EventNames&#x27;.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例中，我们使用 <code>type</code> 定了一个字符串字面量类型 <code>EventNames</code>，它只能取三种字符串中的一种。</p>
<p>注意，<strong>类型别名与字符串字面量类型都是使用 <code>type</code> 进行定义。</strong></p>
<h2 id="十三-元组"><a href="#十三-元组" class="headerlink" title="十三.元组"></a>十三.元组</h2><p>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。</p>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>定义一对值分别为 <code>string</code> 和 <code>number</code> 的元组：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">25</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当赋值或访问一个已知索引的元素时，会得到正确的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom[<span class="number">0</span>] = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">tom[<span class="number">1</span>] = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">tom[<span class="number">0</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">tom[<span class="number">1</span>].<span class="title function_">toFixed</span>(<span class="number">2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可以只赋值其中一项：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom[<span class="number">0</span>] = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom = [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">25</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom = [<span class="string">&#x27;Tom&#x27;</span>];</span><br><span class="line"><span class="comment">// Property &#x27;1&#x27; is missing in type &#x27;[string]&#x27; but required in type &#x27;[string, number]&#x27;.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="越界的元素"><a href="#越界的元素" class="headerlink" title="越界的元素"></a>越界的元素</h3><p>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom = [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">25</span>];</span><br><span class="line">tom.<span class="title function_">push</span>(<span class="string">&#x27;male&#x27;</span>);</span><br><span class="line">tom.<span class="title function_">push</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// Argument of type &#x27;true&#x27; is not assignable to parameter of type &#x27;string | number&#x27;.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="十四-枚举"><a href="#十四-枚举" class="headerlink" title="十四.枚举"></a>十四.枚举</h2><p>枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p>
<h3 id="一-简单的例子"><a href="#一-简单的例子" class="headerlink" title="(一)简单的例子"></a>(一)简单的例子</h3><p>枚举使用 <code>enum</code> 关键字来定义：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span> &#123;<span class="title class_">Sun</span>, <span class="title class_">Mon</span>, <span class="title class_">Tue</span>, <span class="title class_">Wed</span>, <span class="title class_">Thu</span>, <span class="title class_">Fri</span>, <span class="title class_">Sat</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子会被编译为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Days</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Days</span>) &#123;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;Sun&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Mon&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Mon&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Tue&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;Tue&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Wed&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Wed&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Thu&quot;</span>] = <span class="number">4</span>] = <span class="string">&quot;Thu&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Fri&quot;</span>] = <span class="number">5</span>] = <span class="string">&quot;Fri&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Sat&quot;</span>] = <span class="number">6</span>] = <span class="string">&quot;Sat&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Days</span> || (<span class="title class_">Days</span> = &#123;&#125;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二-手动赋值"><a href="#二-手动赋值" class="headerlink" title="(二)手动赋值"></a>(二)手动赋值</h3><p>我们也可以给枚举项手动赋值：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span> &#123;<span class="title class_">Sun</span> = <span class="number">7</span>, <span class="title class_">Mon</span> = <span class="number">1</span>, <span class="title class_">Tue</span>, <span class="title class_">Wed</span>, <span class="title class_">Thu</span>, <span class="title class_">Fri</span>, <span class="title class_">Sat</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] === <span class="number">7</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Mon&quot;</span>] === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Tue&quot;</span>] === <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sat&quot;</span>] === <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>未手动赋值的枚举项会接着上一个枚举项递增。</strong></p>
<p>如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span> &#123;<span class="title class_">Sun</span> = <span class="number">3</span>, <span class="title class_">Mon</span> = <span class="number">1</span>, <span class="title class_">Tue</span>, <span class="title class_">Wed</span>, <span class="title class_">Thu</span>, <span class="title class_">Fri</span>, <span class="title class_">Sat</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Days</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Days</span>) &#123;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Sun&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Mon&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Mon&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Tue&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;Tue&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Wed&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Wed&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Thu&quot;</span>] = <span class="number">4</span>] = <span class="string">&quot;Thu&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Fri&quot;</span>] = <span class="number">5</span>] = <span class="string">&quot;Fri&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Sat&quot;</span>] = <span class="number">6</span>] = <span class="string">&quot;Sat&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Days</span> || (<span class="title class_">Days</span> = &#123;&#125;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以使用的时候需要注意，最好不要出现这种覆盖的情况。</p>
<p>手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查 (编译出的 js 仍然是可用的)：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span> &#123;<span class="title class_">Sun</span> = <span class="number">7</span>, <span class="title class_">Mon</span>, <span class="title class_">Tue</span>, <span class="title class_">Wed</span>, <span class="title class_">Thu</span>, <span class="title class_">Fri</span>, <span class="title class_">Sat</span> = &lt;<span class="built_in">any</span>&gt;<span class="string">&quot;S&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Days</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Days</span>) &#123;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] = <span class="number">7</span>] = <span class="string">&quot;Sun&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Mon&quot;</span>] = <span class="number">8</span>] = <span class="string">&quot;Mon&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Tue&quot;</span>] = <span class="number">9</span>] = <span class="string">&quot;Tue&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Wed&quot;</span>] = <span class="number">10</span>] = <span class="string">&quot;Wed&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Thu&quot;</span>] = <span class="number">11</span>] = <span class="string">&quot;Thu&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Fri&quot;</span>] = <span class="number">12</span>] = <span class="string">&quot;Fri&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Sat&quot;</span>] = <span class="string">&quot;S&quot;</span>] = <span class="string">&quot;Sat&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Days</span> || (<span class="title class_">Days</span> = &#123;&#125;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 <code>1</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span> &#123;<span class="title class_">Sun</span> = <span class="number">7</span>, <span class="title class_">Mon</span> = <span class="number">1.5</span>, <span class="title class_">Tue</span>, <span class="title class_">Wed</span>, <span class="title class_">Thu</span>, <span class="title class_">Fri</span>, <span class="title class_">Sat</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] === <span class="number">7</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Mon&quot;</span>] === <span class="number">1.5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Tue&quot;</span>] === <span class="number">2.5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sat&quot;</span>] === <span class="number">6.5</span>); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三-常数项和计算所得项"><a href="#三-常数项和计算所得项" class="headerlink" title="(三)常数项和计算所得项"></a>(三)常数项和计算所得项</h3><p>枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。</p>
<p>前面我们所举的例子都是常数项，一个典型的计算所得项的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span> = <span class="string">&quot;blue&quot;</span>.<span class="property">length</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>&quot;blue&quot;.length</code> 就是一个计算所得项。</p>
<p>上面的例子不会报错，但是<strong>如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错</strong>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="string">&quot;red&quot;</span>.<span class="property">length</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,33): error TS1061: Enum member must have initializer.</span></span><br><span class="line"><span class="comment">// index.ts(1,40): error TS1061: Enum member must have initializer.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是常数项和计算所得项的完整定义，部分引用自<a target="_blank" rel="noopener" href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Enums.html">中文手册 - 枚举</a>：</p>
<p>当满足以下条件时，枚举成员被当作是常数：</p>
<ul>
<li>不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 <code>1</code>。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 <code>0</code>。</li>
<li>枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式：<ul>
<li>数字字面量</li>
<li>引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用</li>
<li>带括号的常数枚举表达式</li>
<li><code>+</code>, <code>-</code>, <code>~</code> 一元运算符应用于常数枚举表达式</li>
<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code> 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错</li>
</ul>
</li>
</ul>
<p>所有其它情况的枚举成员被当作是需要计算得出的值。</p>
<h3 id="四-常数枚举"><a href="#四-常数枚举" class="headerlink" title="(四)常数枚举"></a>(四)常数枚举</h3><p>常数枚举是使用 <code>const enum</code> 定义的枚举类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [<span class="title class_">Directions</span>.<span class="property">Up</span>, <span class="title class_">Directions</span>.<span class="property">Down</span>, <span class="title class_">Directions</span>.<span class="property">Left</span>, <span class="title class_">Directions</span>.<span class="property">Right</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。</p>
<p>上例的编译结果是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意如果包含了计算成员，则会在编译阶段报错：</p>
<h3 id="五-外部枚举"><a href="#五-外部枚举" class="headerlink" title="(五)外部枚举"></a>(五)外部枚举</h3><p>外部枚举（Ambient Enums）是使用 <code>declare enum</code> 定义的枚举类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [<span class="title class_">Directions</span>.<span class="property">Up</span>, <span class="title class_">Directions</span>.<span class="property">Down</span>, <span class="title class_">Directions</span>.<span class="property">Left</span>, <span class="title class_">Directions</span>.<span class="property">Right</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之前提到过，<code>declare</code> 定义的类型只会用于编译时的检查，编译结果中会被删除。</p>
<p>上例的编译结果是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [<span class="title class_">Directions</span>.<span class="property">Up</span>, <span class="title class_">Directions</span>.<span class="property">Down</span>, <span class="title class_">Directions</span>.<span class="property">Left</span>, <span class="title class_">Directions</span>.<span class="property">Right</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>外部枚举与声明语句一样，常出现在声明文件中。</p>
<p>同时使用 <code>declare</code> 和 <code>const</code> 也是可以的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [<span class="title class_">Directions</span>.<span class="property">Up</span>, <span class="title class_">Directions</span>.<span class="property">Down</span>, <span class="title class_">Directions</span>.<span class="property">Left</span>, <span class="title class_">Directions</span>.<span class="property">Right</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="十五-类"><a href="#十五-类" class="headerlink" title="十五.类"></a>十五.类</h2><p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p>
<ul>
<li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li>
<li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li>
<li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  //public,private,protected</span><br><span class="line">  public name;</span><br><span class="line">  public constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.name); // Jack</span><br><span class="line">a.name = &#x27;Tom&#x27;;</span><br><span class="line">console.log(a.name); // Tom</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>); <span class="comment">// Jack</span></span><br><span class="line">a.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(10,3): TS2540: Cannot assign to &#x27;name&#x27; because it is a read-only property.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h4><p>给类加上 TypeScript 的类型很简单，与接口类似：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHi</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">Animal</span> = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">sayHi</span>()); <span class="comment">// My name is Jack</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="十六-泛型"><a href="#十六-泛型" class="headerlink" title="十六.泛型"></a>十六.泛型</h2><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>
<h4 id="一-案例说明"><a href="#一-案例说明" class="headerlink" title="(一)案例说明"></a>(一)案例说明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function num (a:number,b:number) : Array&lt;number&gt; &#123;</span><br><span class="line">    return [a ,b];</span><br><span class="line">&#125;</span><br><span class="line">num(1,2)</span><br><span class="line">function str (a:string,b:string) : Array&lt;string&gt; &#123;</span><br><span class="line">    return [a ,b];</span><br><span class="line">&#125;</span><br><span class="line">str(&#x27;独孤&#x27;,&#x27;求败&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上两个函数实现的功能是一样,就是类型不同.这时候我们就可以使用泛型来优化</p>
<p>语法为函数名字后面跟一个&lt;参数名&gt; 参数名可以随便写(不过一般约定T)</p>
<p>当我们使用这个函数的时候把参数的类型传进去就可以了 （也就是动态类型）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Add&lt;T&gt;(a: T, b: T): Array&lt;T&gt;  &#123;</span><br><span class="line">    return [a,b]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Add&lt;number&gt;(1,2)//或者触发类型推论 Add(1,2)</span><br><span class="line">Add&lt;string&gt;(&#x27;1&#x27;,&#x27;2&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="二-多类型参数"><a href="#二-多类型参数" class="headerlink" title="(二)多类型参数"></a>(二)多类型参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Sub&lt;T,U&gt;(a:T,b:U):Array&lt;T|U&gt; &#123;</span><br><span class="line">    const params:Array&lt;T|U&gt; = [a,b]</span><br><span class="line">    return params</span><br><span class="line">&#125; </span><br><span class="line">Sub&lt;Boolean,number&gt;(false,1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="三-泛型约束"><a href="#三-泛型约束" class="headerlink" title="(三)泛型约束"></a>(三)泛型约束</h4><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,19): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;T&#x27;.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。</p>
<p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 <code>length</code> 属性的变量。这就是泛型约束：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例中，我们使用了 <code>extends</code> 约束了泛型 <code>T</code> 必须符合接口 <code>Lengthwise</code> 的形状，也就是必须包含 <code>length</code> 属性。</p>
<h4 id="四-泛型类"><a href="#四-泛型类" class="headerlink" title="(四)泛型类"></a>(四)泛型类</h4><p>与泛型接口类似，泛型也可以用于类的类型定义中：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">zeroValue</span>: T;</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.<span class="property">zeroValue</span> = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="五-泛型参数的默认类型"><a href="#五-泛型参数的默认类型" class="headerlink" title="(五)泛型参数的默认类型"></a>(五)泛型参数的默认类型</h4><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createArray&lt;T = <span class="built_in">string</span>&gt;(<span class="attr">length</span>: <span class="built_in">number</span>, <span class="attr">value</span>: T): <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">result</span>: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="十七-tsconfig-json配置文件"><a href="#十七-tsconfig-json配置文件" class="headerlink" title="十七.tsconfig.json配置文件"></a>十七.tsconfig.json配置文件</h2><h4 id="介绍几个常用的"><a href="#介绍几个常用的" class="headerlink" title="介绍几个常用的"></a>介绍几个常用的</h4><p>1.include<br>指定编译文件默认是编译当前目录下所有的ts文件</p>
<p>2.exclude<br>指定排除的文件</p>
<p>3.target<br>指定编译js 的版本例如es5  es6</p>
<p>4.allowJS<br>是否允许编译js文件</p>
<p>5.removeComments<br>是否在编译过程中删除文件中的注释</p>
<p>6.rootDir<br>编译文件的目录</p>
<p>7.outDir<br>输出的目录</p>
<p>8.sourceMap<br>代码源文件</p>
<p>9.strict<br>严格模式</p>
<p>10.module<br>默认common.js  可选es6模式 amd  umd 等</p>
<h4 id="详细的"><a href="#详细的" class="headerlink" title="详细的"></a>详细的</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&quot;compilerOptions&quot;: &#123;</span><br><span class="line">  &quot;incremental&quot;: true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度</span><br><span class="line">  &quot;tsBuildInfoFile&quot;: &quot;./buildFile&quot;, // 增量编译文件的存储位置</span><br><span class="line">  &quot;diagnostics&quot;: true, // 打印诊断信息 </span><br><span class="line">  &quot;target&quot;: &quot;ES5&quot;, // 目标语言的版本</span><br><span class="line">  &quot;module&quot;: &quot;CommonJS&quot;, // 生成代码的模板标准</span><br><span class="line">  &quot;outFile&quot;: &quot;./app.js&quot;, // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;,</span><br><span class="line">  &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,</span><br><span class="line">  &quot;allowJS&quot;: true, // 允许编译器编译JS，JSX文件</span><br><span class="line">  &quot;checkJs&quot;: true, // 允许在JS文件中报错，通常与allowJS一起使用</span><br><span class="line">  &quot;outDir&quot;: &quot;./dist&quot;, // 指定输出目录</span><br><span class="line">  &quot;rootDir&quot;: &quot;./&quot;, // 指定输出文件目录(用于输出)，用于控制输出目录结构</span><br><span class="line">  &quot;declaration&quot;: true, // 生成声明文件，开启后会自动生成声明文件</span><br><span class="line">  &quot;declarationDir&quot;: &quot;./file&quot;, // 指定生成声明文件存放目录</span><br><span class="line">  &quot;emitDeclarationOnly&quot;: true, // 只生成声明文件，而不会生成js文件</span><br><span class="line">  &quot;sourceMap&quot;: true, // 生成目标文件的sourceMap文件</span><br><span class="line">  &quot;inlineSourceMap&quot;: true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中</span><br><span class="line">  &quot;declarationMap&quot;: true, // 为声明文件生成sourceMap</span><br><span class="line">  &quot;typeRoots&quot;: [], // 声明文件目录，默认时node_modules/@types</span><br><span class="line">  &quot;types&quot;: [], // 加载的声明文件包</span><br><span class="line">  &quot;removeComments&quot;:true, // 删除注释 </span><br><span class="line">  &quot;noEmit&quot;: true, // 不输出文件,即编译后不会生成任何js文件</span><br><span class="line">  &quot;noEmitOnError&quot;: true, // 发送错误时不输出任何文件</span><br><span class="line">  &quot;noEmitHelpers&quot;: true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用</span><br><span class="line">  &quot;importHelpers&quot;: true, // 通过tslib引入helper函数，文件必须是模块</span><br><span class="line">  &quot;downlevelIteration&quot;: true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现</span><br><span class="line">  &quot;strict&quot;: true, // 开启所有严格的类型检查</span><br><span class="line">  &quot;alwaysStrict&quot;: true, // 在代码中注入&#x27;use strict&#x27;</span><br><span class="line">  &quot;noImplicitAny&quot;: true, // 不允许隐式的any类型</span><br><span class="line">  &quot;strictNullChecks&quot;: true, // 不允许把null、undefined赋值给其他类型的变量</span><br><span class="line">  &quot;strictFunctionTypes&quot;: true, // 不允许函数参数双向协变</span><br><span class="line">  &quot;strictPropertyInitialization&quot;: true, // 类的实例属性必须初始化</span><br><span class="line">  &quot;strictBindCallApply&quot;: true, // 严格的bind/call/apply检查</span><br><span class="line">  &quot;noImplicitThis&quot;: true, // 不允许this有隐式的any类型</span><br><span class="line">  &quot;noUnusedLocals&quot;: true, // 检查只声明、未使用的局部变量(只提示不报错)</span><br><span class="line">  &quot;noUnusedParameters&quot;: true, // 检查未使用的函数参数(只提示不报错)</span><br><span class="line">  &quot;noFallthroughCasesInSwitch&quot;: true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)</span><br><span class="line">  &quot;noImplicitReturns&quot;: true, //每个分支都会有返回值</span><br><span class="line">  &quot;esModuleInterop&quot;: true, // 允许export=导出，由import from 导入</span><br><span class="line">  &quot;allowUmdGlobalAccess&quot;: true, // 允许在模块中全局变量的方式访问umd模块</span><br><span class="line">  &quot;moduleResolution&quot;: &quot;node&quot;, // 模块解析策略，ts默认用node的解析策略，即相对的方式导入</span><br><span class="line">  &quot;baseUrl&quot;: &quot;./&quot;, // 解析非相对模块的基地址，默认是当前目录</span><br><span class="line">  &quot;paths&quot;: &#123; // 路径映射，相对于baseUrl</span><br><span class="line">    // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置</span><br><span class="line">    &quot;jquery&quot;: [&quot;node_modules/jquery/dist/jquery.min.js&quot;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错</span><br><span class="line">  &quot;listEmittedFiles&quot;: true, // 打印输出文件</span><br><span class="line">  &quot;listFiles&quot;: true// 打印编译的文件(包括引用的声明文件)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件）</span><br><span class="line">&quot;include&quot;: [</span><br><span class="line">   &quot;src/**/*&quot;</span><br><span class="line">],</span><br><span class="line">// 指定一个排除列表（include的反向操作）</span><br><span class="line"> &quot;exclude&quot;: [</span><br><span class="line">   &quot;demo.ts&quot;</span><br><span class="line">],</span><br><span class="line">// 指定哪些文件使用该配置（属于手动一个个指定文件）</span><br><span class="line"> &quot;files&quot;: [</span><br><span class="line">   &quot;demo.ts&quot;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>License</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>READ NEXT</span></section><section class="body fs14"><a id="next" href="/2022/08/30/%E5%89%8D%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">前台项目总结<span class="note">Older</span></a><div class="line"></div><a id="prev" href="/2022/12/13/%E5%9C%A8vue2%E4%B8%AD%E5%B0%86js%E6%94%B9%E4%B8%BAts/">在vue2中将js改为ts<span class="note">Newer</span></a></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</p>
<p>This site was deployed by <a href="http://example.com/">@李阳滨</a> using <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0" title="v1.8.0">Stellar</a>.</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0';
  stellar.config = {
    date_suffix: {
      just: 'Just',
      min: 'minutes ago',
      hour: 'hours ago',
      day: 'days ago',
      month: 'months ago',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://fastly.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://fastly.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://fastly.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
