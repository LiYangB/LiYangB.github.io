<!DOCTYPE html>
<html lang='en'>

<head>
  <meta name="generator" content="Hexo 6.2.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://fastly.jsdelivr.net'>
  <link rel="preconnect" href="https://fastly.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>JavaScript 笔记 - 个人博客</title>

  
    <meta name="description" content="《JS红宝书》概述: js红宝书是每个前端开发者都应该听过的一本书,本文档是作者阅读该书后记录所得,有结合红宝书，网上部分前辈的笔记,以及个人平时积累的知识点.希望能做到对js的查漏补缺。 一：基础部分01：什么是 JavaScriptjs 包含三部分： ECMAScript 也就是 es：es 被称为是 js 的核心，它描述了js的  语法  类型  语句  关键字(back,case,catc">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 笔记">
<meta property="og:url" content="http://example.com/2023/09/24/JavaScript-%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="《JS红宝书》概述: js红宝书是每个前端开发者都应该听过的一本书,本文档是作者阅读该书后记录所得,有结合红宝书，网上部分前辈的笔记,以及个人平时积累的知识点.希望能做到对js的查漏补缺。 一：基础部分01：什么是 JavaScriptjs 包含三部分： ECMAScript 也就是 es：es 被称为是 js 的核心，它描述了js的  语法  类型  语句  关键字(back,case,catc">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-09-24T14:16:23.000Z">
<meta property="article:modified_time" content="2023-09-25T16:22:18.316Z">
<meta property="article:author" content="李阳滨">
<meta property="article:tag" content="个人总结">
<meta name="twitter:card" content="summary">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="title" href="/"><div class="main">个人博客</div></a></div>
<nav class="menu dis-select"></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">TOC</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86"><span class="toc-text">一：基础部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF-JavaScript"><span class="toc-text">01：什么是 JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#js-%E5%8C%85%E5%90%AB%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A"><span class="toc-text">js 包含三部分：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E4%B8%8E%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">拓展与注意点:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JavaScript%E4%B8%8ENode-js"><span class="toc-text">JavaScript与Node.js:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02%EF%BC%9AHTML-%E4%B8%AD%E7%9A%84-JavaScript"><span class="toc-text">02：HTML 中的 JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-lt-script-gt-%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">使用 &lt;script&gt; 元素的方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#script%E5%B1%9E%E6%80%A7"><span class="toc-text">script属性:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E8%84%9A%E6%9C%AC%E5%92%8C%E5%A4%96%E9%83%A8%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">行内脚本和外部脚本的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#js-%E4%B8%8D%E5%8F%AF%E7%94%A8%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%EF%BC%9A"><span class="toc-text">js  不可用时，如何保证用户体验：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E4%B8%8E%E6%B3%A8%E6%84%8F%E7%82%B9-1"><span class="toc-text">拓展与注意点:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03%EF%BC%9A%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-text">03：语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E8%AF%AD%E6%B3%95"><span class="toc-text">3.1语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-text">3.2关键字与保留字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E5%8F%98%E9%87%8F"><span class="toc-text">3.3变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-text">(一)变量提升</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="toc-text">(二)暂时性死区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">(三)块级作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B-%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E"><span class="toc-text">(四)重复声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94-%E4%BF%AE%E6%94%B9%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">(五)修改声明的变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.4数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E6%80%BB%E5%85%B1%E5%85%AB%E7%A7%8D"><span class="toc-text">(一)总共八种</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E9%89%B4%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="toc-text">(二)鉴定方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3.5 操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-1-%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3.5.1 一元操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-2-%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3.5.2 位操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-3-%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3.5.3 布尔操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-4-%E4%B9%98%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3.5.4 乘性操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-5-%E6%8C%87%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3.5.5 指数操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-6-%E5%8A%A0%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3.5.6 加性操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-7-%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3.5.7 关系操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-8-%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3.5.8 相等操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-9-%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6-%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3.5.9 条件操作符(三元操作符)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-10-%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3.5.10 赋值操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-11-%E9%80%97%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">3.5.11 逗号操作符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.6 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-1-if%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.6.1 if语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-2-do%E2%80%A6while%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.6.2 do…while语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-3-while%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.6.3 while语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-4-for%E8%AF%AD%E5%8F%A5-for%E5%BE%AA%E7%8E%AF"><span class="toc-text">3.6.4 for语句(for循环)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-5-for-in%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.6.5 for-in语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-6-for-of%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.6.6 for-of语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-7-%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.6.7 标签语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-8-break%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.6.8 break和continue语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-9-with%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.6.9 with语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-10-switch%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.6.10 switch语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04%EF%BC%9A%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-text">04：变量、作用域与内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AF%B9%E8%B1%A1"><span class="toc-text">执行上下文对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E7%B1%BB"><span class="toc-text">代码分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">全局执行上下文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">函数执行上下文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88"><span class="toc-text">执行上下文栈</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">作用域链</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AF%B9%E6%AF%94"><span class="toc-text">函数执行上下文与作用域对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-text">区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%94%E7%B3%BB"><span class="toc-text">联系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">(一)内存溢出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">(二)内存泄露</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">05：基本引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-Data%EF%BC%88%EF%BC%89"><span class="toc-text">5.1 Data（）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2RegExp%EF%BC%88%EF%BC%89"><span class="toc-text">5.2RegExp（）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-text">实例方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">5.3原始值包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Boolean"><span class="toc-text">Boolean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Number"><span class="toc-text">Number</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B"><span class="toc-text">String类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-text">5.4内置对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Global%E5%AF%B9%E8%B1%A1"><span class="toc-text">Global对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#window%E5%AF%B9%E8%B1%A1"><span class="toc-text">window对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Math%E5%AF%B9%E8%B1%A1"><span class="toc-text">Math对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#06%EF%BC%9A%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">06：集合引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1Object"><span class="toc-text">6.1Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2Array"><span class="toc-text">6.2Array</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-1%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-text">6.2.1创建数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-2%E6%95%B0%E7%BB%84%E7%A9%BA%E4%BD%8D"><span class="toc-text">6.2.2数组空位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-3%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95"><span class="toc-text">6.2.3数组索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-4%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84"><span class="toc-text">6.2.4检测数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-5%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.5迭代器方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-6%E5%A4%8D%E5%88%B6%E5%92%8C%E5%A1%AB%E5%85%85%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.6复制和填充方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text">其他常见方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%96%B9%E6%B3%95"><span class="toc-text">归并方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-text">6.3定型数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4Map"><span class="toc-text">6.4Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5WeakMap"><span class="toc-text">6.5WeakMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6Set"><span class="toc-text">6.6Set</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%ACAPI-2"><span class="toc-text">基本API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E4%B8%8E%E8%BF%AD%E4%BB%A3-1"><span class="toc-text">顺序与迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E6%93%8D%E4%BD%9C"><span class="toc-text">特定操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7WeakSet"><span class="toc-text">6.7WeakSet</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%ACAPI-3"><span class="toc-text">基本API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-text">特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">07：迭代器与生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-text">迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-text">数组迭代的缺陷</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE"><span class="toc-text">可迭代协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">可迭代对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE"><span class="toc-text">迭代器协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-1"><span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">自定义迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E5%89%8D%E7%BB%88%E6%AD%A2%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">提前终止迭代器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%9F%BA%E7%A1%80"><span class="toc-text">生成器基础</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#yield"><span class="toc-text">yield</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#yield-%E5%AE%9E%E7%8E%B0%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-text">yield 实现输入和输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E5%89%8D%E7%BB%88%E6%AD%A2%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">提前终止生成器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#return"><span class="toc-text">return()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#throw"><span class="toc-text">throw()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#08%EF%BC%9A%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-text">08：对象、类与面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.1理解对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-1%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">8.1.1属性的类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-2%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="toc-text">8.1.2定义多个属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-3%E8%AF%BB%E5%8F%96%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">8.1.3读取属性的特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-4%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.1.4合并对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-5%E5%AF%B9%E8%B1%A1%E6%A0%87%E8%AF%86%E5%8F%8A%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%ADis"><span class="toc-text">8.1.5对象标识及相等判断is</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-6%E5%A2%9E%E5%BC%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95"><span class="toc-text">8.1.6增强的对象语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-7%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-text">8.1.7对象解构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.2创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-2%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-text">8.2.2工厂模式：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-3%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-text">8.2.3构造函数模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-4%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%EF%BC%9A"><span class="toc-text">8.2.4理解原型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-5%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3"><span class="toc-text">8.2.5对象迭代</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3%E7%BB%A7%E6%89%BF"><span class="toc-text">8.3继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-3-1%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">8.3.1原型链</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-3-2%E7%9B%97%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.3.2盗用构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-3-3%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-text">8.3.3组合继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-3-4%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">8.3.4原型式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-3-5%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">8.3.5寄生式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-3-6%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-text">8.3.6寄生式组合继承</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4%E7%B1%BB"><span class="toc-text">8.4类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-1%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">8.4.1类的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-2%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.4.2类的构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-3%E5%AE%9E%E4%BE%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-text">8.4.3实例、原型和类成员</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-4%E7%BB%A7%E6%89%BF"><span class="toc-text">8.4.4继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#09%EF%BC%9A%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="toc-text">09：代理与反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1%E4%BB%A3%E7%90%86%E5%9F%BA%E7%A1%80"><span class="toc-text">9.1代理基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-1%E5%88%9B%E5%BB%BA%E7%A9%BA%E7%9A%84%E4%BB%A3%E7%90%86"><span class="toc-text">9.1.1创建空的代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-2%E5%AE%9A%E4%B9%89%E6%8D%95%E8%8E%B7%E5%99%A8"><span class="toc-text">9.1.2定义捕获器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-3%E6%8D%95%E8%8E%B7%E5%99%A8%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%8D%E5%B0%84API"><span class="toc-text">9.1.3捕获器参数和反射API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-4%E6%8D%95%E8%8E%B7%E5%99%A8%E4%B8%8D%E5%8F%98%E5%BC%8F"><span class="toc-text">9.1.4捕获器不变式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-5%E5%8F%AF%E6%92%A4%E9%94%80%E4%BB%A3%E7%90%86"><span class="toc-text">9.1.5可撤销代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-6%E5%AE%9E%E7%94%A8%E5%8F%8D%E5%B0%84API"><span class="toc-text">9.1.6实用反射API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-7%E4%BB%A3%E7%90%86%E5%8F%A6%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86"><span class="toc-text">9.1.7代理另一个代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-8%E4%BB%A3%E7%90%86%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E4%B8%8D%E8%B6%B3"><span class="toc-text">9.1.8代理的问题与不足</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2%E4%BB%A3%E7%90%86%E6%8D%95%E8%8E%B7%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95"><span class="toc-text">9.2代理捕获器与反射方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">9.3代理模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%EF%BC%9A%E5%87%BD%E6%95%B0"><span class="toc-text">10：函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">10.1箭头函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2%E5%87%BD%E6%95%B0%E5%90%8D"><span class="toc-text">10.2函数名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3%E7%90%86%E8%A7%A3%E5%8F%82%E6%95%B0"><span class="toc-text">10.3理解参数:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#arguments%E5%AF%B9%E8%B1%A1"><span class="toc-text">arguments对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-text">箭头函数的参数：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD"><span class="toc-text">10.4函数没有重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-text">10.5默认参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="toc-text">默认参数作用域与暂时性死区</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95%E4%B8%8E%E6%94%B6%E9%9B%86"><span class="toc-text">10.6参数扩展与收集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%8F%82%E6%95%B0"><span class="toc-text">扩展参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E5%8F%82%E6%95%B0"><span class="toc-text">收集参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-7%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">10.7函数声明与函数表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-8%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%80%BC"><span class="toc-text">10.8函数作为值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-9%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8"><span class="toc-text">10.9函数内部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-10%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">10.10函数属性和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-text">属性：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-11%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">10.11函数表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-12%E9%80%92%E5%BD%92"><span class="toc-text">10.12递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-13%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-text">10.13尾调用优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">尾调用优化的条件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-14%E9%97%AD%E5%8C%85"><span class="toc-text">10.14闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9A%E4%B9%89"><span class="toc-text">(一)定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6"><span class="toc-text">(二)产生条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E4%BD%9C%E7%94%A8"><span class="toc-text">(三)作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-3"><span class="toc-text">补充</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%BC%95%E5%8F%91%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">闭包引发的内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-15%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">10.15立即调用的函数表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-16%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="toc-text">10.16私有变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="toc-text">静态私有变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F"><span class="toc-text">模块模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%A2%9E%E5%BC%BA%E6%A8%A1%E5%BC%8F"><span class="toc-text">模块增强模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%EF%BC%9A%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="toc-text">11：期约与异步函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-text">11.1异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-1-2-%E4%BB%A5%E5%BE%80%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">11.1.2 以往的异步编程模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Evnet-Loop%E5%9B%9E%E9%A1%BE"><span class="toc-text">Evnet Loop回顾</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-%E6%9C%9F%E7%BA%A6"><span class="toc-text">11.2 期约</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-2-1-Promises-x2F-A-%E8%A7%84%E8%8C%83"><span class="toc-text">11.2.1 Promises&#x2F;A+规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-2-2-%E6%9C%9F%E7%BA%A6%E5%9F%BA%E7%A1%80"><span class="toc-text">11.2.2 期约基础</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-2-3-%E6%9C%9F%E7%BA%A6%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-text">11.2.3 期约的实例方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-2-4-%E6%9C%9F%E7%BA%A6%E8%BF%9E%E9%94%81%E4%B8%8E%E6%9C%9F%E7%BA%A6%E5%90%88%E6%88%90"><span class="toc-text">11.2.4 期约连锁与期约合成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-2-5-%E6%9C%9F%E7%BA%A6%E6%89%A9%E5%B1%95"><span class="toc-text">11.2.5 期约扩展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E6%89%8B%E5%86%99promise"><span class="toc-text">补充：手写promise</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="toc-text">11.3 异步函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-3-1-%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="toc-text">11.3.1 异步函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-3-2-%E5%81%9C%E6%AD%A2%E5%92%8C%E6%81%A2%E5%A4%8D%E6%89%A7%E8%A1%8C"><span class="toc-text">11.3.2 停止和恢复执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-3-3-%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%AD%96%E7%95%A5"><span class="toc-text">11.3.3 异步函数策略</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81API-%E9%83%A8%E5%88%86"><span class="toc-text">二、API 部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12%EF%BC%9ABOM"><span class="toc-text">12：BOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1window-%E5%AF%B9%E8%B1%A1"><span class="toc-text">12.1window 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#12-1-1Global-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">12.1.1Global 作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-1-2%E7%AA%97%E5%8F%A3%E5%85%B3%E7%B3%BB"><span class="toc-text">12.1.2窗口关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-1-3%E7%AA%97%E5%8F%A3%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%83%8F%E7%B4%A0%E6%AF%94"><span class="toc-text">12.1.3窗口位置与像素比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-1-4%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F"><span class="toc-text">12.1.4窗口大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-1-5%E8%A7%86%E5%8F%A3%E4%BD%8D%E7%BD%AE"><span class="toc-text">12.1.5视口位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-1-6%E5%AF%BC%E8%88%AA%E4%B8%8E%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3"><span class="toc-text">12.1.6导航与打开新窗口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-1-7%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">12.1.7定时器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-1-8%E7%B3%BB%E7%BB%9F%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-text">12.1.8系统对话框</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2location-%E5%AF%B9%E8%B1%A1"><span class="toc-text">12.2location 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#12-2-1%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">12.2.1查询字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-2-2%E6%93%8D%E4%BD%9C%E5%9C%B0%E5%9D%80"><span class="toc-text">12.2.2操作地址</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3navigator-%E5%AF%B9%E8%B1%A1"><span class="toc-text">12.3navigator 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#12-3-1%E6%A3%80%E6%B5%8B%E6%8F%92%E4%BB%B6"><span class="toc-text">12.3.1检测插件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-3-2%E6%B3%A8%E5%86%8C%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F-%E4%BA%86%E8%A7%A3"><span class="toc-text">12.3.2注册处理程序(了解)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4screen-%E5%AF%B9%E8%B1%A1-%E4%BA%86%E8%A7%A3"><span class="toc-text">12.4screen 对象(了解)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5history-%E5%AF%B9%E8%B1%A1"><span class="toc-text">12.5history 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#12-5-1%E5%AF%BC%E8%88%AA"><span class="toc-text">12.5.1导航</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-5-2%E5%8E%86%E5%8F%B2%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-text">12.5.2历史状态管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B"><span class="toc-text">13：客户端检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1%E8%83%BD%E5%8A%9B%E6%A3%80%E6%B5%8B"><span class="toc-text">13.1能力检测</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-1-1%E5%AE%89%E5%85%A8%E8%83%BD%E5%8A%9B%E6%A3%80%E6%B5%8B"><span class="toc-text">13.1.1安全能力检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-1-2%E5%9F%BA%E4%BA%8E%E8%83%BD%E5%8A%9B%E6%A3%80%E6%B5%8B%E8%BF%9B%E8%A1%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%86%E6%9E%90"><span class="toc-text">13.1.2基于能力检测进行浏览器分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86%E6%A3%80%E6%B5%8B"><span class="toc-text">13.2用户代理检测</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%86%E5%8F%B2%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">用户代理的历史（了解）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%86%E6%9E%90"><span class="toc-text">浏览器分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">分析浏览器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3%E8%BD%AF%E4%BB%B6%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%A3%80%E6%B5%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">13.3软件与硬件检测（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">识别浏览器与操作系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-text">浏览器元数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6"><span class="toc-text">硬件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%EF%BC%9ADOM"><span class="toc-text">14：DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1%E8%8A%82%E7%82%B9%E5%B1%82%E7%BA%A7"><span class="toc-text">14.1节点层级</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#14-1-1Node-%E7%B1%BB%E5%9E%8B"><span class="toc-text">14.1.1Node 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-1-2Document-%E7%B1%BB%E5%9E%8B"><span class="toc-text">14.1.2Document 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-1-3Element-%E7%B1%BB%E5%9E%8B"><span class="toc-text">14.1.3Element 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-1-4Text-%E7%B1%BB%E5%9E%8B"><span class="toc-text">14.1.4Text 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-1-5Comment-%E7%B1%BB%E5%9E%8B"><span class="toc-text">14.1.5Comment 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-1-6CDATASection-%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">14.1.6CDATASection 类型（了解）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-1-7DocumentType-%E7%B1%BB%E5%9E%8B-%E4%BA%86%E8%A7%A3"><span class="toc-text">14.1.7DocumentType 类型(了解)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-1-8DocumentFragment-%E7%B1%BB%E5%9E%8B"><span class="toc-text">14.1.8DocumentFragment 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-1-9Attr-%E7%B1%BB%E5%9E%8B-%E4%BA%86%E8%A7%A3"><span class="toc-text">14.1.9Attr 类型(了解)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2DOM-%E7%BC%96%E7%A8%8B"><span class="toc-text">14.2DOM 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#14-2-1%E5%8A%A8%E6%80%81%E8%84%9A%E6%9C%AC"><span class="toc-text">14.2.1动态脚本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-2-2%E5%8A%A8%E6%80%81%E6%A0%B7%E5%BC%8F"><span class="toc-text">14.2.2动态样式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-2-3%E6%93%8D%E4%BD%9C%E8%A1%A8%E6%A0%BC"><span class="toc-text">14.2.3操作表格</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-2-4%E4%BD%BF%E7%94%A8-NodeList"><span class="toc-text">14.2.4使用 NodeList</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3MutationObserver-%E6%8E%A5%E5%8F%A3"><span class="toc-text">14.3MutationObserver 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#14-3-1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">14.3.1基本用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-3-2MutationObserverInit-%E4%B8%8E%E8%A7%82%E5%AF%9F%E8%8C%83%E5%9B%B4"><span class="toc-text">14.3.2MutationObserverInit 与观察范围</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-3-3%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E4%B8%8E%E8%AE%B0%E5%BD%95%E9%98%9F%E5%88%97"><span class="toc-text">14.3.3异步回调与记录队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-3-4%E6%80%A7%E8%83%BD%E3%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">14.3.4性能、内存与垃圾回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%EF%BC%9ADOM-%E6%89%A9%E5%B1%95"><span class="toc-text">15：DOM 扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1Selectors-API"><span class="toc-text">15.1Selectors API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#15-1-1querySelector"><span class="toc-text">15.1.1querySelector()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-1-2querySelectorAll"><span class="toc-text">15.1.2querySelectorAll()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-1-3matches"><span class="toc-text">15.1.3matches()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2%E5%85%83%E7%B4%A0%E9%81%8D%E5%8E%86"><span class="toc-text">15.2元素遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-3HTML5"><span class="toc-text">15.3HTML5</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#15-3-1CSS-%E7%B1%BB%E6%89%A9%E5%B1%95"><span class="toc-text">15.3.1CSS 类扩展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-3-2%E7%84%A6%E7%82%B9%E7%AE%A1%E7%90%86"><span class="toc-text">15.3.2焦点管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-3-3HTMLDocument-%E6%89%A9%E5%B1%95"><span class="toc-text">15.3.3HTMLDocument 扩展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-3-4%E5%AD%97%E7%AC%A6%E9%9B%86%E5%B1%9E%E6%80%A7"><span class="toc-text">15.3.4字符集属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-3-5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7"><span class="toc-text">15.3.5自定义数据属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-3-6%E6%8F%92%E5%85%A5%E6%A0%87%E8%AE%B0"><span class="toc-text">15.3.6插入标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-3-7scrollIntoView"><span class="toc-text">15.3.7scrollIntoView()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-4%E4%B8%93%E6%9C%89%E6%89%A9%E5%B1%95"><span class="toc-text">15.4专有扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#15-4-1children-%E5%B1%9E%E6%80%A7"><span class="toc-text">15.4.1children 属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-4-2contains-%E6%96%B9%E6%B3%95"><span class="toc-text">15.4.2contains()方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-4-3%E6%8F%92%E5%85%A5%E6%A0%87%E8%AE%B0"><span class="toc-text">15.4.3插入标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-4-4%E6%BB%9A%E5%8A%A8"><span class="toc-text">15.4.4滚动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%EF%BC%9ADOM2-%E5%92%8C-DOM3"><span class="toc-text">16：DOM2 和 DOM3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1DOM-%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-text">16.1DOM 的演进</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-1-1XML-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">16.1.1XML 命名空间（了解）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-2%E5%85%B6%E4%BB%96%E5%8F%98%E5%8C%96"><span class="toc-text">16.2其他变化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2%E6%A0%B7%E5%BC%8F"><span class="toc-text">16.2样式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-2-1%E5%AD%98%E5%8F%96%E5%85%83%E7%B4%A0%E6%A0%B7%E5%BC%8F"><span class="toc-text">16.2.1存取元素样式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-2-2%E6%93%8D%E4%BD%9C%E6%A0%B7%E5%BC%8F%E8%A1%A8"><span class="toc-text">16.2.2操作样式表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-2-3%E5%85%83%E7%B4%A0%E5%B0%BA%E5%AF%B8"><span class="toc-text">16.2.3元素尺寸</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3%E9%81%8D%E5%8E%86"><span class="toc-text">16.3遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-3-1NodeIterator"><span class="toc-text">16.3.1NodeIterator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-3-2TreeWalker"><span class="toc-text">16.3.2TreeWalker</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4%E8%8C%83%E5%9B%B4%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">16.4范围（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-4-1DOM-%E8%8C%83%E5%9B%B4"><span class="toc-text">16.4.1DOM 范围</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-4-2%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9"><span class="toc-text">16.4.2简单选择</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-4-3%E5%A4%8D%E6%9D%82%E9%80%89%E6%8B%A9"><span class="toc-text">16.4.3复杂选择</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-4-4%E6%93%8D%E4%BD%9C%E8%8C%83%E5%9B%B4"><span class="toc-text">16.4.4操作范围</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-4-5%E8%8C%83%E5%9B%B4%E6%8F%92%E5%85%A5"><span class="toc-text">16.4.5范围插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-4-6%E8%8C%83%E5%9B%B4%E6%8A%98%E5%8F%A0"><span class="toc-text">16.4.6范围折叠</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-4-7%E8%8C%83%E5%9B%B4%E6%AF%94%E8%BE%83"><span class="toc-text">16.4.7范围比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-4-8%E5%A4%8D%E5%88%B6%E8%8C%83%E5%9B%B4"><span class="toc-text">16.4.8复制范围</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-4-9%E6%B8%85%E7%90%86"><span class="toc-text">16.4.9清理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%EF%BC%9A%E4%BA%8B%E4%BB%B6"><span class="toc-text">17：事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-1%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-text">17.1事件流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#17-1-1%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-text">17.1.1事件冒泡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-1-2%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7"><span class="toc-text">17.1.2事件捕获</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-1-3DOM-%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-text">17.1.3DOM 事件流</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-text">17.2事件处理程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#17-2-1HTML-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-text">17.2.1HTML 事件处理程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-2-2DOM-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-text">17.2.2DOM 事件处理程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-2-3DOM2%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-text">17.2.3DOM2处理：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-2-4IE-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-text">17.2.4IE 事件处理程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-2-5%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-text">17.2.5跨浏览器事件处理程序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-3%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">17.3事件对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#17-3-1DOM-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">17.3.1DOM 事件对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-3-2IE-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">17.3.2IE 事件对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-3-3%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">17.3.3跨浏览器事件对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">17.4事件类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#17-4-1%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8B%E4%BB%B6"><span class="toc-text">17.4.1用户界面事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-4-2%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6"><span class="toc-text">17.4.2焦点事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-4-3%E9%BC%A0%E6%A0%87%E5%92%8C%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6"><span class="toc-text">17.4.3鼠标和滚轮事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-4-4%E9%94%AE%E7%9B%98%E4%B8%8E%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6"><span class="toc-text">17.4.4键盘与输入事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-4-5%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6"><span class="toc-text">17.4.5合成事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-4-7HTML5-%E4%BA%8B%E4%BB%B6"><span class="toc-text">17.4.7HTML5 事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-4-8%E8%AE%BE%E5%A4%87%E4%BA%8B%E4%BB%B6"><span class="toc-text">17.4.8设备事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-4-9%E8%A7%A6%E6%91%B8%E5%8F%8A%E6%89%8B%E5%8A%BF%E4%BA%8B%E4%BB%B6"><span class="toc-text">17.4.9触摸及手势事件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-5%E5%86%85%E5%AD%98%E4%B8%8E%E6%80%A7%E8%83%BD"><span class="toc-text">17.5内存与性能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#17-5-1%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-text">17.5.1事件委托</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-5-2%E5%88%A0%E9%99%A4%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-text">17.5.2删除事件处理程序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-6%E6%A8%A1%E6%8B%9F%E4%BA%8B%E4%BB%B6"><span class="toc-text">17.6模拟事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#17-6-1DOM-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E6%8B%9F"><span class="toc-text">17.6.1DOM 事件模拟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-6-2IE-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E6%8B%9F"><span class="toc-text">17.6.2IE 事件模拟</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%EF%BC%9A%E5%8A%A8%E7%94%BB%E4%B8%8E-Canvas-%E5%9B%BE%E5%BD%A2"><span class="toc-text">18：动画与 Canvas 图形</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1%E4%BD%BF%E7%94%A8-requestAnimationFrame"><span class="toc-text">18.1使用 requestAnimationFrame</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#18-1-1%E6%97%A9%E6%9C%9F%E5%AE%9A%E6%97%B6%E5%8A%A8%E7%94%BB"><span class="toc-text">18.1.1早期定时动画</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-1-2%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">18.1.2时间间隔的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-1-3requestAnimationFrame"><span class="toc-text">18.1.3requestAnimationFrame</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-1-4cancelAnimationFrame"><span class="toc-text">18.1.4cancelAnimationFrame</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-1-5%E9%80%9A%E8%BF%87-requestAnimationFrame-%E8%8A%82%E6%B5%81"><span class="toc-text">18.1.5通过 requestAnimationFrame 节流</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-2%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%94%BB%E5%B8%83%E5%8A%9F%E8%83%BD"><span class="toc-text">18.2基本的画布功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-3-2D-%E7%BB%98%E5%9B%BE%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">18.3 2D 绘图上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#18-3-1%E5%A1%AB%E5%85%85%E5%92%8C%E6%8F%8F%E8%BE%B9"><span class="toc-text">18.3.1填充和描边</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-3-2%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2"><span class="toc-text">18.3.2绘制矩形</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-3-3%E7%BB%98%E5%88%B6%E8%B7%AF%E5%BE%84"><span class="toc-text">18.3.3绘制路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-3-4%E7%BB%98%E5%88%B6%E6%96%87%E6%9C%AC"><span class="toc-text">18.3.4绘制文本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-3-5%E5%8F%98%E6%8D%A2"><span class="toc-text">18.3.5变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-3-6%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F"><span class="toc-text">18.3.6绘制图像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-3-7%E9%98%B4%E5%BD%B1"><span class="toc-text">18.3.7阴影</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-3-8%E6%B8%90%E5%8F%98"><span class="toc-text">18.3.8渐变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-3-9%E5%9B%BE%E6%A1%88"><span class="toc-text">18.3.9图案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-3-10%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE"><span class="toc-text">18.3.10图像数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-3-11%E5%90%88%E6%88%90"><span class="toc-text">18.3.11合成</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-4WebGL-%E4%B8%8A%E4%B8%8B%E6%96%87-%E4%BA%86%E8%A7%A3"><span class="toc-text">18.4WebGL 上下文(了解)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#WebGL-%E5%9F%BA%E7%A1%80"><span class="toc-text">WebGL 基础</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%EF%BC%9A%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC"><span class="toc-text">19：表单脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#19-1%E8%A1%A8%E5%8D%95%E5%9F%BA%E7%A1%80"><span class="toc-text">19.1表单基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#19-1-1%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95"><span class="toc-text">19.1.1提交表单</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-1-2%E9%87%8D%E7%BD%AE%E8%A1%A8%E5%8D%95"><span class="toc-text">19.1.2重置表单</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-1-3%E8%A1%A8%E5%8D%95%E5%AD%97%E6%AE%B5"><span class="toc-text">19.1.3表单字段</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-2%E6%96%87%E6%9C%AC%E6%A1%86%E7%BC%96%E8%BE%91"><span class="toc-text">19.2文本框编辑</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#19-2-1%E9%80%89%E6%8B%A9%E6%96%87%E6%9C%AC"><span class="toc-text">19.2.1选择文本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-2-2%E8%BE%93%E5%85%A5%E8%BF%87%E6%BB%A4"><span class="toc-text">19.2.2输入过滤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-2-3%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2"><span class="toc-text">19.2.3自动切换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-2-4HTML5-%E7%BA%A6%E6%9D%9F%E9%AA%8C%E8%AF%81-API"><span class="toc-text">19.2.4HTML5 约束验证 API</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-3%E9%80%89%E6%8B%A9%E6%A1%86%E7%BC%96%E7%A8%8B"><span class="toc-text">19.3选择框编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#19-3-1%E9%80%89%E9%A1%B9%E5%A4%84%E7%90%86"><span class="toc-text">19.3.1选项处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-3-2%E6%B7%BB%E5%8A%A0%E9%80%89%E9%A1%B9"><span class="toc-text">19.3.2添加选项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-3-3%E7%A7%BB%E9%99%A4%E9%80%89%E9%A1%B9"><span class="toc-text">19.3.3移除选项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-3-4%E7%A7%BB%E5%8A%A8%E5%92%8C%E9%87%8D%E6%8E%92%E9%80%89%E9%A1%B9"><span class="toc-text">19.3.4移动和重排选项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-4%E8%A1%A8%E5%8D%95%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">19.4表单序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-5%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91"><span class="toc-text">19.5富文本编辑</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#19-5-2%E4%B8%8E%E5%AF%8C%E6%96%87%E6%9C%AC%E4%BA%A4%E4%BA%92"><span class="toc-text">19.5.2与富文本交互</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-5-3%E5%AF%8C%E6%96%87%E4%BB%B6%E9%80%89%E6%8B%A9"><span class="toc-text">19.5.3富文件选择</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-5-4%E9%80%9A%E8%BF%87%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E5%AF%8C%E6%96%87%E6%9C%AC"><span class="toc-text">19.5.4通过表单提交富文本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%EF%BC%9AJavaScript-API"><span class="toc-text">20：JavaScript API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%EF%BC%9A%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E6%8A%80%E6%9C%AF"><span class="toc-text">三：开发实用技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-text">21：错误处理与调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%EF%BC%9A%E5%A4%84%E7%90%86-XML-23%EF%BC%9AJSON"><span class="toc-text">22：处理 XML + 23：JSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%EF%BC%9A%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B5%84%E6%BA%90"><span class="toc-text">24：网络请求与远程资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8"><span class="toc-text">25：客户端存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%EF%BC%9A%E6%A8%A1%E5%9D%97"><span class="toc-text">26：模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%EF%BC%9A%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B"><span class="toc-text">27：工作者线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%EF%BC%9A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">28：最佳实践</span></a></li></ol></li></ol></div></div></div>


</div>


    </aside>
    <div class='l_main'>
      

      

<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a><span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a></div><div id="post-meta">Posted on&nbsp;<time datetime="2023-09-24T14:16:23.000Z">2023-09-24</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>JavaScript 笔记</span></h1>
<h1 id="《JS红宝书》"><a href="#《JS红宝书》" class="headerlink" title="《JS红宝书》"></a>《JS红宝书》</h1><p>概述:</p>
<p>js红宝书是每个前端开发者都应该听过的一本书,本文档是作者阅读该书后记录所得,有结合红宝书，网上部分前辈的笔记,以及个人平时积累的知识点.希望能做到对js的查漏补缺。</p>
<h2 id="一：基础部分"><a href="#一：基础部分" class="headerlink" title="一：基础部分"></a>一：基础部分</h2><h3 id="01：什么是-JavaScript"><a href="#01：什么是-JavaScript" class="headerlink" title="01：什么是 JavaScript"></a>01：什么是 JavaScript</h3><h4 id="js-包含三部分："><a href="#js-包含三部分：" class="headerlink" title="js 包含三部分："></a><code>js</code> 包含三部分：</h4><ol>
<li><p><code>ECMAScript</code> 也就是 <code>es</code>：<code>es</code> 被称为是 <code>js</code> 的核心，它描述了js的</p>
<ul>
<li><p>语法</p>
</li>
<li><p>类型</p>
</li>
<li><p>语句</p>
</li>
<li><p>关键字(back,case,catch等等)</p>
</li>
<li><p>保留字(enum,await等)</p>
</li>
<li><p>操作符</p>
</li>
<li><p>全局对象<br>es只是对实现这个规范描述的所有方面的一门语言的称呼,js实现了es.。还有一些其他的语言也同样实现了es</p>
<p>如Adobe 为其产品flash(一种播放器,播放flash文档)开发的ActionScript(简称AS)脚本语言</p>
</li>
</ul>
<p>es在 <code>2015 年</code> 之后几乎保持着每年发布一版的频率。其中 <code>2015 年</code> 发布的 <code>ESMAScript 第六版</code> 被称为 <code>ES6</code>，如果用年来表示的话就是 <code>ES 2015</code>。后续也同样维持着同样的叫法，比如：<code>2016 年</code> 发布第七版，被称作 <code>ES7</code> 或 <code>ES 2016</code></p>
</li>
<li><p><code>DOM</code>： 文档对象模型。它是一组应用编程接口的 <code>API</code>，可以直接控制整个页面的节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dom产生的背景:</span><br><span class="line"> 由于微软跟网景采用不同的开发思路开发DHTML(动态HTML),开发者写一个HTML就不可以在不同浏览器运行,为了保持Web跨平台的本性,W3C制定了DOM标准</span><br><span class="line"> DHTML:</span><br><span class="line"> 在DHTML中, 将所有的HTML元素都使用一个一个的JS对象来进行表示, 使用对象来表示元素本身, 使用对象之间的包含关系来表示元素之间的层级关系.</span><br><span class="line">　　使用一个文档结构树来表示整个HTML文档.</span><br><span class="line">　　对象上可以设计属性和方法, 通过操作对象上的属性或方法, 可以间接的操作页面中的元素.</span><br><span class="line">　　利用这种方式将HTML、CSS、JavaScript整合在了一起，形成了现在的DHTML技术.</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">	&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">		function changecolor()</span><br><span class="line">	&#123;</span><br><span class="line">		document.getElementById(&#x27;header&#x27;).style.color=&quot;red&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;h1 id=&quot;header&quot; onclick=&quot;changecolor()&quot;&gt;Click on this text&lt;/h1&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>BOM</code>：它表示 <strong>浏览器对象模型</strong> 的 <code>API</code>。主要用来操作浏览器窗口。比如我们常用的 <code>window</code> 对象，就属于 <code>BOM</code> 对象。</p>
</li>
</ol>
<h4 id="拓展与注意点"><a href="#拓展与注意点" class="headerlink" title="拓展与注意点:"></a>拓展与注意点:</h4><h5 id="JavaScript与Node-js"><a href="#JavaScript与Node-js" class="headerlink" title="JavaScript与Node.js:"></a>JavaScript与Node.js:</h5><p>Node.js官网解释:Node.js是一个开源的、跨平台的 JavaScript 运行时环境。所以node.js不是一门语言</p>
<p>JavaScript的组成：</p>
<ul>
<li>ECMAScript（语言基础，如：语法、数据类型结构以及一些内置对象）</li>
<li>DOM（一些操作页面元素的方法）</li>
<li>BOM（一些操作浏览器的方法）</li>
</ul>
<p>Node.js的组成：</p>
<ul>
<li>ECMAScript（语言基础，如：语法、数据类型结构以及一些内置对象）</li>
<li>Node.js内置模块：文件系统I&#x2F;O、网络（HTTP、TCP、UDP、DNS、TLS&#x2F;SSL等）、二进制数据流、加密算法、数据流等等</li>
</ul>
<h3 id="02：HTML-中的-JavaScript"><a href="#02：HTML-中的-JavaScript" class="headerlink" title="02：HTML 中的 JavaScript"></a>02：HTML 中的 JavaScript</h3><h4 id="使用-lt-script-gt-元素的方式："><a href="#使用-lt-script-gt-元素的方式：" class="headerlink" title="使用 &lt;script&gt; 元素的方式："></a><strong>使用 <code>&lt;script&gt;</code> 元素的方式：</strong></h4><p>引入 <code>&lt;script&gt;</code> 标签一般可以在两个地方做：</p>
<ol>
<li>在 <code>header</code> 标签的最后：但是这样会意味着，浏览器必须把所有 <code>JavaScript</code> 代码都下载、解析完成后，才能开始渲染页面。这就会导致在最初时页面空白。</li>
<li>在 <code>body</code> 标签的最后：这样就不会影响页面渲染了。</li>
</ol>
<h5 id="script属性"><a href="#script属性" class="headerlink" title="script属性:"></a>script属性:</h5><p>总共8个属性,不过有一些已经被废弃了</p>
<ul>
<li>src :  表示包含要执行的代码的外部文件。</li>
<li>async: 异步加载js</li>
<li>defer: 等待html解析和显示后,在加载js</li>
<li>charset: 指定src属性指定的代码字符集,默认utf-8,很少使用</li>
<li>crossorigin: 配置相关请求 CORS（跨域资源共享）设置。默认不适用 CORS。crossorigin&#x3D;”anonymous” 配置文件请求不必设置凭据标志。</li>
<li>integrity : 允许比对接收到和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。</li>
<li>language: 废弃。最初用于表示代码块中的脚本语言（如“JavaScript”、“JavaScript 1.2”或“VBScript”）。大多数浏览器都会忽略这个属性，不应该再使用它。</li>
<li>type : 可选。代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型）。按照惯例，这个值始终都是 text&#x2F;javascript ，尽管 text&#x2F;javascript 和 ecmascript 都已经废弃了。JavaScript 文件的 MIME 类型通常是 application&#x2F;x-javascript ，不过给 type 属性这个值有可能 导致脚本被忽略。</li>
</ul>
<h4 id="行内脚本和外部脚本的区别："><a href="#行内脚本和外部脚本的区别：" class="headerlink" title="行内脚本和外部脚本的区别："></a>行内脚本和外部脚本的区别：</h4><p>所谓行内脚本就是直接把 <code>JS</code> 写到 <code>html</code> 文件里面。这种方式肯定是不被推荐的。推荐使用外部脚本，也就是：以 <code>script</code> 标签的形式引入。</p>
<h4 id="js-不可用时，如何保证用户体验："><a href="#js-不可用时，如何保证用户体验：" class="headerlink" title="js  不可用时，如何保证用户体验："></a><code>js</code>  不可用时，如何保证用户体验：</h4><p> <code>html</code> 提供了一个 <noscript></noscript> 标签，可以在 不支持脚本运行 的浏览器中显示。</p>
<h4 id="拓展与注意点-1"><a href="#拓展与注意点-1" class="headerlink" title="拓展与注意点:"></a>拓展与注意点:</h4><p>使用了src属性的script元素,不能再在标签中包含其他语句,如果<strong>两者都提供</strong>的话,浏览器只会<strong>下载并执行脚本文件,忽略行内代码</strong></p>
<h3 id="03：语言基础"><a href="#03：语言基础" class="headerlink" title="03：语言基础"></a>03：语言基础</h3><h4 id="3-1语法"><a href="#3-1语法" class="headerlink" title="3.1语法"></a>3.1语法</h4><p>区分大小写</p>
<p>标识符:以字母,下划线,$开头</p>
<h4 id="3-2关键字与保留字"><a href="#3-2关键字与保留字" class="headerlink" title="3.2关键字与保留字"></a>3.2关键字与保留字</h4><p>关键字(back,case,catch等等)</p>
<p>保留字(enum,await等)</p>
<h4 id="3-3变量"><a href="#3-3变量" class="headerlink" title="3.3变量"></a>3.3变量</h4><p><code>var</code>、<code>let</code>、<code>const</code>三者区别可以围绕下面五点展开：</p>
<h5 id="一-变量提升"><a href="#一-变量提升" class="headerlink" title="(一)变量提升"></a>(一)变量提升</h5><p>var<code>声明的变量存在变量提升，即变量可以在声明之前调用，值为</code>undefined</p>
<p><code>let</code>和<code>const</code>不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</p>
<h5 id="二-暂时性死区"><a href="#二-暂时性死区" class="headerlink" title="(二)暂时性死区"></a>(二)暂时性死区</h5><p><code>var</code>不存在暂时性死区</p>
<p><code>let</code>和<code>const</code>存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p>
<h5 id="三-块级作用域"><a href="#三-块级作用域" class="headerlink" title="(三)块级作用域"></a>(三)块级作用域</h5><p><code>var</code>不存在块级作用域</p>
<p><code>let</code>和<code>const</code>存在块级作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在for循环中使用let声明变量好,就是因为块级作用域的原因</span><br><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line"> setTimeout(() =&gt; &#123;console.log(i)&#125;, 400); //5 5 5 5 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line"> setTimeout(() =&gt; &#123;console.log(i)&#125;, 400); //0 1 2 3 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四-重复声明"><a href="#四-重复声明" class="headerlink" title="(四)重复声明"></a>(四)重复声明</h5><p><code>var</code>允许重复声明变量</p>
<p><code>let</code>和<code>const</code>在同一作用域不允许重复声明变量</p>
<h5 id="五-修改声明的变量"><a href="#五-修改声明的变量" class="headerlink" title="(五)修改声明的变量"></a>(五)修改声明的变量</h5><p><code>var</code>和<code>let</code>可以</p>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变</p>
<h4 id="3-4数据类型"><a href="#3-4数据类型" class="headerlink" title="3.4数据类型"></a>3.4数据类型</h4><h5 id="一-总共八种"><a href="#一-总共八种" class="headerlink" title="(一)总共八种"></a>(一)总共八种</h5><p>1.七种基本数据类型</p>
<h6 id="1-Number"><a href="#1-Number" class="headerlink" title="1)Number"></a>1)Number</h6><ul>
<li>存在取值范围:</li>
</ul>
<p>在大多数浏览器中为(5e-324~1.797e+308),即为(-Infinity到Infinity).</p>
<p>可以使用isFinite()函数判断一个数是否是有限大,返回true或者false</p>
<p>如果不是有限大,可以使用Bigint来记录该数字</p>
<ul>
<li><p>只能使用isNaN(数字)来判断一个数是不是NaN</p>
</li>
<li><p>其他函数</p>
<p>Number(),parseInt(),parseFloat()</p>
</li>
</ul>
<h6 id="2-String"><a href="#2-String" class="headerlink" title="2)String"></a>2)String</h6><ul>
<li>可以用双引号(“”),单引号(‘’),反引号(&#96;&#96;)表示</li>
<li>可以在模板字面(模板字符串),中插入变量</li>
</ul>
<h6 id="3-Boolean"><a href="#3-Boolean" class="headerlink" title="3)Boolean"></a>3)Boolean</h6><h6 id="4-Undefined"><a href="#4-Undefined" class="headerlink" title="4)Undefined"></a>4)Undefined</h6><h6 id="5-Null"><a href="#5-Null" class="headerlink" title="5)Null"></a>5)Null</h6><h6 id="6-Symbol"><a href="#6-Symbol" class="headerlink" title="6)Symbol"></a>6)Symbol</h6><p>它的功能类似于一种标识唯一性的ID。通常情况下，我们可以通过调用Symbol()函数来创建一个Symbol实例：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let <span class="attr">s1</span> = Symbol()</span><br></pre></td></tr></table></figure>

<p>或者，你也可以在调用Symbol()函数时传入一个可选的字符串参数，相当于给你创建的Symbol实例一个描述信息：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let <span class="attr">s2</span> = Symbol(<span class="string">&#x27;another symbol&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>同时每个Symbol实例都是唯一的。因此，当你比较两个Symbol实例的时候，将总会返回false：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let s1 = Symbol()</span><br><span class="line">let s2 = Symbol(&#x27;another symbol&#x27;)</span><br><span class="line">let s3 = Symbol(&#x27;another symbol&#x27;)</span><br><span class="line"></span><br><span class="line">s1 === s2 // false</span><br><span class="line">s2 === s3 // false</span><br><span class="line">//但是可以通过这样创建一个相同的symbol</span><br><span class="line">let gs1 = Symbol.for(&#x27;global_symbol_1&#x27;)  //注册一个全局Symbol</span><br><span class="line">let gs2 = Symbol.for(&#x27;global_symbol_1&#x27;)  //获取全局Symbol</span><br><span class="line"></span><br><span class="line">gs1 === gs2  // true</span><br></pre></td></tr></table></figure>

<p>使用Symbol比较常用的三种场景:</p>
<ul>
<li><p>使用Symbol来作为对象属性名(key)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">   [Symbol(&#x27;name&#x27;)]: &#x27;一斤代码&#x27;,</span><br><span class="line">   age: 18,</span><br><span class="line">   title: &#x27;Engineer&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.keys(obj)   // [&#x27;age&#x27;, &#x27;title&#x27;]</span><br><span class="line"></span><br><span class="line">for (let p in obj) &#123;</span><br><span class="line">   console.log(p)   // 分别会输出：&#x27;age&#x27; 和 &#x27;title&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(obj)   // [&#x27;age&#x27;, &#x27;title&#x27;]</span><br><span class="line">JSON.stringify(obj)  // &#123;&quot;age&quot;:18,&quot;title&quot;:&quot;Engineer&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>Symbol类型的key是不能通过Object.keys()或者for…in来枚举的，它未被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。</p>
<p>也正因为这样一个特性，当使用JSON.stringify()将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外,</p>
<p>只能使用特定的api才能访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用Object的API</span><br><span class="line">Object.getOwnPropertySymbols(obj) // [Symbol(name)]</span><br><span class="line"></span><br><span class="line">// 使用新增的反射API</span><br><span class="line">Reflect.ownKeys(obj) // [Symbol(name), &#x27;age&#x27;, &#x27;title&#x27;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Symbol来替代常量,消除魔术字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const shapeType = &#123;</span><br><span class="line">  triangle: &#x27;Triangle&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">function getArea(shape, options) &#123;</span><br><span class="line">  let area = 0;</span><br><span class="line">  switch (shape) &#123;</span><br><span class="line">    case shapeType.triangle:</span><br><span class="line">      ...</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  return area;</span><br><span class="line">&#125;</span><br><span class="line">getArea(shapeType.triangle, &#123;...&#125;);</span><br><span class="line">//如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用 Symbol 值。只需要shapeType.triangle的值设为一个 Symbol</span><br><span class="line">const shapeType = &#123;</span><br><span class="line">  triangle: Symbol()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Symbol定义类的私有属性&#x2F;方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const _radius = Symbol();</span><br><span class="line">const _draw = Symbol();</span><br><span class="line"></span><br><span class="line">class Circle &#123;</span><br><span class="line">  constructor(radius) &#123;</span><br><span class="line">    // 私有属性</span><br><span class="line">    this[_radius] = radius;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 私有方法</span><br><span class="line">  [_draw] () &#123;</span><br><span class="line">    console.log(&#x27;draw&#x27;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c = new Circle(1);</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="7-Bigint"><a href="#7-Bigint" class="headerlink" title="7)Bigint"></a>7)Bigint</h6><p>它在某些方面类似于 Number，但是也有几个关键的不同点：不能用于 Math 对象中的方法；不能和任何 Number 实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为 <code>BigInt</code> 变量在转换成 Number 变量时可能会丢失精度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const theBiggestInt = 9007199254740991n;</span><br><span class="line">const alsoHuge = BigInt(9007199254740991);</span><br></pre></td></tr></table></figure>

<p>2.一种引用数据类型</p>
<h6 id="8-Object-包括Array-Function-等"><a href="#8-Object-包括Array-Function-等" class="headerlink" title="8).Object(包括Array Function 等)"></a>8).Object(包括Array Function 等)</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const o = new Object()</span><br></pre></td></tr></table></figure>

<p>每个object实例多有以下七种属性或者方法</p>
<ul>
<li>constructor:指向创建当前对象的函数,如上面的o.constructor为Object()函数</li>
<li>hasOwnProperty:用于判断当前对象实例(不是原型)上是否存在某个属性,如:o.hasOwnProperty(“name”)</li>
<li>isPrototypeof():用于判断当前对象是否是另一个对象的原型</li>
<li>propertyIsEnumerable():用于判断给定的属性是否可以使用for…in枚举</li>
<li>toLocaleString():返回对象的字符串表示,该字符串表示对象所在本地化执行环境</li>
<li>toString():返回对象的字符串</li>
<li>toValue():返回对象的字符串,数值,布尔值,通常与toString()类似</li>
</ul>
<h5 id="二-鉴定方法"><a href="#二-鉴定方法" class="headerlink" title="(二)鉴定方法"></a>(二)鉴定方法</h5><p>1.typeof(typeof XXX)</p>
<p>可鉴别 Number,String,Boolean,Undefined,Symbol,Bigint,function</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof null //object</span><br></pre></td></tr></table></figure>

<p>2.&#x3D;&#x3D;&#x3D;</p>
<p>可鉴别undefined,null</p>
<p>3.instanceof(a instanceof Array)</p>
<p>判断对象具体类型,返回true&#x2F;false</p>
<h4 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5 操作符"></a>3.5 操作符</h4><h5 id="3-5-1-一元操作符"><a href="#3-5-1-一元操作符" class="headerlink" title="3.5.1 一元操作符"></a>3.5.1 一元操作符</h5><p>++,–</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//注意a++与++a,两者对a来说多是加一</span><br><span class="line">let a = 2</span><br><span class="line">let num = a++ + 20 //22</span><br><span class="line">let num1 = ++a + 20 //23</span><br></pre></td></tr></table></figure>

<h5 id="3-5-2-位操作符"><a href="#3-5-2-位操作符" class="headerlink" title="3.5.2 位操作符"></a>3.5.2 位操作符</h5><p>位操作符一向是很多小伙伴不太熟悉的领域。所谓的 “位”，指的是 <strong>操作内存中表示数据的比特（位）</strong>。一般以 <code>32 位</code> 的整数进行表示。</p>
<p>这里的每一位都代表 <strong>2 的幂</strong>， 第一位（称为第 0 位）表示 <code>2^0</code> ，第二位表示 <code>2^1</code> ，依此类推。</p>
<p>如果一个位是空的，则以<code>0</code>填充，相当于忽略不计。<br>除此之外，作者还在书中提到了 <code>7</code> 种按位运算。</p>
<ol>
<li>按位非：用波浪符（~）表示，它的作用是返回数值的一补数。即：<strong>由0变为1</strong>。</li>
<li>按位与(&amp;)：按位与操作在两个位都是 1 时返回 1，在任何一位是 0 时返回 0。</li>
<li>按位或(|)：按位或操作在至少一位是 1 时返回 1，两位都是 0 时返回 0。</li>
<li>按位异或(^)：按位异或与按位或的区别是，它只在一位上是 1 的时候返回 1（两位都是 1 或 0，则返回 0）。</li>
<li>左移(&lt;&lt;)：按照指定的位数将数值的所有位向左移动</li>
<li>有符号右移(&gt;&gt;)：会将数值的所有 32 位都向右移，同时保留符号</li>
<li>无符号右移(&gt;&gt;&gt;)：会将数值的所有 32 位都向右移</li>
</ol>
<h5 id="3-5-3-布尔操作符"><a href="#3-5-3-布尔操作符" class="headerlink" title="3.5.3 布尔操作符"></a>3.5.3 布尔操作符</h5><p>&amp;&amp;,||,!</p>
<h5 id="3-5-4-乘性操作符"><a href="#3-5-4-乘性操作符" class="headerlink" title="3.5.4 乘性操作符"></a>3.5.4 乘性操作符</h5><ul>
<li></li>
</ul>
<h5 id="3-5-5-指数操作符"><a href="#3-5-5-指数操作符" class="headerlink" title="3.5.5 指数操作符"></a>3.5.5 指数操作符</h5><p>es7新加:</p>
<ul>
<li>3**2 &#x3D;&#x3D;&#x3D; 9</li>
<li>Math.pow(3, 2) &#x3D;&#x3D;&#x3D; 9</li>
<li>指数赋值操作符 (3 **&#x3D; 2) &#x3D;&#x3D;&#x3D; 9</li>
</ul>
<h5 id="3-5-6-加性操作符"><a href="#3-5-6-加性操作符" class="headerlink" title="3.5.6 加性操作符"></a>3.5.6 加性操作符</h5><p>+:涉及到隐式转换,如果是字符串相加,叠加字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a = 5 + &#x27;5&#x27; //&#x27;55&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="3-5-7-关系操作符"><a href="#3-5-7-关系操作符" class="headerlink" title="3.5.7 关系操作符"></a>3.5.7 关系操作符</h5><p>&lt;,&gt;,&lt;&#x3D;,&gt;&#x3D;</p>
<h5 id="3-5-8-相等操作符"><a href="#3-5-8-相等操作符" class="headerlink" title="3.5.8 相等操作符"></a>3.5.8 相等操作符</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==, !=, ===, !==</span><br></pre></td></tr></table></figure>

<h5 id="3-5-9-条件操作符-三元操作符"><a href="#3-5-9-条件操作符-三元操作符" class="headerlink" title="3.5.9 条件操作符(三元操作符)"></a>3.5.9 条件操作符(三元操作符)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a = b ? &#x27;1&#x27; : &#x27;2&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="3-5-10-赋值操作符"><a href="#3-5-10-赋值操作符" class="headerlink" title="3.5.10 赋值操作符"></a>3.5.10 赋值操作符</h5><p>&#x3D;</p>
<h5 id="3-5-11-逗号操作符"><a href="#3-5-11-逗号操作符" class="headerlink" title="3.5.11 逗号操作符"></a>3.5.11 逗号操作符</h5><p>在一行语句中执行多个操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a = 1, b = 2, c = 3</span><br></pre></td></tr></table></figure>

<h4 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6 语句"></a>3.6 语句</h4><h5 id="3-6-1-if语句"><a href="#3-6-1-if语句" class="headerlink" title="3.6.1 if语句"></a>3.6.1 if语句</h5><h5 id="3-6-2-do…while语句"><a href="#3-6-2-do…while语句" class="headerlink" title="3.6.2 do…while语句"></a>3.6.2 do…while语句</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//循环体内代码至少执行一次</span><br><span class="line">let i = 0</span><br><span class="line">do &#123;</span><br><span class="line">  i += 2</span><br><span class="line">&#125; while(i &lt; 10)</span><br></pre></td></tr></table></figure>

<h5 id="3-6-3-while语句"><a href="#3-6-3-while语句" class="headerlink" title="3.6.3 while语句"></a>3.6.3 while语句</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let i = 0</span><br><span class="line">while(i &lt; 10) &#123;</span><br><span class="line">  i += 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-6-4-for语句-for循环"><a href="#3-6-4-for语句-for循环" class="headerlink" title="3.6.4 for语句(for循环)"></a>3.6.4 for语句(for循环)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let count = 0</span><br><span class="line">for(let i = 0; i &lt; count; i++ )&#123;</span><br><span class="line">	//语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-6-5-for-in语句"><a href="#3-6-5-for-in语句" class="headerlink" title="3.6.5 for-in语句"></a>3.6.5 for-in语句</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//遍历对象,要注意es对象中属性是无序的,如:</span><br><span class="line">const o = &#123;&#x27;1&#x27;: 1&#125;</span><br><span class="line">o.b = 2</span><br><span class="line">o[2] = 3</span><br><span class="line">o.a = 4</span><br><span class="line">console.log(o)</span><br><span class="line">//在对象中是,会先将数字按照顺序排列,其他的会按照添加顺序添加</span><br><span class="line">&#123;1: 1, 2: 3, b: 2, a: 4&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(const i in window) &#123;</span><br><span class="line">  document.writer(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-6-6-for-of语句"><a href="#3-6-6-for-of语句" class="headerlink" title="3.6.6 for-of语句"></a>3.6.6 for-of语句</h5><p>for-of循环会按照可迭代对象的next()方法产生值的顺序迭代元素</p>
<h5 id="3-6-7-标签语句"><a href="#3-6-7-标签语句" class="headerlink" title="3.6.7 标签语句"></a>3.6.7 标签语句</h5><p>可以用下列语句给语句加标签，以便以后调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label : statement</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start : i = 5;</span><br></pre></td></tr></table></figure>

<p>break 语句和 continue 语句都可以与有标签的语句联合使用，返回代码中的特定位置。</p>
<p>通常，当循环内部还有循环时，会这样做，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span> outermost;</span><br><span class="line">  &#125;</span><br><span class="line">  iNum++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(iNum);	<span class="comment">//输出 &quot;55&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，标签 outermost 表示的是第一个 for 语句。正常情况下，每个 for 语句执行 10 次代码块，这意味着 iNum++ 正常情况下将被执行 100 次，在执行完成时，iNum 应该等于 100。这里的 break 语句有一个参数，即停止循环后要跳转到的语句的标签。这样 break 语句不止能跳出内部 for 语句（即使用变量 j 的语句），还能跳出外部 for 语句（即使用变量 i 的语句）。因此，iNum 最后的值是 55，因为当 i 和 j 的值都等于 5 时，循环将终止.</p>
<p>由这个demo可以发现,标签语句可读性不高,并不建议在项目中过度使用,会导致代码逻辑过于复杂</p>
<h5 id="3-6-8-break和continue语句"><a href="#3-6-8-break和continue语句" class="headerlink" title="3.6.8 break和continue语句"></a>3.6.8 break和continue语句</h5><h5 id="3-6-9-with语句"><a href="#3-6-9-with语句" class="headerlink" title="3.6.9 with语句"></a>3.6.9 with语句</h5><p>with&#96;语句的用途是将代码作用域设置为特定的对象。感觉重置表单可以使用,蛮实用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 如果想要改变 obj 中每一项的值，一般写法可能会是这样：</span><br><span class="line">// 重复写了3次的“obj”</span><br><span class="line">obj.a = 2;</span><br><span class="line">obj.b = 3;</span><br><span class="line">obj.c = 4;</span><br><span class="line">// 而用了 with 的写法，会有一个简单的快捷方式</span><br><span class="line">with (obj) &#123;</span><br><span class="line">	a = 3;</span><br><span class="line">	b = 4;</span><br><span class="line">	c = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-6-10-switch语句"><a href="#3-6-10-switch语句" class="headerlink" title="3.6.10 switch语句"></a>3.6.10 switch语句</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式) &#123;</span><br><span class="line">     case n:</span><br><span class="line">        代码块</span><br><span class="line">        break;</span><br><span class="line">     case n:</span><br><span class="line">        代码块</span><br><span class="line">        break;</span><br><span class="line">     default:</span><br><span class="line">        默认代码块</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="04：变量、作用域与内存"><a href="#04：变量、作用域与内存" class="headerlink" title="04：变量、作用域与内存"></a>04：变量、作用域与内存</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ol>
<li>原始数据类型：数据保存在栈中，通过变量直接引用</li>
<li>引用数据类型：数据保存在堆中，变量无法直接引用到堆，所以需要在栈中保存一个内存地址，通过内存地址指向堆内存。</li>
</ol>
<h4 id="执行上下文对象"><a href="#执行上下文对象" class="headerlink" title="执行上下文对象"></a>执行上下文对象</h4><h5 id="代码分类"><a href="#代码分类" class="headerlink" title="代码分类"></a>代码分类</h5><ul>
<li>全局代码</li>
<li>函数代码</li>
</ul>
<h5 id="全局执行上下文"><a href="#全局执行上下文" class="headerlink" title="全局执行上下文"></a>全局执行上下文</h5><ul>
<li>在执行全局代码前将window确定为全局执行上下文</li>
<li>对全局数据进行预处理</li>
</ul>
<p>​    - var定义的全局变量&#x3D;&#x3D;&gt;undefined, 添加为window的属性</p>
<p>​    - function声明的全局函数&#x3D;&#x3D;&gt;赋值(fun), 添加为window的方法</p>
<p>​    - this&#x3D;&#x3D;&gt;赋值(window)</p>
<ul>
<li><p>开始执行全局代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">function a () &#123;...&#125;</span><br><span class="line">//等于</span><br><span class="line">var a = Undefined</span><br><span class="line">function a () &#123;...&#125;</span><br><span class="line">a = 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h5><ul>
<li>在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象</li>
<li>对局部数据进行预处理</li>
</ul>
<p>​    - 形参变量&#x3D;&gt;赋值(实参)&#x3D;&gt;添加为执行上下文的属性</p>
<p>​    - arguments&#x3D;&#x3D;&gt;赋值(实参列表), 添加为执行上下文的属性</p>
<p>​    - var定义的局部变量&#x3D;&#x3D;&gt;undefined, 添加为执行上下文的属性</p>
<p>​    - function声明的函数 &#x3D;&#x3D;&gt;赋值(fun), 添加为执行上下文的方法</p>
<p>​    - this&#x3D;&#x3D;&gt;赋值(调用函数的对象)</p>
<ul>
<li>开始执行函数体代码</li>
</ul>
<h5 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h5><ol>
<li><p>在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象</p>
</li>
<li><p>在全局执行上下文(window)确定后, 将其添加到栈中(压栈)</p>
</li>
<li><p>在函数执行上下文创建后, 将其添加到栈中(压栈)</p>
</li>
<li><p>在当前函数执行完后,将栈顶的对象移除(出栈)</p>
</li>
<li><p>当所有的代码执行完后, 栈中只剩下window</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//判断一段代码中有多少个执行上下文对象:</span><br><span class="line">看这段代码执行了n次函数,那么这段代码就有n+1个执行上下文(n个函数执行上下文+1个全局上下文)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域</li>
</ul>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>隔离变量，不同作用域下同名变量不会有冲突</li>
</ul>
<h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><h6 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h6><ul>
<li>多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)</li>
<li>查找变量时就是沿着作用域链来查找的</li>
</ul>
<h6 id="查找一个变量的查找规则"><a href="#查找一个变量的查找规则" class="headerlink" title="查找一个变量的查找规则"></a>查找一个变量的查找规则</h6><ul>
<li>在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2</li>
<li>在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3</li>
<li>再次执行2的相同操作, 直到全局作用域, 如果还找不到就报错</li>
</ul>
<h6 id="补充-查找对象的属性"><a href="#补充-查找对象的属性" class="headerlink" title="补充:查找对象的属性"></a>补充:查找对象的属性</h6><p>是沿着对象的原型链查找,一直找到Object()函数的显示原型对象的隐式原型(null),返回undefined</p>
<h4 id="函数执行上下文与作用域对比"><a href="#函数执行上下文与作用域对比" class="headerlink" title="函数执行上下文与作用域对比"></a>函数执行上下文与作用域对比</h4><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul>
<li>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时</li>
</ul>
<p>全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建</p>
<p>函数执行上下文环境是在调用函数时, 函数体代码执行之前创建</p>
<ul>
<li>作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化,上下文环境是动态的, 调用函数时创建, 函数调用结束时上下文环境就会被释放</li>
</ul>
<h5 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h5><p>  上下文环境(对象)是从属于所在的作用域</p>
<h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h4><ol>
<li>引用计数：在 <strong>循环引用</strong> 时出现错误,所以被放弃</li>
<li>标记清理：目前浏览器中最常用的垃圾回收策略,先给离开作用域的值或者值为null自动标记为可回收,在垃圾回收期间(过程是周期的)删除,回收内存.</li>
</ol>
<h5 id="一-内存溢出"><a href="#一-内存溢出" class="headerlink" title="(一)内存溢出"></a>(一)内存溢出</h5><p>一种程序运行时出现的错误,当程序运行需要的内存超过了剩余内存时,就抛出内存溢出错误</p>
<h5 id="二-内存泄露"><a href="#二-内存泄露" class="headerlink" title="(二)内存泄露"></a>(二)内存泄露</h5><p>占用的内存没有及时释放,内存泄露记录就会产生内存溢出</p>
<p>操作:</p>
<ul>
<li>意外的全局变量: 无法被回收</li>
<li>定时器: 未被正确关闭，导致所引用的外部变量无法被释放</li>
<li>闭包</li>
</ul>
<h3 id="05：基本引用类型"><a href="#05：基本引用类型" class="headerlink" title="05：基本引用类型"></a>05：基本引用类型</h3><h4 id="5-1-Data（）"><a href="#5-1-Data（）" class="headerlink" title="5.1 Data（）"></a>5.1 Data（）</h4><p>要创建日期对象，就使用<code>new</code>操作符来调用<code>Date</code>构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br></pre></td></tr></table></figure>

<p>两个辅助方法 <code>Date.parse()</code>和 <code>Date.UTC()</code></p>
<p>**<code>Date.parse()</code>**方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。</p>
<p>比如要创建一个表示“2019年5月23日”的日期对象，可以使用如下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;May 23, 2019&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如果传给<code>Date.parse()</code>的字符串并不表示日期，则该方法会返回NaN。如果直接把表示日期的字符串传给Date构造函数，那么Date会在后台调用Date.parse()。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;May 23, 2019&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这两行代码得到的日期对象相同。</p>
<p>**<code>Date.UTC()</code>**方法也返回日期的毫秒表示，但使用的是跟<code>Date.parse()</code>不同的信息来生成这个值。</p>
<p>传给<code>Date.UTC()</code>的参数是年、零起点月数、日（1-31）、时（0-23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为1日。其他参数的默认值都是0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GMT时间2000年1月1日0点</span></span><br><span class="line"><span class="keyword">let</span> y2k = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">UTC</span>(<span class="number">2000</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// GMT时间2005年5月5日下午5点55分55秒</span></span><br><span class="line"><span class="keyword">let</span> allFives = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">UTC</span>(<span class="number">2005</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">17</span>,<span class="number">55</span>,<span class="number">55</span>))</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>ECMAScript还提供了<code>Date.now()</code>方法，返回表示方法执行时日期和时间的毫秒数。</p>
<p>Date类型的<code>valueOf()</code>方法不反悔字符串，这个方法被重写后返回的是日期的毫秒表示。</p>
<h6 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h6><p>GMT是前世界标准时，UTC是现世界标准时。</p>
<p>UTC 比 GMT更精准，以原子时计时，适应现代社会的精确计时。</p>
<p>但在不需要精确到秒的情况下，二者可以视为等同。</p>
<h4 id="5-2RegExp（）"><a href="#5-2RegExp（）" class="headerlink" title="5.2RegExp（）"></a>5.2RegExp（）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>ECMAScript 通过 <code>RegExp</code> 类型来支持正则表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const expression = / pattern / flags ;</span><br><span class="line">var pattern1 = /[bc]at/i; // 匹配第一个&quot;bat&quot;或&quot;cat&quot;，不区分大小写</span><br><span class="line">var pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;); // 与 pattern1 相同，只不过是使用构造函数创建的</span><br></pre></td></tr></table></figure>

<p>其中的模式 (pattern) 部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、 向前查找以及反向引用。</p>
<p>每个正则表达式都可带有一或多个标志 (flags)，用以标明正则表达式的行为。 正则表达式的匹配模式支持下列 几个标志。</p>
<ul>
<li>g：表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即 停止；</li>
<li>i：表示不区分大小写(case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写；</li>
<li>m：表示多行(multiline)模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模</li>
</ul>
<p>式匹配的项。</p>
<ul>
<li>y:粘贴模式,从最后一个字符开始查找</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var pattern0 = /at/g; // 匹配字符串中所有&quot;at&quot;的实例</span><br><span class="line">var pattern1 = /[bc]at/i; // 匹配第一个&quot;bat&quot;或&quot;cat&quot;，不区分大小写</span><br><span class="line">var pattern2 = /\[bc\]at/i; // 匹配第一个&quot; [bc]at&quot;，不区分大小写</span><br><span class="line">var pattern3 = /.at/gi; // 匹配所有以&quot;at&quot;结尾的 3 个字符的组合，不区分大小写</span><br><span class="line">var pattern4 = /\.at/gi; // 匹配所有&quot;.at&quot;，不区分大小写</span><br></pre></td></tr></table></figure>

<h5 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h5><h6 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h6><p>专门为捕获组而设计的。接受一个参数，即 要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 <code>null</code>。返回的数组虽然是 <code>Array</code> 的实例，但包含两个额外的属性：<code>index</code> 和 <code>input</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;mom and dad and baby&quot;;</span><br><span class="line">var pattern = /mom( and dad( and baby)?)?/gi;</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line"></span><br><span class="line">// [&quot;mom and dad and baby&quot;, &quot; and dad and baby&quot;, &quot; and baby&quot;, index: 0, input: &quot;mom and dad and baby&quot;, groups: undefined]</span><br><span class="line"></span><br><span class="line">alert(matches.index); // 0, 匹配项在字符串中的位置</span><br><span class="line">alert(matches.input); // &quot;mom and dad and baby&quot;, 应用正则表达式的字符串</span><br><span class="line">alert(matches[0]); // 数组第一项与整个模式匹配的字符串</span><br><span class="line">alert(matches[1]); // 数组其他项是与模式中的捕获组匹配的字符串(如果模式中没有捕获组，则该数组只包含一项)。</span><br></pre></td></tr></table></figure>

<p>对于 <code>exec()</code> 方法而言，即使在模式中设置了全局标志(g)，它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用 <code>exec()</code> 将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用 <code>exec()</code> 则都会在字符串中继续查找新匹配项。</p>
<h6 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h6><p>接受一个字符串参数。在模式与该参数匹配的情况下返回 <code>true</code>；否则返回 <code>false</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;000-00-0000&quot;;</span><br><span class="line">var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;</span><br><span class="line">if (pattern.test(text))&#123;</span><br><span class="line">  alert(&quot;The pattern was matched.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="补充"><a href="#补充" class="headerlink" title="补充:"></a>补充:</h5><p>正则与字符串方法结合</p>
<h6 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h6><p>可以将一个字符串拆分为一个数组</p>
<ul>
<li>方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串</li>
<li>这个方法即使不指定全局匹配，也会全都插分</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;1a2b3c4d5e6f7&quot;;</span><br><span class="line">var result = str.split(/[A-z]/);</span><br><span class="line">//[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;]</span><br></pre></td></tr></table></figure>

<h6 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h6><p>可以搜索字符串中是否含有指定内容</p>
<ul>
<li>如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1</li>
<li>它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串</li>
<li>serach()只会查找第一个，即使设置全局匹配也没用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;hello abc hello aec afc&quot;;</span><br><span class="line">result = str.search(/a[bef]c/);</span><br><span class="line">//6</span><br></pre></td></tr></table></figure>

<h6 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h6><p>可以根据正则表达式，从一个字符串中将符合条件的内容提取出来</p>
<ul>
<li>默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索</li>
<li>我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容</li>
<li>match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;1a2a3a4a5e6f7A8B9C&quot;;</span><br><span class="line">result = str.match(/[a-z]/ig);</span><br><span class="line">//  [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br></pre></td></tr></table></figure>

<h6 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h6><p>可以将字符串中指定内容替换为新的内容,这个在日常开发中极其常见</p>
<p>参数：</p>
<ul>
<li>1.被替换的内容，可以接受一个正则表达式作为参数</li>
<li>2.新的内容</li>
</ul>
<p>默认只会替换第一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;1a2a3a4a5e6f7A8B9C&quot;;</span><br><span class="line">result = str.replace(/[a-z]/gi , &quot;&quot;);</span><br><span class="line">//123456789</span><br></pre></td></tr></table></figure>

<h4 id="5-3原始值包装类"><a href="#5-3原始值包装类" class="headerlink" title="5.3原始值包装类"></a>5.3原始值包装类</h4><p> <code>Boolean</code>、<code>Number</code> 和 <code>String</code>。</p>
<h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h5><p>Boolean对象很假,书中直接讲强烈建议永远不要使用Boolean对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//个人感觉原因</span><br><span class="line">var falseObject = new Boolean(false); </span><br><span class="line">var result = falseObject &amp;&amp; true; </span><br><span class="line">alert(result); // true, falseObject 可视作对象 Boolean(falseObject) 为true</span><br></pre></td></tr></table></figure>

<h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><p>有几个常用的方法:</p>
<h6 id="数值格式化为字符串"><a href="#数值格式化为字符串" class="headerlink" title="数值格式化为字符串"></a>数值格式化为字符串</h6><p>toFixed() :  会按照指定的小数位返回数值的字符串表示，接收一个参数，指定输出结果中的小数位数；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var num = 10;</span><br><span class="line">alert(num.toFixed(2)); // &quot;10.00&quot;</span><br><span class="line">var num = 10.005</span><br><span class="line">alert(num.toFixed(2)); // &quot;10.01&quot;</span><br></pre></td></tr></table></figure>

<h6 id="返回这个数字在特定语言环境下的表示字符串"><a href="#返回这个数字在特定语言环境下的表示字符串" class="headerlink" title="返回这个数字在特定语言环境下的表示字符串"></a>返回这个数字在特定语言环境下的表示字符串</h6><p>toLocaleString()，这个方法贼六，之前想实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100000---》100，000</span><br></pre></td></tr></table></figure>

<p>这种效果得遍历字符串的长度，去切片，添加逗号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let num = 10000.toString()</span><br><span class="line">let  result = &#x27;&#x27;;</span><br><span class="line">while (num.length &gt; 3) &#123;</span><br><span class="line">  //此处用数组的slice方法，如果是负数，那么它规定从数组尾部开始算起的位置</span><br><span class="line">  result = &#x27;,&#x27; + num.slice(-3) + result;</span><br><span class="line">  num = num.slice(0, num.length - 3);</span><br><span class="line">&#125;</span><br><span class="line">this.fileAllNum = result.slice(1,result.length)</span><br><span class="line">if (num)&#123;</span><br><span class="line">  result = num + result</span><br><span class="line">  this.fileAllNum = result.slice(0,result.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有这个方法就很简单了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const number = 3500;</span><br><span class="line"></span><br><span class="line">console.log(number.toLocaleString()); // Displays &quot;3,500&quot; if in U.S. English locale</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">const number = 123456.789;</span><br><span class="line"></span><br><span class="line">// 德国使用逗号作为小数分隔符，分位周期为千位</span><br><span class="line">console.log(number.toLocaleString(&quot;de-DE&quot;));</span><br><span class="line">// → 123.456,789</span><br><span class="line"></span><br><span class="line">// 在大多数阿拉伯语国家使用阿拉伯语数字</span><br><span class="line">console.log(number.toLocaleString(&quot;ar-EG&quot;));</span><br><span class="line">// → ١٢٣٤٥٦٫٧٨٩</span><br><span class="line"></span><br><span class="line">// 印度使用千位/拉克（十万）/克若尔（千万）分隔</span><br><span class="line">console.log(number.toLocaleString(&quot;en-IN&quot;));</span><br><span class="line">// → 1,23,456.789</span><br><span class="line"></span><br><span class="line">// nu 扩展字段要求编号系统，e.g. 中文十进制</span><br><span class="line">console.log(number.toLocaleString(&quot;zh-Hans-CN-u-nu-hanidec&quot;));</span><br><span class="line">// → 一二三,四五六.七八九</span><br><span class="line"></span><br><span class="line">// 当请求不支持的语言时，例如巴厘语，加入一个备用语言，比如印尼语</span><br><span class="line">console.log(number.toLocaleString([&quot;ban&quot;, &quot;id&quot;]));</span><br><span class="line">// → 123.456,789</span><br></pre></td></tr></table></figure>



<h5 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h5><p>String<code>对象的方法也可以在所有基本的字符串值中访问到。其中，继承的</code>valueOf()<code>、</code>toLocaleString()<code>和</code>toString()<code>方法，都返回对象所表示的基本字符串值。</code>String<code>类型的每个实例都有一个</code>length&#96; 属性，表示字符串中包含多个字符。</p>
<h6 id="零宽字符："><a href="#零宽字符：" class="headerlink" title="零宽字符："></a>零宽字符：</h6><p>一种不可打印的Unicode字符, 在浏览器等环境不可见, 但是真是存在, 获取字符串长度时也会占位置, 表示某一种控制功能的字符.</p>
<p>常见的零宽字符有哪些</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">零宽空格（zero-width space, ZWSP）用于可能需要换行处。</span><br><span class="line">    Unicode: U+200B  HTML: &amp;#8203;</span><br><span class="line">零宽不连字 (zero-width non-joiner，ZWNJ)放在电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制。</span><br><span class="line">    Unicode: U+200C  HTML: &amp;#8204;</span><br><span class="line">零宽连字（zero-width joiner，ZWJ）是一个控制字符，放在某些需要复杂排版语言（如阿拉伯语、印地语）的两个字符之间，使得这两个本不会发生连字的字符产生了连字效果。</span><br><span class="line">    Unicode: U+200D  HTML: &amp;#8205;</span><br><span class="line">左至右符号（Left-to-right mark，LRM）是一种控制字符，用于计算机的双向文稿排版中。</span><br><span class="line">    Unicode: U+200E  HTML: &amp;lrm; &amp;#x200E; 或&amp;#8206;</span><br><span class="line">右至左符号（Right-to-left mark，RLM）是一种控制字符，用于计算机的双向文稿排版中。</span><br><span class="line">    Unicode: U+200F  HTML: &amp;rlm; &amp;#x200F; 或&amp;#8207;</span><br><span class="line">字节顺序标记（byte-order mark，BOM）常被用来当做标示文件是以UTF-8、UTF-16或UTF-32编码的标记。</span><br><span class="line">    Unicode: U+FEFF</span><br></pre></td></tr></table></figure>

<p>零宽度字符在JavaScript的应用</p>
<ul>
<li>数据防爬 将零宽度字符插入文本中,干扰关键字匹配。爬虫得到的带有零宽度字符的数据会影响他们的分析，但不会影响用户的阅读数据。</li>
<li>信息传递 将自定义组合的零宽度字符插入文本中，用户复制后会携带不可见信息，达到传递作用。</li>
</ul>
<h6 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">alert(stringValue.charAt(1)); // &quot;e&quot; 也可以 stringValue[1] </span><br></pre></td></tr></table></figure>

<h6 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt()"></a>charCodeAt()</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">alert(stringValue.charCodeAt(1)); // 输出&quot;101&quot; &#x27;e&#x27;的字符编码</span><br></pre></td></tr></table></figure>

<p>字符串操作方法</p>
<h6 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello &quot;;</span><br><span class="line">var result = stringValue.concat(&quot;world&quot;); </span><br><span class="line">alert(result); //&quot;hello world&quot; </span><br><span class="line">alert(stringValue); //&quot;hello&quot;</span><br><span class="line">var result1 = stringValue.concat(&quot;world&quot;, &quot;!&quot;); // 可接收多个参数</span><br><span class="line">alert(result1); //&quot;hello world!&quot;</span><br></pre></td></tr></table></figure>

<h6 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h6><p><em>可以从字符串中截取指定的内容</em></p>
<ul>
<li>不会影响原字符串，而是将截取到内容返回</li>
<li>参数：<ul>
<li>第一个，开始位置的索引（包括开始位置）</li>
<li>第二个，结束位置的索引（不包括结束位置）</li>
<li>如果省略第二个参数，则会截取到后边所有的</li>
<li>也可以传递一个负数作为参数，负数的话将会从后边计算</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">alert(stringValue.slice(3));  // &quot;lo world&quot;</span><br><span class="line">alert(stringValue.slice(-3)); // &quot;rld&quot;</span><br></pre></td></tr></table></figure>

<h6 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h6><p>类似于slice()，不过参数不同</p>
<p>参数：</p>
<ul>
<li>第一个：开始截取位置的索引（包括开始位置）</li>
<li>第二个：结束位置的索引（不包括结束位置）</li>
<li>不同的是这个方法不能接受负值作为参数,如果传递了一个负值，则默认使用0</li>
<li>而且他还自动调整参数的位置，如果第二个参数小于第一个，则自动交换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">alert(stringValue.substring(3)); // &quot;lo world&quot;</span><br><span class="line">alert(stringValue.substring(-3)); // &quot;hello world&quot;</span><br><span class="line">alert(stringValue.substring(3, -4)); // &quot;hel&quot; 会将较小的数作为开始位置，将较大的数作为结束位置， 因此最终相当于调用了 substring(0,3)</span><br><span class="line">alert(stringValue); // &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<h6 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h6><ul>
<li>用来截取字符串</li>
<li>参数：</li>
</ul>
<p>​       1.截取开始位置的索引</p>
<p>​        2.截取的长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">alert(stringValue.substr(3));  // &quot;lo world&quot;</span><br><span class="line">alert(stringValue.substr(-3)); // &quot;rld&quot;</span><br><span class="line">alert(stringValue.substr(3, 7)) // &quot;lo worl&quot; 第二个参数返回的字符个数</span><br><span class="line">alert(stringValue); // &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<p>字符串位置方法</p>
<h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">alert(stringValue.indexOf(&quot;o&quot;)); //4</span><br><span class="line">alert(stringValue.indexOf(&quot;m&quot;)); // -1</span><br><span class="line">alert(stringValue.indexOf(&quot;o&quot;, 6)); // 7 第二个参数，会从指定的位置向后搜索</span><br></pre></td></tr></table></figure>

<p>lastIndexOf()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">alert(stringValue.lastIndexOf(&quot;o&quot;)); // 7</span><br><span class="line">alert(stringValue.lastIndexOf(&quot;m&quot;)); // -1</span><br><span class="line">alert(stringValue.lastIndexOf(&quot;o&quot;, 6)); //4 第二个参数，会从指定的位置向前搜索</span><br></pre></td></tr></table></figure>

<h6 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim() 方法"></a>trim() 方法</h6><p>会创建一个字符串的副本，删除前置及 后缀的所有空格，然后返回结果。</p>
<h6 id="字符串大小写转换方法"><a href="#字符串大小写转换方法" class="headerlink" title="字符串大小写转换方法"></a>字符串大小写转换方法</h6><p><code>toLowerCase()</code>、<code>toLocaleLowerCase()</code>、<code>toUpperCase()</code> 和 <code>toLocaleUpperCase()</code>。 <code>toLocaleLowerCase()</code> 和 <code>toLocaleUpperCase()</code> 方法是针对特定地区的实现。对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言(如土耳其语)会为 Unicode 大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。</p>
<h6 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h6><p>查看正则的补充</p>
<h6 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare()方法"></a>localeCompare()方法</h6><p>操作字符串有关的最后一个方法，比较两个字符串，并返回下列值中的一个:</p>
<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数(大多数情况下是-1，具体的值要视实现而定);</li>
<li>如果字符串等于字符串参数，则返回 0;</li>
<li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数(大多数情况下是 1，具体的值同样要视实现而定)。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;yellow&quot;; </span><br><span class="line"></span><br><span class="line">alert(stringValue.localeCompare(&quot;brick&quot;)); //1 </span><br><span class="line">alert(stringValue.localeCompare(&quot;yellow&quot;)); //0 </span><br><span class="line">alert(stringValue.localeCompare(&quot;zoo&quot;)); //-1</span><br><span class="line">stringValue.localeCompare(&quot;Yellow&quot;) // -1 所以是区分大小写的</span><br></pre></td></tr></table></figure>

<h6 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode()方法"></a>fromCharCode()方法</h6><p><code>String</code> 构造函数本身的一个静态方法，接收一或多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法 <code>charCodeAt()</code> 执行的是相反的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(String.fromCharCode(104, 101, 108, 108, 111));  // &quot;hello&quot;</span><br></pre></td></tr></table></figure>

<h4 id="5-4内置对象"><a href="#5-4内置对象" class="headerlink" title="5.4内置对象"></a>5.4内置对象</h4><p>在所有代码执行之前，作用域中就已经存在两个内置对象：<code>Global</code> 和 <code>Math</code>。</p>
<h5 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h5><p>不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数;所有在全局作用域中定义的属性和函数，都是 <code>Global</code> 对象的属性。如 <code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code> 以及 <code>parseFloat()</code>，实际上全都是 <code>Global</code> 对象的方法。</p>
<p>URI编码方法</p>
<p>为什么要对url进行编码？</p>
<p>因为有效的url不能包含某些字符，如空格。使用url编码方法来编码url，可以使浏览器能够理解它们，并使用utf-8替换掉所有无效字符</p>
<h6 id="encodeURI"><a href="#encodeURI" class="headerlink" title="encodeURI()"></a>encodeURI()</h6><p>主要用于整个 URI(例如，<a target="_blank" rel="noopener" href="http://www.wrox.com/illegal">http://www.wrox.com/illegal</a> value.htm)，不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、 问号和井字号；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var uri = &quot;http://www.wrox.com/illegal value.htm#start&quot;;</span><br><span class="line">alert(encodeURI(uri));   </span><br><span class="line">// &quot;http://www.wrox.com/illegal%20value.htm#start&quot;</span><br></pre></td></tr></table></figure>

<h6 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent()"></a>encodeURIComponent()</h6><p>主要用于对 URI 中的某一段(例如前面 URI 中的 illegal value.htm)进行编码，会对它发现的任何非标准字符进行编码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var uri = &quot;http://www.wrox.com/illegal value.htm#start&quot;; </span><br><span class="line"></span><br><span class="line">//&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;    </span><br><span class="line">alert(encodeURIComponent(uri));</span><br></pre></td></tr></table></figure>

<p>两者区别，正是对整个 URI 使用 <code>encodeURI()</code>，而只能对附加在现有 URI 后面的字符串使用 <code>encodeURIComponent()</code> 的原因所在。使用 <code>encodeURIComponent()</code> 方法的时候要比使用 <code>encodeURI()</code> 更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI 进行编码。</p>
<h6 id="decodeURI-："><a href="#decodeURI-：" class="headerlink" title="decodeURI()："></a>decodeURI()：</h6><p>只能对使用 <code>encodeURI()</code> 替换的字符进行解码；</p>
<h6 id="decodeURIComponent-："><a href="#decodeURIComponent-：" class="headerlink" title="decodeURIComponent()："></a>decodeURIComponent()：</h6><p>只能对使用 <code>encodeURIComponent()</code> 替换的字符进行解码；</p>
<h6 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval()方法"></a>eval()方法</h6><p><code>eval()</code> 方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript或(JavaScript)字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eval(&quot;function sayHi() &#123; alert(&#x27;hi&#x27;); &#125;&quot;);</span><br><span class="line">sayHi();</span><br><span class="line">eval(&quot;var msg = &#x27;hello world&#x27;; &quot;); </span><br><span class="line">alert(msg); //&quot;hello world&quot;</span><br><span class="line">//函数 `sayHi()` 是在 `eval()` 内部定义的。但由于对 `eval()` 的调用最终会被替换成定义函数的实际代码，因此可以在下一行调用 `sayHi()`，对于变量也一样； `eval()` 中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字 符串中；它们只在 `eval()` 执行的时候创建； 严格模式下，在外部访问不到 `eval()` 中创建的任何变量或函数，因此前面两个例子都会导致错误。在严格模式下，为 `eval` 赋值也会导致错误； 使用 `eval()` 时必须极为谨慎，特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输入危险代码(即所谓的代码注入)。</span><br></pre></td></tr></table></figure>

<h5 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h5><p>ECMAScript 虽然没有指出如何直接访问 <code>Global</code> 对象，但 Web 浏览器都是将这个全局对象作为 <code>window</code> 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了 <code>window</code> 对象的属性。</p>
<h5 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h5><p>为保存数学公式和信息提供了一个公共位置，即 <code>Math</code> 对象。</p>
<h6 id="min-和-max-方法"><a href="#min-和-max-方法" class="headerlink" title="min()和 max()方法"></a>min()和 max()方法</h6><p><code>min()</code> 和 <code>max()</code> 方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多个数值参数；这两个方法经常用于避免多余的循环和在 <code>if</code> 语句中确定一组数的最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//找到数组中的最大值或最小值，可以使用 `apply`</span><br><span class="line">var values = [1, 2, 3, 4, 5,  6, 7, 8]</span><br><span class="line">var max = Math.max.apply(Math, values);</span><br></pre></td></tr></table></figure>

<p>这个技巧的关键是把 <code>Math</code> 对象作为 <code>apply()</code> 的第一个参数，从而正确地设置 <code>this</code> 值。然后，可以将任何数组作为第二个参数。</p>
<p>拓展：接着es6结构更简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var values = [1, 2, 3, 4, 5,  6, 7, 8]</span><br><span class="line">var max = Math.max(...values);</span><br></pre></td></tr></table></figure>

<h6 id="Math-ceil"><a href="#Math-ceil" class="headerlink" title="Math.ceil()"></a>Math.ceil()</h6><p>Math.ceil() 执行向上舍入，即它总是将数值向上舍入为最接近的整数；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Math.ceil(25.9)); //26 </span><br><span class="line">alert(Math.ceil(25.5)); //26 </span><br><span class="line">alert(Math.ceil(25.1)); //26</span><br></pre></td></tr></table></figure>

<h6 id="Math-floor"><a href="#Math-floor" class="headerlink" title="Math.floor()"></a>Math.floor()</h6><p>Math.floor() 执行向下舍入，即它总是将数值向下舍入为最接近的整数；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Math.floor(25.9)); //25 </span><br><span class="line">alert(Math.floor(25.5)); //25 </span><br><span class="line">alert(Math.floor(25.1)); //25</span><br></pre></td></tr></table></figure>

<h6 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h6><p>Math.round() 执行标准舍入，即它总是将数值四舍五入为最接近的整数；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Math.round(25.9)); //26 </span><br><span class="line">alert(Math.round(25.5)); //26 </span><br><span class="line">alert(Math.round(25.1)); //25</span><br></pre></td></tr></table></figure>

<h6 id="random-方法"><a href="#random-方法" class="headerlink" title="random()方法"></a>random()方法</h6><p><code>Math.random()</code> 方法返回大于等于 0 小于 1 的一个随机数。套用下面的公式，可以从某个整数范围内随机选择一个值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)</span><br><span class="line"></span><br><span class="line">var num = Math.floor(Math.random() * 10 + 1); // 1-10</span><br><span class="line">var num = Math.floor(Math.random() * 9 + 2); // 2-10</span><br></pre></td></tr></table></figure>

<p>math还有一些很牛的方法如利用sin(),cos()去进行元素布局等等</p>
<h3 id="06：集合引用类型"><a href="#06：集合引用类型" class="headerlink" title="06：集合引用类型"></a>06：集合引用类型</h3><h4 id="6-1Object"><a href="#6-1Object" class="headerlink" title="6.1Object"></a>6.1Object</h4><h4 id="6-2Array"><a href="#6-2Array" class="headerlink" title="6.2Array"></a>6.2Array</h4><h5 id="6-2-1创建数组"><a href="#6-2-1创建数组" class="headerlink" title="6.2.1创建数组"></a>6.2.1创建数组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a = new Arrey(10) //创建长度为10的空数组</span><br><span class="line">const b = new Arrey(10, 20, 30) //创建[10,20,30]的数组</span><br></pre></td></tr></table></figure>

<h6 id="from"><a href="#from" class="headerlink" title="from()"></a>from()</h6><p>将任何可迭代的结构，或者有一个length属性和可索引的结构。转换为数组实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getArgsArray() &#123;</span><br><span class="line">  return Array.from(arguments);</span><br><span class="line">&#125;</span><br><span class="line">console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">const arrayLikeObject = &#123;</span><br><span class="line">  0: 1,</span><br><span class="line">  1: 2,</span><br><span class="line">  2: 3,</span><br><span class="line">  3: 4,</span><br><span class="line">  length: 4</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<p>应用：数组去重</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,1,8,8,12,12,15,15,16,16];</span><br><span class="line">function unique (arr) &#123;</span><br><span class="line">  return Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(unique(arr))</span><br><span class="line"> //[1,8,12,15,16]</span><br></pre></td></tr></table></figure>

<p>还接收第二个可选的映射函数参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1, <span class="function"><span class="params">x</span> =&gt;</span> x**<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1, <span class="keyword">function</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x**<span class="variable language_">this</span>.<span class="property">exponent</span>&#125;, &#123;<span class="attr">exponent</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2);  <span class="comment">// [1, 4, 9, 16]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a3);  <span class="comment">// [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>

<h6 id="of"><a href="#of" class="headerlink" title="of()"></a>of()</h6><p>可以把一组参数转换为数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="literal">undefined</span>));  <span class="comment">// [undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法用于替代在ES6之前常用的 Array.prototype.slice.call(arguments)</span></span><br></pre></td></tr></table></figure>

<p>对于 <code>undefined</code>, <code>null</code> 的包容性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="literal">undefined</span>)   <span class="comment">// [undefined]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="literal">null</span>)        <span class="comment">// [null]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="literal">undefined</span>) <span class="comment">// TypeError: Array.from requires an array-like object - not null or undefined</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="literal">null</span>)      <span class="comment">// TypeError: Array.from requires an array-like object - not null or undefined</span></span><br></pre></td></tr></table></figure>

<h5 id="6-2-2数组空位"><a href="#6-2-2数组空位" class="headerlink" title="6.2.2数组空位"></a>6.2.2数组空位</h5><p>ES6新增方法普遍将这些空位当成存在的元素，只不过值为<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [,,]; <span class="comment">// 创建包含2个元素的数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options.<span class="property">length</span>);   <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options);          <span class="comment">// [empty × 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* for of */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> option <span class="keyword">of</span> options) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(option === <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Array.form */</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="title class_">Array</span>.<span class="title function_">from</span>(options)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> a) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val === <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 等等</span></span><br></pre></td></tr></table></figure>

<p>ES6之前的方法则会忽略这个空位</p>
<ul>
<li><code>map()</code>会跳过空位置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>,,,,<span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options.<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="number">6</span>));  <span class="comment">// [6, undefined, undefined, undefined, 6]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>join()</code>视空位置为空字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>,,,,<span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>));     <span class="comment">// &quot;1----5&quot;</span></span><br></pre></td></tr></table></figure>

<h6 id="补充：-1"><a href="#补充：-1" class="headerlink" title="补充："></a>补充：</h6><p>由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用<code>undefined</code>值代替。</p>
<h5 id="6-2-3数组索引"><a href="#6-2-3数组索引" class="headerlink" title="6.2.3数组索引"></a>6.2.3数组索引</h5><p>通过修改length属性，可以从数组末尾删除或添加元素</p>
<ul>
<li><p>数组一开始有3个值。将length设置为2，就删除了最后一个</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含3个字符串的数组</span></span><br><span class="line">colors.<span class="property">length</span> = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">alert</span>(colors[<span class="number">2</span>]);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将length设置为大于数组元素数的值，则新添加的元素都将以undefined填充</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  <span class="comment">// 创建一个包含3个字符串的数组</span></span><br><span class="line">colors.<span class="property">length</span> = <span class="number">4</span>;</span><br><span class="line"><span class="title function_">alert</span>(colors[<span class="number">3</span>]);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用length属性可以方便地向数组末尾添加元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  <span class="comment">// 创建一个包含3个字符串的数组</span></span><br><span class="line">colors[colors.<span class="property">length</span>] = <span class="string">&quot;black&quot;</span>;        <span class="comment">// 添加一种颜色（位置3）</span></span><br><span class="line">colors[colors.<span class="property">length</span>] = <span class="string">&quot;brown&quot;</span>;        <span class="comment">// 再添加一种颜色（位置4）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="补充：-2"><a href="#补充：-2" class="headerlink" title="补充："></a>补充：</h6><p>不要在<code>Vue2.x</code>中使用 <code>length</code> 来改变数组，否则无法触发动态响应，最好使用push()添加</p>
<h5 id="6-2-4检测数组"><a href="#6-2-4检测数组" class="headerlink" title="6.2.4检测数组"></a>6.2.4检测数组</h5><h6 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123; <span class="comment">/* 操作数组 */</span> &#125;</span><br></pre></td></tr></table></figure>

<h6 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value))&#123; <span class="comment">/* 操作数组 */</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-2-5迭代器方法"><a href="#6-2-5迭代器方法" class="headerlink" title="6.2.5迭代器方法"></a>6.2.5迭代器方法</h5><p>在ES6中，Array的原型上暴露了3个用于检索数组内容的方法</p>
<ul>
<li><code>keys()</code> - 返回数组索引的迭代器</li>
<li><code>values()</code> - 返回数组元素的迭代器</li>
<li><code>entries()</code> - 返回索引&#x2F;值对的迭代器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为这些方法都返回迭代器，所以可以将它们的内容</span></span><br><span class="line"><span class="comment">// 通过Array.from()直接转换为数组实例</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">keys</span>());     <span class="comment">// [0, 1, 2, 3]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">values</span>());   <span class="comment">// [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">entries</span>());  <span class="comment">// [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]]</span></span><br></pre></td></tr></table></figure>

<h5 id="6-2-6复制和填充方法"><a href="#6-2-6复制和填充方法" class="headerlink" title="6.2.6复制和填充方法"></a>6.2.6复制和填充方法</h5><h6 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h6><p>填充数组方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [0,0,0,0,0]</span><br><span class="line">//用7填充索引大于等于1且小于3的元素</span><br><span class="line">a.fill(7,1,3)</span><br><span class="line">//[0,7,7,0,0]</span><br></pre></td></tr></table></figure>

<h6 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h6><p>批量复制方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [0,1,2,3,4,5,6,7,8]</span><br><span class="line">//复制从索引大于等于0开始到小于3结束的内容，插入到4开始的位置</span><br><span class="line">a.copyWithin(4，0，3)</span><br><span class="line">//[0,1,2,3,0,1,2,7,8]</span><br></pre></td></tr></table></figure>

<h6 id="补充-1"><a href="#补充-1" class="headerlink" title="补充:"></a>补充:</h6><p>面试题：写一个长度为1000，内容全为10的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a = new Arrey(1000)</span><br><span class="line">a.fill(10)</span><br></pre></td></tr></table></figure>

<h5 id="其他常见方法"><a href="#其他常见方法" class="headerlink" title="其他常见方法"></a>其他常见方法</h5><h6 id="一-增"><a href="#一-增" class="headerlink" title="(一)增"></a>(一)增</h6><p>下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响</p>
<ul>
<li><p>push()</p>
<p>向尾部添加</p>
</li>
<li><p>unshift()</p>
<p>向头部添加</p>
</li>
<li><p>splice()</p>
<p>将指定元素从原数组中删除。传入三个参数,(开始位置、要删除的元素数量,插入的元素)。返回删除值</p>
</li>
<li><p>concat()</p>
<p>连接两个或多个数组,并将新的数组返回</p>
</li>
</ul>
<h6 id="二-删"><a href="#二-删" class="headerlink" title="(二)删"></a>(二)删</h6><p>下面三种都会影响原数组，最后一项不影响原数组：</p>
<ul>
<li><p>pop()</p>
<p>删除最后一个元素</p>
</li>
<li><p>shift()</p>
<p>删除第一个元素</p>
</li>
<li><p>splice()</p>
<p>将指定元素从原数组中删除。传入三个参数,(开始位置、要删除的元素数量,插入的元素)。返回删除值</p>
</li>
<li><p>slice()</p>
<p>用于创建一个包含原有数组中一个或多个元素的新数组,传入两个参数,(开始位置、结束位置)</p>
</li>
</ul>
<h6 id="三-改"><a href="#三-改" class="headerlink" title="(三)改"></a>(三)改</h6><p>slice():用于创建一个包含原有数组中一个或多个元素的新数组,传入三个参数,(开始位置、结束位置)</p>
<h6 id="四-查"><a href="#四-查" class="headerlink" title="(四)查"></a>(四)查</h6><p>即查找元素，返回元素坐标或者元素值,多不会改变原数组</p>
<ul>
<li><p>indexOf()</p>
<p>返回要查找的元素在数组中的位置，如果没找到则返回 -1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>includes()</p>
<p>返回要查找的元素在数组中的位置，找到返回<code>true</code>，否则<code>false</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">includes</span>(<span class="number">4</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>find()</p>
<p>返回第一个匹配的元素</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">27</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line">people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>) <span class="comment">// // &#123;name: &quot;Matt&quot;, age: 27&#125;</span></span><br></pre></td></tr></table></figure>

<h6 id="五-排序"><a href="#五-排序" class="headerlink" title="(五)排序"></a>(五)排序</h6><p>数组有两个方法可以用来对元素重新排序,多改变原数组：</p>
<ul>
<li><p>reverse()</p>
<p>将数组元素方向反转</p>
</li>
<li><p>sort()</p>
<p>sort()方法(默认按照unicode编码排序)接受一个比较函数,需要两个形参,根据返回值判断顺序。</p>
<p>如果返回值&gt;0则元素交换位置,&lt;&#x3D;0则不变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.<span class="title function_">sort</span>(compare);</span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 0,1,5,10,15</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="六-转换"><a href="#六-转换" class="headerlink" title="(六)转换"></a>(六)转换</h6><ul>
<li>join() 方法将数组转换为字符串,接收一个参数，即字符串分隔符，返回包含所有项的字符串</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">alert(colors.join(&quot;,&quot;)); // red,green,blue</span><br><span class="line">alert(colors.join(&quot;||&quot;)); // red||green||blue</span><br></pre></td></tr></table></figure>

<ul>
<li><p>from()方法 从具有 length 属性或可迭代对象的任何对象返回 Array 对象。(将伪数组转换为数组)</p>
<p>Array.from(object,mapFunction,thisValue);<br>参数说明：</p>
<ol>
<li><code>object</code>：必须，要转换为数组的对象。</li>
<li><code>mapFunction</code>：可选，数组中每个元素要调用的函数。</li>
<li><code>thisValue</code>：可选，映射函数（mapFunction）中的this对象</li>
</ol>
</li>
</ul>
<h6 id="七-遍历"><a href="#七-遍历" class="headerlink" title="(七)遍历"></a>(七)遍历</h6><p>常用来迭代数组的方法（都不改变原数组）有如下：</p>
<ul>
<li><p>some()</p>
<p>对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> someResult = numbers.<span class="title function_">some</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(someResult) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>every()</p>
<p>对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> everyResult = numbers.<span class="title function_">every</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(everyResult) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>forEach()</p>
<p>对数组每一项都运行传入的函数，没有返回值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>filter()</p>
<p>对数组每一项都运行传入的函数，函数返回 <code>true</code> 的项会组成数组之后返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filterResult); <span class="comment">// 3,4,5,4,3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>map()</p>
<p>对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapResult) <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h5><ul>
<li><p><code>reduce()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。</span></span><br><span class="line"><span class="comment">// 函数接收4个参数：上一个归并值、当前项、当前项的索引和数组本身。</span></span><br><span class="line"><span class="comment">// 这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。</span></span><br><span class="line"><span class="comment">// 如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始</span></span><br><span class="line"><span class="comment">// 因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> sum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur )</span><br><span class="line">arr <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">sum <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>reduceRight()</code></p>
<p>[注]  顺序从右至左，其余跟<code>reduce()</code>一致</p>
</li>
</ul>
<h4 id="6-3定型数组"><a href="#6-3定型数组" class="headerlink" title="6.3定型数组"></a>6.3定型数组</h4><p>定型数组是ECMAScript新增的结构，目的是提升向原生库传输数据的效率。定型数组包含一套不同的引用类型，用于管理数值在内存中的类型.</p>
<h6 id="补充：-3"><a href="#补充：-3" class="headerlink" title="补充："></a>补充：</h6><p>这一部分可以当作课外知识阅读</p>
<h6 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h6><p>在 WebGL的早期版本中，因为 JavaScript 数组与原生数组之间不匹配，所以出现了性能问题。图形驱动程序 API 通常不需要以 JavaScript 默认双精度浮点格式传递给它们的数值，而这恰恰是 JavaScript数组在内存中的格式。</p>
<p>Mozilla 为解决这个问题而实现了 CanvasFloatArray 。这是一个提供JavaScript接口的、C语言风格的浮点值数组。最终， CanvasFloatArray变成了 Float32Array ，也就是今天定型数组中可用的第一个“类型”。</p>
<h6 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h6><p><code>Float32Array</code>实际上是一种“视图”，可以允许JS运行时访问一块名为<code>ArrayBuffer</code>的预分配内存。</p>
<p><code>ArrayBuffer</code>是所有定型数组及视图引用的基本单位。</p>
<p><code>ArrayBuffer()</code>是一个普通的JS构造函数，可用于在内存中分配特定数量的字节空间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>); <span class="comment">// 在内存中分配16字节</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf.<span class="property">byteLength</span>); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<p><code>ArrayBuffer</code>一经创建就不能再调整大小。不过，可以使用<code>slice()</code>复制其全部或部分到一个新实例中。</p>
<p><code>ArrayBuffer</code>在分配失败时会抛出错误，声明后会将所有二进制位初始化为0。</p>
<p>通过声明<code>ArrayBuffer</code>分配的堆内存可以被当成垃圾回收，不用手动释放。</p>
<p>不能仅通过对<code>ArrayBuffer</code>的引用就读取或写入其内容。要读取或写入，必须通过视图。视图有不同的类型，但引用的都是<code>ArrayBuffer</code>中存储的二进制数据</p>
<h6 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h6><p>第一种允许读写<code>ArrayBuffer</code>的视图是<code>DataView</code>。这个视图专为文件I&#x2F;0和网络I&#x2F;0设计，其API支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些</p>
<p><code>DataView</code>对缓冲内容没有任何预设，也不能迭代</p>
<p>必须在对已有的<code>ArrayBuffer</code>读取或写入时才能创建<code>DataView</code>实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataView默认（只有一个参数时）使用整个ArrayBuffer</span></span><br><span class="line"><span class="comment">// 第二个参数表示视图从缓冲起点开始</span></span><br><span class="line"><span class="comment">// 第三个参数表示限制视图为前8个字节，如果不指定，则使用剩余缓冲</span></span><br><span class="line"><span class="keyword">const</span> fullDataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf, <span class="number">0</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>要通过<code>DataView</code>读取缓冲，还需要几个组件</p>
<ul>
<li>首先是要读或写的字节偏移量。可以看成<code>DataView</code>中的某种“地址”。</li>
<li><code>DataView</code>应该使用<code>ElementType</code>来实现JS的<code>Number</code>类型到缓冲内二进制格式的转换</li>
</ul>
<blockquote>
<p>ElementType</p>
<p><code>DataView</code>对存储在缓冲内的数据类型没有预设。它暴露的API强制开发者在读、写时指定一个<code>ElementType</code>，然后<code>DataView</code>就会忠实地为读、写而完成相应的转换</p>
</blockquote>
<ul>
<li>最后是内存中值的字节序。默认为大端字节序</li>
</ul>
<blockquote>
<p>字节序</p>
<p>“字节序”指的是计算系统维护的一种字节顺序的约定。</p>
<p><code>DataView</code>只支持两种约定：</p>
<ul>
<li>大端字节序, 也称为“网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节</li>
<li>小端字节序，与大端字节序相反</li>
</ul>
<p>JS运行时所在系统的原生字节序决定了如何读取或写入字节。对一段内存而言，<code>DataView</code>是一个中立接口，它会遵循你指定的字节序（接收一个可选地布尔值，设置为<code>true</code>即可启用小端字节序）</p>
</blockquote>
<h6 id="定型数组"><a href="#定型数组" class="headerlink" title="定型数组"></a>定型数组</h6><p>定型数组是另一种形式的<code>ArrayBuffer</code>视图，虽然概念上与<code>DataView</code>接近，但定型数组的区别在于，它特定于一种<code>ElementType</code>且遵循系统原生的字节序。</p>
<p>定型数组提供了适用面更广的API和更高的性能。</p>
<blockquote>
<p>由于定型数组的二进制表示对操作系统而言是一种容易使用的格式，JS引擎可以重度优化算术运算、按位运算和其他对定型数组的常见操作，因此使用他们速度极快</p>
</blockquote>
<h4 id="6-4Map"><a href="#6-4Map" class="headerlink" title="6.4Map"></a>6.4Map</h4><p>一种数据结构，类似与Object，不同的是Object只能使用数值、字符串或符号作为键，而Map可以使用任何JavaScript数据类型作为键。并且Map实例会维护键值对的插入顺序。</p>
<h6 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h6><ul>
<li><p>使用嵌套数组初始化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">])</span><br><span class="line">m1  <span class="comment">// Map &#123;&quot;key1&quot; =&gt; &quot;val1&quot;, &quot;key2&quot; =&gt; &quot;val2&quot;, &quot;key3&quot; =&gt; &quot;val3&quot;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用自定义迭代器初始化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="title class_">Map</span>(&#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>*() &#123;</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>];</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>];</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">m2  <span class="comment">// Map &#123;&quot;key1&quot; =&gt; &quot;val1&quot;, &quot;key2&quot; =&gt; &quot;val2&quot;, &quot;key3&quot; =&gt; &quot;val3&quot;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>set()</code>方法添加键&#x2F;值对</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">demo_map.<span class="title function_">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>)</span><br><span class="line">        .<span class="title function_">set</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>)</span><br><span class="line">demo_map  <span class="comment">// Map &#123;&quot;key1&quot; =&gt; &quot;val1&quot;, &quot;key2&quot; =&gt; &quot;val2&quot;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>get()</code>和<code>has()</code>进行查询，通过<code>size</code>属性获取长度</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>]</span><br><span class="line">])</span><br><span class="line">demo_map.<span class="title function_">has</span>(<span class="string">&quot;key1&quot;</span>)  <span class="comment">// true</span></span><br><span class="line">demo_map.<span class="title function_">get</span>(<span class="string">&quot;key2&quot;</span>)  <span class="comment">// &quot;val2&quot;</span></span><br><span class="line">demo_map.<span class="property">size</span>         <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>delete()</code>和<code>clear()</code>删除值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">])</span><br><span class="line">demo_map  <span class="comment">// Map &#123;&quot;key1&quot; =&gt; &quot;val1&quot;, &quot;key2&quot; =&gt; &quot;val2&quot;, &quot;key3&quot; =&gt; &quot;val3&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delete() 删除指定项</span></span><br><span class="line">demo_map.<span class="title function_">delete</span>(<span class="string">&quot;key1&quot;</span>)   </span><br><span class="line">demo_map  <span class="comment">// Map &#123;&quot;key2&quot; =&gt; &quot;val2&quot;, &quot;key3&quot; =&gt; &quot;val3&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clear() 清除所有</span></span><br><span class="line">demo_map.<span class="title function_">clear</span>()</span><br><span class="line">demo_map  <span class="comment">// Map &#123;&#125; </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="顺序与迭代"><a href="#顺序与迭代" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h6><p>Map会维护值插入时的顺序,而Object中属性是无序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//遍历对象,要注意es对象中属性是无序的,如:</span><br><span class="line">const o = &#123;&#x27;1&#x27;: 1&#125;</span><br><span class="line">o.b = 2</span><br><span class="line">o[2] = 3</span><br><span class="line">o.a = 4</span><br><span class="line">console.log(o)</span><br><span class="line">//在对象中是,会先将数字按照顺序排列,其他的会按照添加顺序添加</span><br><span class="line">&#123;1: 1, 2: 3, b: 2, a: 4&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>entries()</code>（或者<code>Symbol.iterator</code>属性，它引用<code>entries()</code>）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_map = <span class="keyword">new</span> <span class="title class_">Map</span>( [ [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>] ] )</span><br><span class="line">demo_map.<span class="property">entries</span> === demo_map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">demo_map.<span class="title function_">entries</span>()  <span class="comment">// MapIterator &#123;&#x27;key1&#x27; =&gt; &#x27;val1&#x27;, &#x27;key2&#x27; =&gt; &#x27;val2&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>entries()</code> 配合使用 <code>for of</code> 实现遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_map = <span class="keyword">new</span> <span class="title class_">Map</span>( [ [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>] ] )</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> pair <span class="keyword">of</span> demo_map.<span class="title function_">entries</span>() ) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(pair) &#125;</span><br><span class="line"><span class="comment">// [&#x27;key1&#x27;, &#x27;val1&#x27;]</span></span><br><span class="line"><span class="comment">// [&#x27;key2&#x27;, &#x27;val2&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展操作<code>[...]</code> 实现<code>Map</code>转<code>Array</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_map = <span class="keyword">new</span> <span class="title class_">Map</span>( [ [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>] ] )</span><br><span class="line"></span><br><span class="line">[...demo_map] <span class="comment">// [[&#x27;key1&#x27;, &#x27;val1&#x27;], [&#x27;key2&#x27;, &#x27;val2&#x27;]]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>forEach(callback, opt_thisArg)</code> 进行遍历</p>
<p>[注]  传入的回调接收可选的第二个参数，这个参数用于重写回调内部<code>this</code>的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_map = <span class="keyword">new</span> <span class="title class_">Map</span>( [ [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>] ] )</span><br><span class="line"></span><br><span class="line">demo_map.<span class="title function_">forEach</span>(</span><br><span class="line">  <span class="function">(<span class="params">val, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> -&gt; <span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// key1 -&gt; val1</span></span><br><span class="line"><span class="comment">// key2 -&gt; val2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>keys()</code>和<code>values()</code>分别返回以插入顺序生成键和值的迭代器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_map = <span class="keyword">new</span> <span class="title class_">Map</span>( [ [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>] ] )</span><br><span class="line"></span><br><span class="line">demo_map.<span class="title function_">keys</span>()   <span class="comment">// MapIterator &#123;&#x27;key1&#x27;, &#x27;key2&#x27;&#125;</span></span><br><span class="line">demo_map.<span class="title function_">values</span>() <span class="comment">// MapIterator &#123;&#x27;val1&#x27;, &#x27;val2&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> key <span class="keyword">of</span> demo_map.<span class="title function_">keys</span>() ) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(key) &#125;</span><br><span class="line"><span class="comment">// key1</span></span><br><span class="line"><span class="comment">// key2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> value <span class="keyword">of</span> demo_map.<span class="title function_">values</span>() ) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;</span><br><span class="line"><span class="comment">// val1</span></span><br><span class="line"><span class="comment">// val2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-5WeakMap"><a href="#6-5WeakMap" class="headerlink" title="6.5WeakMap"></a>6.5WeakMap</h4><ul>
<li>键只能是<code>Object</code>或者继承自<code>Object</code>的类型，尝试使用非对象设置键会抛出<code>TypeError</code>。</li>
<li>WeakMap<code>是</code>Map<code>的“兄弟”类型，其API也是</code>Map的子集。</li>
<li>WeakMap中的“weak”（弱），描述的是JavaScript垃圾回收程序对待“弱映射”中键的方式。</li>
</ul>
<h6 id="基本API-1"><a href="#基本API-1" class="headerlink" title="基本API"></a>基本API</h6><ul>
<li><code>set()</code>添加键&#x2F;值对</li>
<li><code>get()</code>和<code>has()</code>查询</li>
<li><code>delete()</code>删除</li>
<li>跟<code>Map</code>不一样，<code>WeakMap</code>没有<code>clear()</code></li>
</ul>
<h4 id="6-6Set"><a href="#6-6Set" class="headerlink" title="6.6Set"></a>6.6Set</h4><p>Set<code>在很多方面都像是加强的</code>Map，这是因为它们的大多数API和行为都是共有的。</p>
<h5 id="基本API-2"><a href="#基本API-2" class="headerlink" title="基本API"></a>基本API</h5><ul>
<li><p>使用嵌套数组初始化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line">s1  <span class="comment">// Set(3) &#123;&#x27;val1&#x27;, &#x27;val2&#x27;, &#x27;val3&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用自定义迭代器初始化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>(&#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>*() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;val1&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;val2&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;val3&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">s2  <span class="comment">// Set(3) &#123;&#x27;val1&#x27;, &#x27;val2&#x27;, &#x27;val3&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>add()</code>方法添加元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">demo_set.<span class="title function_">add</span>(<span class="string">&quot;val1&quot;</span>)</span><br><span class="line">        .<span class="title function_">add</span>(<span class="string">&quot;val2&quot;</span>)</span><br><span class="line">demo_set  <span class="comment">// Set(2) &#123;&#x27;val1&#x27;, &#x27;val2&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add() 同样的值会默认略过</span></span><br><span class="line">demo_set.<span class="title function_">add</span>(<span class="string">&quot;val1&quot;</span>)</span><br><span class="line">demo_set  <span class="comment">// Set(2) &#123;&#x27;val1&#x27;, &#x27;val2&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>has()</code>进行查询，通过<code>size</code>属性获取长度</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>]);</span><br><span class="line">demo_set.<span class="title function_">has</span>(<span class="string">&quot;val1&quot;</span>)  <span class="comment">// true</span></span><br><span class="line">demo_set.<span class="property">size</span>         <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>delete()</code>和<code>clear()</code>删除值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line">demo_set  <span class="comment">// Set(3) &#123;&#x27;val1&#x27;, &#x27;val2&#x27;, &#x27;val3&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delete() 删除指定项</span></span><br><span class="line"><span class="comment">// 返回 Set 中是否存在被删除的值</span></span><br><span class="line">demo_set.<span class="title function_">delete</span>(<span class="string">&#x27;val1&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">demo_set.<span class="title function_">delete</span>(<span class="string">&#x27;val1&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">demo_set  <span class="comment">// Set(2) &#123;&#x27;val2&#x27;, &#x27;val3&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clear() 清除所有</span></span><br><span class="line">demo_set.<span class="title function_">clear</span>()</span><br><span class="line">demo_set  <span class="comment">// Set(0) &#123;size: 0&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="顺序与迭代-1"><a href="#顺序与迭代-1" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h5><p>会维护值插入时的顺序</p>
<ul>
<li><p><code>values()</code> 及其别名方法<code>keys()</code>（或者<code>Symbol.iterator</code>属性，它引用<code>values()</code>）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>]);</span><br><span class="line">demo_set.<span class="property">values</span> === demo_set[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] <span class="comment">// true</span></span><br><span class="line">demo_set.<span class="property">keys</span>   === demo_set[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">demo_set.<span class="title function_">values</span>() <span class="comment">// SetIterator &#123;&#x27;val1&#x27;, &#x27;val2&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>values()</code> 配合使用 <code>for of</code> 实现遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> value <span class="keyword">of</span> demo_set.<span class="title function_">values</span>() ) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;</span><br><span class="line"><span class="comment">// val1</span></span><br><span class="line"><span class="comment">// val2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展操作<code>[...]</code> 实现<code>Set</code>转<code>Array</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>]);</span><br><span class="line"></span><br><span class="line">[...demo_set] <span class="comment">// [&quot;val1&quot;, &quot;val2&quot;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>entries()</code>方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> pair <span class="keyword">of</span> demo_set.<span class="title function_">entries</span>() ) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(pair) &#125;</span><br><span class="line"><span class="comment">// [&#x27;val1&#x27;, &#x27;val1&#x27;]</span></span><br><span class="line"><span class="comment">// [&#x27;val2&#x27;, &#x27;val2&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>forEach(callback, opt_thisArg)</code> 进行遍历</p>
<p>[注]  传入的回调接收可选的第二个参数，这个参数用于重写回调内部<code>this</code>的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo_set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>]);</span><br><span class="line"></span><br><span class="line">demo_set.<span class="title function_">forEach</span>(</span><br><span class="line">  <span class="function">(<span class="params">val, dupVal</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;val&#125;</span> -&gt; <span class="subst">$&#123;dupVal&#125;</span>`</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// val1 -&gt; val1</span></span><br><span class="line"><span class="comment">// val2 -&gt; val2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="特定操作"><a href="#特定操作" class="headerlink" title="特定操作"></a>特定操作</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4,5,4,3,2,1];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数组去重</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let result = [...new Set(arr)];</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>
</li>
<li><p>交集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let arr2 = [4,5,6,5,6];</span><br><span class="line">let result = [...new Set(arr)].filter(item =&gt; &#123;</span><br><span class="line">    let s2 = new Set(arr2);// 4 5 6</span><br><span class="line">    if(s2.has(item))&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">let result = [...new Set(arr)].filter(item =&gt; new Set(arr2).has(item));</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>
</li>
<li><p>并集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let union = [...new Set([...arr, ...arr2])];</span><br><span class="line">console.log(union);</span><br></pre></td></tr></table></figure>
</li>
<li><p>差集</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let diff = [...new Set(arr)].filter(item =&gt; !(new Set(arr2).has(item)));</span><br><span class="line">console.log(diff);</span><br></pre></td></tr></table></figure>

<h4 id="6-7WeakSet"><a href="#6-7WeakSet" class="headerlink" title="6.7WeakSet"></a>6.7WeakSet</h4><p>WeakSet<code>是</code>Set<code>的“兄弟”类型，其API也是</code>Set<code>的子集。</code>WeakSet&#96;中的“weak”（弱），描述的是JavaScript垃圾回收程序对待“弱集合”中值的方式。</p>
<h5 id="基本API-3"><a href="#基本API-3" class="headerlink" title="基本API"></a>基本API</h5><ul>
<li><code>add()</code>添加值</li>
<li><code>has()</code>查询</li>
<li><code>delete()</code>删除</li>
<li>跟<code>Set</code>不一样，<code>WeakSet</code>没有<code>clear()</code></li>
</ul>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul>
<li><p>值只能是<code>Object</code>或者继承自<code>Object</code>的类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objVal = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> demo_weakSet = <span class="keyword">new</span> <span class="title class_">WeakSet</span>( [ objVal ] )</span><br><span class="line">demo_weakSet <span class="comment">// WeakSet &#123;&#123;…&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 原始值不可以直接当 WeakSet 的键 */</span></span><br><span class="line"><span class="keyword">const</span> demo_weakSet = <span class="keyword">new</span> <span class="title class_">WeakSet</span>( [ <span class="string">&#x27;val&#x27;</span> ] )</span><br><span class="line"><span class="comment">// Uncaught TypeError: Invalid value used in weak set</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="07：迭代器与生成器"><a href="#07：迭代器与生成器" class="headerlink" title="07：迭代器与生成器"></a>07：迭代器与生成器</h3><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>迭代是按照顺序反复多次执行一段程序，通常会有明确的终止条件。</p>
<h5 id="数组迭代的缺陷"><a href="#数组迭代的缺陷" class="headerlink" title="数组迭代的缺陷"></a>数组迭代的缺陷</h5><ul>
<li>迭代前需要事先知道如何使用数据结构。数据结构必须需要满足通过<code>[]</code>取特定索引位置的项</li>
<li>遍历顺序并不是数据结构固有的。不适用于除数组以外的具有隐式顺序的数据结构</li>
</ul>
<p>为了弥补缺陷，ES5 新增了些迭代方法，在上一章节<a target="_blank" rel="noopener" href="https://juejin.cn/post/6916167190060367886#heading-17">集合引用类型</a>有介绍过</p>
<ul>
<li>forEach()</li>
<li>map()</li>
<li>some()</li>
<li>every()</li>
<li>filter() 以上方法无需通过<code>[]</code>取特定索引位置的项,但还是数组原型上的方法，不适用其他数据结构</li>
</ul>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>ES6 新增的<strong>迭代器模式</strong>，可以像 Python、Java 等开发语言通过<strong>原生语言结构</strong>解决迭代缺陷，让开发者无需事先知道如何迭代就能实现迭代操作。</p>
<p>ES6 新增了迭代协议，分为<strong>可迭代协议</strong>和<strong>迭代器协议</strong>，其中，实现可迭代协议（Iterable 接口）的对象称为<strong>可迭代对象</strong>，实现迭代器协议的对象称为<strong>迭代器</strong>，而可迭代对象在迭代过程中会被迭代器“消费”。</p>
<p>下面先从协议来讲起。</p>
<h5 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h5><p>可迭代协议具备两种能力：</p>
<ul>
<li>支持迭代的自我识别能力</li>
<li>创建实现可迭代协议的对象的能力</li>
</ul>
<p>首先，为何是这两种能力：</p>
<ul>
<li>第一点，自我识别，这一点解决 ES6 之前需要事先知道迭代对象的缺陷；</li>
<li>第二点，创建对象，这一点解决 ES6 之前迭代限定于数组的缺陷。</li>
</ul>
<h5 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h5><ul>
<li>内置可迭代对象 <ul>
<li>String</li>
<li>Array</li>
<li>TypedArray</li>
<li>Map</li>
<li>Set</li>
<li>函数的 arguments 对象</li>
<li>NodeList 等 DOM 集合类型</li>
</ul>
</li>
<li>需要可迭代对象的语法 <ul>
<li>for-of</li>
<li>解构赋值</li>
<li>扩展运算符</li>
<li>yield*</li>
</ul>
</li>
</ul>
<h5 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h5><p>迭代器协议定义了产生一系列值（无论是有限个还是无线个）的标准方式。当值为有限个时，所有的值都被迭代完毕后，则会返回一个默认返回值。</p>
<p>这种标准方式需要满足迭代器协议的迭代器去实现，而只有实现 <code>next()</code> 方法的对象才能成为迭代器。</p>
<p>那么，来看看这个 <code>next()</code> 的语义是什么：next() 是一个无参函数，返回对象 IteratorReault，该对象拥有 <strong>done</strong> 和 <strong>value</strong> 两个属性：</p>
<ul>
<li>done，布尔值，false 表示还可以调用 next() 取得下一个值，true 代表“耗尽”</li>
<li>value，当 done 为 true 时包含可迭代对象的下一个值，否则显示 undefined</li>
</ul>
<p>具体场景如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); <span class="comment">// 获取迭代器</span></span><br><span class="line"><span class="comment">// 执行迭代器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意到，通过迭代器的 <code>next()</code> 方法可以按顺序迭代可迭代对象，并返回 IteratorReault。当 IteratorReault 的 done 属性为 true 后，会返回同样的 IteratorReault 对象。</p>
<p>因此，也就解释了，当值是有限的时候，所有值被迭代完毕后，会返回默认返回值，而无线的时候，done 值一直为 false，迭代一直进行下去。</p>
<h5 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h5><p>迭代器是一个对象，它定义了一个序列，并在终止时可能返回一个返回值。拥有以下特点：</p>
<ul>
<li>一次性使用的对象：每次调用迭代器工厂函数会生成新的迭代器对象</li>
<li>关联一个可迭代对象：会阻止垃圾回收程序回收可迭代对象</li>
</ul>
<p>那么，看看一个简单的迭代器长什么样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="comment">// 迭代器</span></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>] () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    	<span class="comment">// next() 函数</span></span><br><span class="line">      next () &#123;</span><br><span class="line">      	<span class="comment">// 返回 IteratorReault</span></span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&#x27;cyan&#x27;</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> color = <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(color[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// &#123; next: f () &#123;&#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(color[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]().<span class="title function_">next</span>()); <span class="comment">// &#123;done: false, value: &quot;cyan&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h5><p>为了能够将可迭代对象迭代多次，需要迭代器对象上创建对个迭代器，每一个迭代器对应一个新计数器，再将计数器变量放到闭包中，通过闭包返回迭代器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (limit) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = limit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>] () &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>,</span><br><span class="line">    limit = <span class="variable language_">this</span>.<span class="property">limit</span>;</span><br><span class="line">    retrun  &#123;</span><br><span class="line">      next () &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= limit) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="提前终止迭代器"><a href="#提前终止迭代器" class="headerlink" title="提前终止迭代器"></a>提前终止迭代器</h5><p>迭代器使用<strong>可选</strong>的 return() 方法可以让迭代器提前关闭执行。应用场景包括：</p>
<ul>
<li>for-of 循环通过 break\continue\return\throw 等提前退出</li>
<li>解构赋值并未消费所有值 将自定义迭代器将入 return() 方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (limit) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = limit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>] () &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>,</span><br><span class="line">      limit = <span class="variable language_">this</span>.<span class="property">limit</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next () &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= limit) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 加入 return</span></span><br><span class="line">      <span class="keyword">return</span> () &#123;</span><br><span class="line">      	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;迭代器关闭前执行操作&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span> (<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 迭代器关闭前执行操作</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>没有设定 return() 关闭迭代器或迭代器不能关闭的情况下，迭代退出后还可从上次离开的地方继续迭代</li>
<li>设定了 return() 的迭代器不会强制进入关闭状态，但 return() 会被调用</li>
</ul>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器是一个能够函数内暂停和恢复执行的函数，并且在函数面前加一个星号（<code>*</code>）。除了箭头函数，其他函数可以定义生成器函数。</p>
<h5 id="生成器基础"><a href="#生成器基础" class="headerlink" title="生成器基础"></a>生成器基础</h5><ul>
<li>声明带 <code>*</code>，星号两边空格不影响</li>
<li>调用生成器函数会产生生成器对象</li>
<li>生成器对象一开始处于<strong>暂停状态</strong> suspended</li>
<li>生成器对象拥有和迭代器相似 的 next() 方法</li>
<li>生成器函数只会在<strong>初次</strong>调用 next() 方法后开始执行</li>
<li>生成器函数实现了可迭代协议，默认迭代器是自引用的</li>
</ul>
<h5 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h5><p>回顾一下生成器的概念：可以在函数内部暂停和恢复的结构。这个内部暂停和回复就是通过 yield 关键字做到的，因此，yield 是生成器中最有用的地方。</p>
<p>yield 的特性是：</p>
<ul>
<li>yield 只能在生成器内部使用，其他地方会报错</li>
<li>生成器函数遇到 yield 之前会正常执行</li>
<li>遇到之后，执行会停止，函数作用域会被保留</li>
<li>通过生成器对象调用 next() 恢复 yield 暂停的生成器执行</li>
<li>yield 将生成的值返回给 next() 返回的对象里</li>
<li>直到遇到 return，生成器退出，并处于 done: true 状态</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;generator&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;return&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());</span><br><span class="line"><span class="comment">// generator</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;return&quot;, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="yield-实现输入和输出"><a href="#yield-实现输入和输出" class="headerlink" title="yield 实现输入和输出"></a>yield 实现输入和输出</h5><p>yield 作为函数的<strong>中间参数</strong>使用，上一次的 yield 会接收到当前 next() 方法的第一个值，但第一次调用的 next() 仅仅作为开始执行生成器函数，因此第一次 next() 的<strong>第一个值</strong>不会被 yield 接收使用。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function * <span class="built_in">gen</span>(arg)&#123;</span><br><span class="line">    console<span class="selector-class">.log</span>(arg);</span><br><span class="line">    let one = yield <span class="number">111</span>;</span><br><span class="line">    console<span class="selector-class">.log</span>(one);</span><br><span class="line"></span><br><span class="line">    let two = yield <span class="number">222</span>;</span><br><span class="line">    console<span class="selector-class">.log</span>(two);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行获取迭代器对象</span></span><br><span class="line">let iterator = <span class="built_in">gen</span>(&#x27;形参&#x27;);</span><br><span class="line">console<span class="selector-class">.log</span>(iterator.next(&quot;hhhh&quot;),&#x27;外部<span class="number">1</span>&#x27;);</span><br><span class="line"><span class="comment">//next方法可以传入实参</span></span><br><span class="line">console<span class="selector-class">.log</span>(iterator.next(&#x27;BBB&#x27;),&#x27;外部<span class="number">2</span>&#x27;);</span><br><span class="line">console<span class="selector-class">.log</span>(iterator.next(&#x27;CCC&#x27;), &#x27;外部<span class="number">3</span>&#x27;);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">形参</span><br><span class="line">&#123;value: <span class="number">111</span>, done: false&#125; &#x27;外部<span class="number">1</span>&#x27;</span><br><span class="line">BBB</span><br><span class="line">&#123;value: <span class="number">222</span>, done: false&#125; &#x27;外部<span class="number">2</span>&#x27;</span><br><span class="line">CCC</span><br><span class="line">&#123;value: <span class="number">333</span>, done: true&#125; &#x27;外部<span class="number">3</span>&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="提前终止生成器"><a href="#提前终止生成器" class="headerlink" title="提前终止生成器"></a>提前终止生成器</h5><p>生成器都可以作为默认迭代器了，那么一定也支持提前关闭。生成器除了 <code>return()</code> 一种终止方法，还支持 <code>throw()</code> 方法强制生成器进入关闭状态。</p>
<h5 id="return"><a href="#return" class="headerlink" title="return()"></a>return()</h5><p>生成器提供的 <code>return()</code> 方法相比于迭代器的有很大不同：</p>
<ul>
<li>可选：生成器都有 <code>return()</code> 方法，而迭代器是可选的</li>
<li>强制：生成器的 <code>return()</code> 方法会强制进入关闭状态，而迭代器不会强制，但方法会执行</li>
<li>传值：生成器的 <code>return()</code> 方法可以<strong>传值</strong>，且该值是终止迭代器对象的值，而迭代器必须返回一个<strong>对象</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">yield</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g1 = <span class="title function_">generatorFn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">return</span>(<span class="number">4</span>)); <span class="comment">// &#123; done: true, value: 4 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for-of 循环会忽略状态为 done: true 的迭代器对象内部返回的值</span></span><br><span class="line"><span class="keyword">const</span> g2 = <span class="title function_">generatorFn</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> g2) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">1</span>) g.<span class="keyword">return</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h5 id="throw"><a href="#throw" class="headerlink" title="throw()"></a>throw()</h5><p>该方法会将一个提供的错误注入到生成器对象中。</p>
<p>如果错误未被处理，生成器就会关闭。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* generatorFn () &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">  <span class="keyword">yield</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  g.<span class="keyword">throw</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// &quot;err&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果生成器函数内部处理了这个错误，生成器不但不会关闭，还会恢复执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* generatorFn () &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: 1 &#125;</span></span><br><span class="line">g.<span class="keyword">throw</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p>错误处理跳过对应的 yield，因此会跳过 2，并且后续会恢复执行。</p>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用:"></a>应用:</h5><p>解决回调地狱</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//模拟获取  用户数据  订单数据  商品数据 </span><br><span class="line">function getUsers()&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        let data = &#x27;用户数据&#x27;;</span><br><span class="line">        //调用 next 方法, 并且将数据传入</span><br><span class="line">        iterator.next(data);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getOrders()&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        let data = &#x27;订单数据&#x27;;</span><br><span class="line">        iterator.next(data);</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getGoods()&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        let data = &#x27;商品数据&#x27;;</span><br><span class="line">        iterator.next(data);</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function * gen()&#123;</span><br><span class="line">    let users = yield getUsers();</span><br><span class="line">    console.log(users)</span><br><span class="line">    let orders = yield getOrders();</span><br><span class="line">    console.log(orders)</span><br><span class="line">    let goods = yield getGoods();</span><br><span class="line">    console.log(goods)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用生成器函数</span><br><span class="line">let iterator = gen();</span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure>



<h3 id="08：对象、类与面向对象编程"><a href="#08：对象、类与面向对象编程" class="headerlink" title="08：对象、类与面向对象编程"></a>08：对象、类与面向对象编程</h3><h4 id="8-1理解对象"><a href="#8-1理解对象" class="headerlink" title="8.1理解对象"></a>8.1理解对象</h4><h5 id="8-1-1属性的类型"><a href="#8-1-1属性的类型" class="headerlink" title="8.1.1属性的类型"></a>8.1.1属性的类型</h5><h6 id="数据属性："><a href="#数据属性：" class="headerlink" title="数据属性："></a>数据属性：</h6><p>数据属性有四个特性描述他们的行为：</p>
<table>
<thead>
<tr>
<th>key</th>
<th>功能</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>confingurable</td>
<td>属性是否可以通过delete删除</td>
<td>true</td>
</tr>
<tr>
<td>enumberable</td>
<td>属性是否可以通过for-in循环遍历</td>
<td>true</td>
</tr>
<tr>
<td>writable</td>
<td>属性值是否可以被修改</td>
<td>true</td>
</tr>
<tr>
<td>value</td>
<td>属性实际的值</td>
<td>undefined</td>
</tr>
</tbody></table>
<h6 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h6><p>访问器属性也有四个特性描述他们：</p>
<table>
<thead>
<tr>
<th>key</th>
<th>功能</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>configurable</td>
<td>属性是否可以通过delete删除</td>
<td>true</td>
</tr>
<tr>
<td>enumberable</td>
<td>属性是否可以通过for-in循环遍历</td>
<td>true</td>
</tr>
<tr>
<td>get</td>
<td>读取函数</td>
<td>undefined</td>
</tr>
<tr>
<td>set</td>
<td>设置函数</td>
<td>undefined</td>
</tr>
</tbody></table>
<h6 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h6><p>通过object.defineProperty方法</p>
<ul>
<li>修改属性的数据属性的四个特性</li>
<li>设置访问器属性的四个特性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure>

<p>obj：必需。目标对象</p>
<p>prop：必需。需定义或修改的属性的名字</p>
<p>descriptor：必需。目标属性所拥有的特性,是一个配置对象,可以配置上面的数据属性与访问器属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, &quot;key2&quot;, &#123;</span><br><span class="line">  enumerable: false,</span><br><span class="line">  configurable: false,</span><br><span class="line">  writable: false,</span><br><span class="line">  value: &quot;static&quot;,</span><br><span class="line">  //当使用了writable和value属性，不允许使用getter或setter这两个方法</span><br><span class="line">  set (newValue) &#123;</span><br><span class="line">    if (newValue &gt; 2) ...</span><br><span class="line">  &#125;,</span><br><span class="line">  get () &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="补充-2"><a href="#补充-2" class="headerlink" title="补充:"></a>补充:</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">o.a = 1;</span><br><span class="line">// 等价于：</span><br><span class="line">Object.defineProperty(o, &quot;a&quot;, &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  writable: true,</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 另一种情况,如果设置了但不设置全,会改默认为fasle</span><br><span class="line">Object.defineProperty(o, &quot;a&quot;, &#123; value: 1 &#125;);</span><br><span class="line">// 等价于：</span><br><span class="line">Object.defineProperty(o, &quot;a&quot;, &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  writable: false,</span><br><span class="line">  configurable: false,</span><br><span class="line">  enumerable: false,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//面试题： a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3</span><br><span class="line">Object.defineProperty(window,&#x27;a&#x27;,&#123;</span><br><span class="line">  get:function() &#123;</span><br><span class="line">    //this指向window.a</span><br><span class="line">    this.value ? this.value++ : this.value = 1;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">if(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3) &#123;</span><br><span class="line">  console.log(&quot;OK&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="8-1-2定义多个属性"><a href="#8-1-2定义多个属性" class="headerlink" title="8.1.2定义多个属性"></a>8.1.2定义多个属性</h5><p>如果需要定义多个属性那么久用Object.definedPropiries,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperties(obj, props)</span><br></pre></td></tr></table></figure>

<p>接受两个参数：第一个是要添加或者修改的对象本身，第二个参数是 描述符的配置对象,<strong>跟上面一样如果设置了但不设置全,会改默认为fasle</strong>；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const object1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperties(object1, &#123;</span><br><span class="line">  property1: &#123;</span><br><span class="line">    value: 42</span><br><span class="line">  &#125;,</span><br><span class="line">  property2: &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">object1.property1 = 1</span><br><span class="line">console.log(object1.property1)//42</span><br></pre></td></tr></table></figure>

<h5 id="8-1-3读取属性的特性"><a href="#8-1-3读取属性的特性" class="headerlink" title="8.1.3读取属性的特性"></a>8.1.3读取属性的特性</h5><p>使用Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符；</p>
<p>接受两个参数：第一个是对象本身，另一个是要获取描述符的属性名称；</p>
<p>返回值：一个对象</p>
<p>如果是访问器属性返回的对象包含configurable,enumerable,get,set属性</p>
<p>如果是数据属性返回的对象包含configurable,enumerable,value,witerable;</p>
<p>ECMAScript 2017新增了一个Object.getOwnPrototypeDescriptors()静态方法，可以一次返回多个属性描述信息对象；</p>
<h6 id="补充：-4"><a href="#补充：-4" class="headerlink" title="补充："></a>补充：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//未知对象浅拷贝</span><br><span class="line">Object.create(</span><br><span class="line">  Object.getPrototypeOf(obj),</span><br><span class="line">  Object.getOwnPropertyDescriptors(obj),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="8-1-4合并对象"><a href="#8-1-4合并对象" class="headerlink" title="8.1.4合并对象"></a>8.1.4合并对象</h5><p>ECNAScript6 专门提供了一个合并对象Object.assign()方法来合并对象； 这个方法接受一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举和自有属性复制到目标对象；</p>
<p>强调：对于每一个符合条件的属性，这个方法会使用源对象上的[[get]]取得属性的值，然后使用目标对象上的[[set]]设置属性的值；</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特殊的例子</span></span><br><span class="line"><span class="keyword">var</span> dest = &#123;</span><br><span class="line">    <span class="attr">_a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设置a的值：&#x27;</span> + val);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_a</span> = val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">a</span>() &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取a的值：&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest);</span><br><span class="line"><span class="comment">//获取a的值：</span></span><br><span class="line">设置a的值：foo</span><br><span class="line">&#123;<span class="attr">_a</span>: <span class="string">&#x27;foo&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Object.assign()合并对象的特点：</p>
<ul>
<li>实际上对每个源对象执行的都是浅拷贝；</li>
<li>如果多个源对象都有相同的属性，则使用最后一个复制的值；</li>
<li>不能再两个对象间转移获取函数和设置函数；</li>
</ul>
<p>如果合并对象的时候出错了，Object.assign()并不会回滚操作，可能只会完成部分复制的方法</p>
<p>看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回滚测试代码</span></span><br><span class="line"><span class="keyword">var</span> dest = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> src = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">b</span>() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">c</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest);  <span class="comment">// &#123;a: &quot;foo&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="8-1-5对象标识及相等判断is"><a href="#8-1-5对象标识及相等判断is" class="headerlink" title="8.1.5对象标识及相等判断is"></a>8.1.5对象标识及相等判断is</h5><p>ECMAScrpt6规范新增了Objece.is(),这个方法跟&#x3D;&#x3D; &#x3D;很想，比&#x3D;&#x3D;&#x3D;更加精确；</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用三等号，下满三个都是true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>))   <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, <span class="number">0</span>));   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">0</span>, -<span class="number">0</span>));   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前判断NaN,只能用isNaN方法判断</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="8-1-6增强的对象语法"><a href="#8-1-6增强的对象语法" class="headerlink" title="8.1.6增强的对象语法"></a>8.1.6增强的对象语法</h5><ul>
<li>1，属性值简写（key名字和值的变量名一样的话就可以省略）</li>
<li>2，可计算属性 (可用中括号动态改变对象的属性名)</li>
<li>3，简写方法名 (es6的方法简写)</li>
</ul>
<h5 id="8-1-7对象解构"><a href="#8-1-7对象解构" class="headerlink" title="8.1.7对象解构"></a>8.1.7对象解构</h5><p>这个没有什么好说的，注意两点就行了：</p>
<p>1，使用解构赋值的时候可以起一个别名</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>: personName, <span class="attr">age</span>: personAge&#125; = person; </span><br></pre></td></tr></table></figure>

<p>2，赋值的时候可以给以默认值</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>: persionName = <span class="string">&#x27;默认名字&#x27;</span>, <span class="attr">age</span>: persionAge&#125; = person; </span><br></pre></td></tr></table></figure>

<p>重点来了：</p>
<p>解构在内部使用函数ToObject()把原数据结构转化为对象，这意味这在对象解构的上下文中，原始值会被当做对象，也意味着null和undefined不能被解构，会抛出错误；</p>
<p>看看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; length &#125; = <span class="string">&quot;foobar&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(length);   <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4的构造函数赋值给了c</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">constructor</span>: c &#125; = <span class="number">4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c === <span class="title class_">Number</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">null</span>;         <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">undefined</span>;    <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<p>解构赋值还可以用在嵌套解构，部分解构，参数上下文匹配中；</p>
<h4 id="8-2创建对象"><a href="#8-2创建对象" class="headerlink" title="8.2创建对象"></a>8.2创建对象</h4><p>强调：ES6虽然引入了类和继承，但是本质还是对ES5的封装，只是一个语法糖而已；</p>
<p>创建一个对象下面几种模式：</p>
<ul>
<li>工厂模式；</li>
<li>构造函数模式；</li>
<li>原型模式；</li>
</ul>
<h5 id="8-2-2工厂模式："><a href="#8-2-2工厂模式：" class="headerlink" title="8.2.2工厂模式："></a>8.2.2工厂模式：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPersion</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  o.<span class="property">name</span> = name;</span><br><span class="line">  o.<span class="property">age</span> = age;</span><br><span class="line">  o.<span class="property">job</span> = job;</span><br><span class="line">  o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="title function_">createPersion</span>(<span class="string">&#x27;lsj&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;web前端&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="title function_">createPersion</span>(<span class="string">&#x27;zm&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;平面设计师&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这种工厂模式虽然可以解决创建多个类似对象的问题，但是没有解决对象标识的问题（即新创建的对象是什么类型）</p>
<h5 id="8-2-3构造函数模式"><a href="#8-2-3构造函数模式" class="headerlink" title="8.2.3构造函数模式"></a>8.2.3构造函数模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编码规范，只有是构造函数就需要首字母大写；</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Persion</span>(<span class="params">name,age,job</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我的名字是&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="title class_">Persion</span>(<span class="string">&#x27;lsj&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;web前端&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p5 = <span class="keyword">new</span> <span class="title class_">Persion</span>(<span class="string">&#x27;zm&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;平面设计师&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p4.<span class="title function_">sayName</span>();  <span class="comment">// 我的名字是lsj</span></span><br><span class="line">p5.<span class="title function_">sayName</span>();  <span class="comment">// 我的名字是zm</span></span><br></pre></td></tr></table></figure>

<h6 id="创建一个对象new内部都做了什么事情？"><a href="#创建一个对象new内部都做了什么事情？" class="headerlink" title="创建一个对象new内部都做了什么事情？"></a>创建一个对象new内部都做了什么事情？</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var  a = new A();</span><br><span class="line"></span><br><span class="line">假设我们要创建一个构造函数A()的实例a，则必须使用new操作符。会经历以下5个步骤：</span><br><span class="line"></span><br><span class="line">1，在内存中创建了一个新的对象（var o=new Object();）；</span><br><span class="line">2，这个新对象内部[[prototype]]指向了构造函数prototype属性（o.__proto__=A.prototype;）；</span><br><span class="line">3，构造函数内部的this被赋值为这个新的对象；</span><br><span class="line">4，执行构造函数内部的代码（给新对象添加属性）；</span><br><span class="line">5，如果构造函数返回的是个非空对象，则返回这个对象，否则返回刚创建的那个对象（也就是this）；</span><br></pre></td></tr></table></figure>

<p>在前面我们说过工厂函创建出来的对象不知道类型，那么构造函数可以解决上面问题，p4和p5分别保存着Persion的不同实力，这两个对象都有一个constructor属性指向了Persion;这个constructor就是标识对象类型的；</p>
<h6 id="构造函数与普通函数的区别："><a href="#构造函数与普通函数的区别：" class="headerlink" title="构造函数与普通函数的区别："></a>构造函数与普通函数的区别：</h6><p>构造函数与普通函数唯一的区别就是调用方式不用。除此之外，构造函数也是函数。任何函数只要使用了new操作符调用就是构造函数，而不使用new操作符调用的函数就是普通函数；</p>
<p>构造函数创建出来的对象有什么问题呢？</p>
<p>创建出来的方法每一个对象都保存了一份占用空间，所以就出现了后面的原型模式；</p>
<h5 id="8-2-4理解原型："><a href="#8-2-4理解原型：" class="headerlink" title="8.2.4理解原型："></a>8.2.4理解原型：</h5><p>无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为constructor的属性，指回与之关联的构造函数。然后因构造函数而异，可能会给原型对象添加其他属性和方法；</p>
<p>在自定义构造函数时，原型对象默认只会获得constructor属性，其他的所有方法都继承自Object,每次调用构造函数创建一个新的实例，这个实例内部[[prototype]]指针就会被赋值为构造函数原型对象，脚本中没有访问这个[[prototype]]特性的标准方式，但是浏览器会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型。</p>
<p>关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</p>
<p>下面看一些例子来理解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明之后构造函数就有了一个与之关联的原型对象；</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Persion</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span>);  <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数有一个prototype属性，指向其原型对象，而这个原型对象也有一个constructor属性，指向这个构造函数；</span></span><br><span class="line"><span class="comment">// 换句话说就是循环引用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Persion</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常的原型链都会终止与Object的原型对象 Objecrt的原型指向的是null </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>);   <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1,实例对象通过__proto__链接到原型对象,他实际上指向隐藏属性[[prototype]]</span></span><br><span class="line"><span class="comment">// 2,构造函数通过prototype属性链接到原型对象；</span></span><br><span class="line"><span class="comment">// 3,实例与构造函数没有直接联系，与原型对象有直接的联系；</span></span><br><span class="line"><span class="keyword">let</span> persion1 = <span class="keyword">new</span> <span class="title class_">Persion</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(persion1.<span class="property">__proto__</span> === <span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同一个构造函数创建两个实例，共享一个原型对象（节省空间）</span></span><br><span class="line"><span class="keyword">let</span> persion2 = <span class="keyword">new</span> <span class="title class_">Persion</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(persion1.<span class="property">__proto__</span> === persion2.<span class="property">__proto__</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// instanceof 检查实例的原型中是否包含指定构造函数的原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(persion1 <span class="keyword">instanceof</span> <span class="title class_">Persion</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(persion1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>)   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>虽然不是所有实现都对外暴露了[[prototype]],但可以使用isPrototypeOf()方法判断两个对象之间的关系；</p>
<p>用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(persion2)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(persion1)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>ECMAScript的object类型有一个方法叫Object.getPrototypeOf(),返回参数的内部特性[[prototype]]的值；在继承的时候很有用，后面介绍；</p>
<p>用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(persion2))</span><br></pre></td></tr></table></figure>

<p>setPrototypeOf()方法，设置一个对象的原型，但是性能不好！可以通过Object.create()方法来代替；</p>
<p>虽然可以通过实例访问原型上的属性，但是不能修改原型上的属性，如果再实例上添加一个与原型同名的属性，会遮住原型的上的属性；这是因为访问一个对象的属性时，先从对像自己属性上找，找不到才回去原型链上去找，一层一层向上寻找；</p>
<p>hasOwnPrototype()方法用于确定属性实在实例上是否有该属性，有返回true,否则返回false；</p>
<p>in操作符：可以通过对象访问属性时候返回true，无论这个属性在对象上还是在原型上；</p>
<p>可以根据上面两个api实现一个hasPrototypeProtype方法，判断竖向是否在原型上：</p>
<p>具体代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasPrototypePrototype</span>(<span class="params">obj, name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (name <span class="keyword">in</span> obj) &amp;&amp; !obj.<span class="title function_">hasOwnPrototype</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for in 循环注意事项：</p>
<p>只要能够被访问就可以被枚举出来，既包含实例属性，也包含原型属性；</p>
<p>如果只需要遍历对象属性，那么可以使用Object.key()方法，这个方法接受一个对象作为参数，返回包含该对象所欲可枚举属性名称的字符串数组；</p>
<p>下面举个例子看一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Persion</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;lsj&quot;</span></span><br><span class="line"><span class="keyword">let</span> persion1 = <span class="keyword">new</span> <span class="title class_">Persion</span>();</span><br><span class="line">persion1.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> persion1) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key)  <span class="comment">// name age</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(persion1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(keys)  <span class="comment">// [age]</span></span><br></pre></td></tr></table></figure>

<p>如果想要获取实例上的所有属性无论是否可枚举（不包含原型上的属性），可以使用Object.getOwnPropertyNames(),如果以Symbol作为key的话，需要使用它的兄弟方法遍历Object.getOwnPropertySymbols(),用法一样的；</p>
<h6 id="属性枚举的顺序："><a href="#属性枚举的顺序：" class="headerlink" title="属性枚举的顺序："></a>属性枚举的顺序：</h6><ul>
<li>for in</li>
<li>Object.keys()</li>
<li>Object.getOwnPropertyNames()</li>
<li>Object.getOwnPropertySymbols()</li>
<li>Object.assign()</li>
</ul>
<p>for in 循环和Object.keys()的枚举顺序是不确定的，取决于js引擎，可能因浏览器而已；</p>
<p>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和Object.assign()的枚举顺序是确定的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看下面的例子：</span></span><br><span class="line"><span class="keyword">let</span> key1 = <span class="title class_">Symbol</span>(<span class="string">&quot;k1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> key2 = <span class="title class_">Symbol</span>(<span class="string">&quot;k2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">first</span>: <span class="string">&quot;first&quot;</span>,</span><br><span class="line">  [key1]: <span class="string">&#x27;key1&#x27;</span>,</span><br><span class="line">  <span class="attr">second</span>: <span class="string">&quot;second&quot;</span>,</span><br><span class="line">  <span class="number">0</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o[key2] = <span class="string">&#x27;key2&#x27;</span></span><br><span class="line">o[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">o.<span class="property">thrid</span> = <span class="string">&#x27;thrid&#x27;</span></span><br><span class="line">o[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(o))  <span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;first&quot;, &quot;second&quot;, &quot;thrid&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(o))   <span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure>

<h5 id="8-2-5对象迭代"><a href="#8-2-5对象迭代" class="headerlink" title="8.2.5对象迭代"></a>8.2.5对象迭代</h5><p>ESMAScript2017新增了两个静态方法，Objedt.values()和Object.entries(),接受一个对象作为参数，前者返回的是值的数组，后者返回的是键值对的数组；</p>
<p>值得注意的是：</p>
<ul>
<li>如果值是引用类型，这两个方法拿到的都是引用，就是所谓浅复制；</li>
<li>对于键是Symbol类型，两个方法都会忽略；</li>
</ul>
<h6 id="重写原型"><a href="#重写原型" class="headerlink" title="重写原型"></a>重写原型</h6><p>还有一种方式使我们可以重新定义Prototype指向一个新的对象；</p>
<p>如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Persion</span> () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将构造函数的原型重新指向一个对象</span></span><br><span class="line"><span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;lsj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我的名字是&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1  = <span class="keyword">new</span> <span class="title class_">Persion</span>()</span><br><span class="line">p1.<span class="title function_">sayName</span>()</span><br></pre></td></tr></table></figure>

<p>但是这样写有一个问题：重写之后Persion.Prototype的consturctor属性就不知道指向Persion了；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Persion</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>所以就不能通过constructor属性来识别类型了，也需要使用instanceof操作符来判断了；</p>
<p>当然我们可以修正该指针，如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将构造函数的原型重新指向一个对象</span></span><br><span class="line"><span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>:<span class="title class_">Persion</span>,  <span class="comment">// 指针修正</span></span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;lsj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我的名字是&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种修正的方式和原生的有些区别（原生中constructor是不可以枚举的）：</p>
<p>再次修改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Persion</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将构造函数的原型重新指向一个对象</span></span><br><span class="line"><span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lsj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我的名字是&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constuctor&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Persion</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h6><p>表现在创建一个对象实例之后，对原型所做的修改在实例上也会反应出来；</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Persion</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="comment">//创建实例</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Persion</span>()</span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line"><span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用原型方法</span></span><br><span class="line">p1.<span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure>

<p>之所以这样是因为实例和原型之间就是简单的指针关系，而不是保存副本，所以能在原型中找到sayHello方法；</p>
<p>需要注意一点就是创建实例之后，然后重写原型，那么之前重建实例不会动态改变了，因为指针变掉了；</p>
<p>一般情况：原型上定义一些公用的方法，属性最好通过传参的方式传入；</p>
<h4 id="8-3继承"><a href="#8-3继承" class="headerlink" title="8.3继承"></a>8.3继承</h4><h5 id="8-3-1原型链"><a href="#8-3-1原型链" class="headerlink" title="8.3.1原型链"></a>8.3.1原型链</h5><h6 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h6><p>ECMS-262把原型链定义为ECMASCript的主要继承方式；基本思路就是通过原型继承多个引用类型的属性和方法；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">方式1: 原型链继承</span><br><span class="line">  1. 套路</span><br><span class="line">    1. 定义父类型构造函数</span><br><span class="line">    2. 给父类型的原型添加方法</span><br><span class="line">    3. 定义子类型的构造函数</span><br><span class="line">    4. 创建父类型的对象赋值给子类型的原型</span><br><span class="line">    5. 将子类型原型的构造属性设置为子类型</span><br><span class="line">    6. 给子类型原型添加方法</span><br><span class="line">    7. 创建子类型的对象: 可以调用父类型的方法</span><br><span class="line">  2. 关键</span><br><span class="line">    1. 子类型的原型为父类型的一个实例对象</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">  function Supper() &#123; //父类型</span><br><span class="line">    this.superProp = &#x27;The super prop&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  //原型的数据所有的实例对象都可见</span><br><span class="line">  Supper.prototype.showSupperProp = function () &#123;</span><br><span class="line">    console.log(this.superProp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function Sub() &#123; //子类型</span><br><span class="line">    this.subProp = &#x27;The sub prop&#x27;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 子类的原型为父类的实例</span><br><span class="line">  Sub.prototype = new Supper()</span><br><span class="line">  // 修正Sub.prototype.constructor为Sub本身</span><br><span class="line">  Sub.prototype.constructor = Sub</span><br><span class="line"></span><br><span class="line">  Sub.prototype.showSubProp = function () &#123;</span><br><span class="line">    console.log(this.subProp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 创建子类型的实例</span><br><span class="line">  var sub = new Sub()</span><br><span class="line">  // 调用父类型的方法</span><br><span class="line">  sub.showSubProp()</span><br><span class="line">  // 调用子类型的方法</span><br><span class="line">  sub.showSupperProp()</span><br></pre></td></tr></table></figure>

<h6 id="默认原型："><a href="#默认原型：" class="headerlink" title="默认原型："></a>默认原型：</h6><p>原型链的最顶层就是Object,这就是为什么自定义的类型能够继承包括toString()、valueOf()等在内的所有默认方法的原因；</p>
<h6 id="继承和原型之间的关系："><a href="#继承和原型之间的关系：" class="headerlink" title="继承和原型之间的关系："></a>继承和原型之间的关系：</h6><p>原型和实例的关系可以通过两种方式来确认：第一个是instanceof,第二个是isPrototypeOf()</p>
<h6 id="关于方法："><a href="#关于方法：" class="headerlink" title="关于方法："></a>关于方法：</h6><p>子类有时候需要覆盖父类的方法，或者重写父类的方法，为此，这些方法必须原型赋值之后再添加到原型上；</p>
<h6 id="原型链的问题："><a href="#原型链的问题：" class="headerlink" title="原型链的问题："></a>原型链的问题：</h6><p>原型中包含引用类型的时候，会在实例中共享；</p>
<h5 id="8-3-2盗用构造函数"><a href="#8-3-2盗用构造函数" class="headerlink" title="8.3.2盗用构造函数"></a>8.3.2盗用构造函数</h5><p>在子类构造函数中调用call()或者apply()方法，并且把this作为上下文，执行父类的构造函数；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student(name, age, price) &#123;</span><br><span class="line">  Person.call(this, name, age)   // this.Person(name, age)</span><br><span class="line">  this.price = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s = new Student(&#x27;Tom&#x27;, 20, 12000)</span><br><span class="line">console.log(s.name, s.age, s.price)</span><br></pre></td></tr></table></figure>

<ul>
<li>优势：可以传参给父类</li>
<li>缺点：父类原型上的方法不能继承</li>
</ul>
<h5 id="8-3-3组合继承"><a href="#8-3-3组合继承" class="headerlink" title="8.3.3组合继承"></a>8.3.3组合继承</h5><p>组合继承就是将上面两种方式结合起来的继承，同是也保留了instanceof操作符合isPrototypeOf()方法识别合成对象的能力；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = function (name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student(name, age, price) &#123;</span><br><span class="line">  Person.call(this, name, age) //得到父类型的属性</span><br><span class="line">  this.price = price</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = new Person()  //得到父类型的方法</span><br><span class="line">Student.prototype.constructor = Student</span><br><span class="line">Student.prototype.setPrice = function (price) &#123;</span><br><span class="line">  this.price = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s = new Student(&#x27;Tom&#x27;, 12, 10000)</span><br><span class="line">s.setPrice(11000)</span><br><span class="line">s.setName(&#x27;Bob&#x27;)</span><br><span class="line">console.log(s)</span><br><span class="line">console.log(s.constructor)</span><br></pre></td></tr></table></figure>

<p>缺点：原型对象上定了很多不必要的属性；</p>
<h5 id="8-3-4原型式继承"><a href="#8-3-4原型式继承" class="headerlink" title="8.3.4原型式继承"></a>8.3.4原型式继承</h5><p>使用场景：你有一个对象，想在它的基础上在创建一个新的对象，这个时候你就可以把这个对象先传给object(),然后对返回的对选哪个做适当的修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数原型，然后返回这个临时类型的一个实例；本质上，object()是对传入的对象执行了一次浅复制；</p>
<p>ECMAScript5新增了一个Object.create()方法将原型式继承的概念规范化了，接受两个参数：第一个是作为新对象原型的对象，第二个给新对象定义额外属性的对象（可选），用法和Object.defineProperties()的第二个参数一样的；</p>
<h5 id="8-3-5寄生式继承"><a href="#8-3-5寄生式继承" class="headerlink" title="8.3.5寄生式继承"></a>8.3.5寄生式继承</h5><p>思路：类似于寄生构造函数和工厂模式，创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。(一般没有什么用，可以忽略)</p>
<h5 id="8-3-6寄生式组合继承"><a href="#8-3-6寄生式组合继承" class="headerlink" title="8.3.6寄生式组合继承"></a>8.3.6寄生式组合继承</h5><p>这里只调用了一次SuperType构造函数，避免了subType.prototype上不必要也用不到的属性；而且instanceof操作符合isPrototypeOf()方法正常有效；</p>
<p><strong>寄生式组合继承可以算是引用类型继承的最佳模式</strong>。</p>
<p>看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现寄生式组合的核心逻辑</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inHeritPrototype</span>(<span class="params">subType,superType</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(superType.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  <span class="comment">// 修正constructor</span></span><br><span class="line">  prototype.<span class="property">constructor</span> = subType</span><br><span class="line">  subType.<span class="property"><span class="keyword">prototype</span></span> = prototype</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承实现</span></span><br><span class="line"><span class="title function_">inHeritPrototype</span>(<span class="title class_">SubType</span>,<span class="title class_">SuperType</span>)</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&#x27;lsj&#x27;</span>,<span class="number">18</span>)</span><br><span class="line">instance.<span class="title function_">sayName</span>()  <span class="comment">// lsj 调用父类的方法</span></span><br><span class="line">instance.<span class="title function_">sayAge</span>()  <span class="comment">// 18 调用子类的方法</span></span><br></pre></td></tr></table></figure>

<h4 id="8-4类"><a href="#8-4类" class="headerlink" title="8.4类"></a>8.4类</h4><p>类是ECMAScript6中新的基础性语法糖结构，实际上它的背后是的仍然是原型和构造函数的；</p>
<h5 id="8-4-1类的定义"><a href="#8-4-1类的定义" class="headerlink" title="8.4.1类的定义"></a>8.4.1类的定义</h5><p>和函数一样主要有两种定义方式：类声明和类表达式；</p>
<p>与函数的不用点：</p>
<ul>
<li>函数生命可以提前，但是类定义不行；</li>
<li>函数受作用域限制，而类受块作用域限制；</li>
</ul>
<p>类的构成：</p>
<ul>
<li>构造方法</li>
<li>实例方法</li>
<li>获取函数</li>
<li>设置函数</li>
<li>静态类方</li>
</ul>
<h5 id="8-4-2类的构造函数"><a href="#8-4-2类的构造函数" class="headerlink" title="8.4.2类的构造函数"></a>8.4.2类的构造函数</h5><p>方法名字constructor会告诉解析器在使用new操作符创建类的实例时，应该调用真函数；构造函数不是必须的，不定义构造函数就相当于将构造函数定义为空函数；</p>
<h6 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h6><p>实例化的过程和前面介绍的构造方法实例化基本一致，只是执行了构造方法为对象添加属性；实例化时候传入的参数给了constructor这个方法，如果不需要参数，则类名后面的括号也是可选的；（一般还是带上吧）</p>
<p>默认情况下，类构造函数会在执行之后返回this对象，也就是实例对象；不过返回的不是this对象而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联；</p>
<p>类构造函数与普通的构造函数主要的区别是:调用构造函数必须使用new操作符；</p>
<h6 id="把类当做特殊函数"><a href="#把类当做特殊函数" class="headerlink" title="把类当做特殊函数"></a>把类当做特殊函数</h6><p>可以通过typeof操作符检测类标识符；类型是function</p>
<p>类标签符有prototype属性，原型上面也有一个constructor属性指向自身，也可以使用instanceof操作符检查构造函数原型是否存在实例的原型链中；</p>
<p>重点在于：类定义的constructor方法不会被当成构造函数，在对它使用instanceof操作符会返回false(P253页)</p>
<p>类是javascript的一等公民，可以像函数一样作为参数，也可以像函数一样立即实例化；</p>
<h5 id="8-4-3实例、原型和类成员"><a href="#8-4-3实例、原型和类成员" class="headerlink" title="8.4.3实例、原型和类成员"></a>8.4.3实例、原型和类成员</h5><p>类语法糖可以更方便的定义应该存在于实例上的成员、应该存在于原型上的成员、以及应该存在于类本身的成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Persion</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 添加到this的所有内容都会存在于不同的实例上</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">loacate</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;instance&quot;</span>, <span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义在原型上</span></span><br><span class="line">  <span class="title function_">loacate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;prototype&quot;</span>, <span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义在类本身上</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">locate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;class&quot;</span>, <span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Persion</span>()</span><br><span class="line">p.<span class="title function_">loacate</span>()</span><br><span class="line"><span class="title class_">Persion</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">loacate</span>()</span><br><span class="line"><span class="title class_">Persion</span>.<span class="title function_">locate</span>()</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>不能在类块中给原型添加原始值或者对象作为成员数据；</li>
<li>类方法等同于对象属性，因此可以使用字符串、符号（symbol）或者计算的值作为键</li>
<li>类定义支持获取和设置访问器（get，set方法）</li>
<li>类中支持书写生成器方法，可以通过添加一个默认的迭代器，把类变成可迭代对象；</li>
<li>虽然类定义不支持显示在原型或类中添加成员数据，但在类定义外部，可以手动添加；</li>
</ul>
<h5 id="8-4-4继承"><a href="#8-4-4继承" class="headerlink" title="8.4.4继承"></a>8.4.4继承</h5><p>ES6类仅支持单继承，使用extends关键字，就可以继承任何拥有[[constructor]]和原型的对象。不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）；</p>
<p>使用super()的注意事项：</p>
<ul>
<li>1，super只能在派生类构造函数和静态方法中使用；</li>
<li>2，不能单独使用super关键字，要么用它调用构造函数，要么用它调用静态方法；</li>
<li>3，调用super回调用父类构造函数，并将返回的实例赋值给this;</li>
<li>4, super的行为如同调用构造函数，如果需要给父类构造函数传入参数，则需要手动传入；</li>
<li>5，如果么有定义构造函数，在实例化派生类时会调用super,而且会传入所有传给派生类参数；</li>
<li>6，在类构造函数中，不能再调用super之前应用this;</li>
<li>7,如果在派生类中显示定义了构造函数，则要么必须在其中调用super,要么必须在其中返回一个对象；</li>
</ul>
<h6 id="抽象基类："><a href="#抽象基类：" class="headerlink" title="抽象基类："></a>抽象基类：</h6><p>假设需要这样一个类,可以供给其他类继承，但是本身不会被实例化；</p>
<p>ECMAScript并没有实现专门支持这种的语法，但是可以通过new.target容易实现。new.target保存通过new关键字调用的类或函数。</p>
<p>可以通过抽象类构造函数进行检查，要求派生类必须实现某一个方法；（P262页）</p>
<h6 id="继承内置类型"><a href="#继承内置类型" class="headerlink" title="继承内置类型"></a>继承内置类型</h6><p>ES6类为继承内置引用类型提供了顺畅的时机；</p>
<p>可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 自己实现很多方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些内置类型方法会返回新的实例。默认情况下，返回的实例类型与原始实例的类型是一致的；</p>
<p>如果想覆盖这个默认行为，则可以覆盖Symbol.species访问器，这个访问器决定在创建返回的是实例时使用；</p>
<h6 id="类的混入"><a href="#类的混入" class="headerlink" title="类的混入"></a>类的混入</h6><p>看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123; &#125;</span><br><span class="line"><span class="comment">// 定义一个foo混合</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">FooMixin</span> = (<span class="params">SuperClass</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个bar混合</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BarMixin</span> = (<span class="params">SuperClass</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个bar混合</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BazMixin</span> = (<span class="params">SuperClass</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;baz&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FooMixin</span>(<span class="title class_">BarMixin</span>(<span class="title class_">BazMixin</span>(<span class="title class_">Vehicle</span>))) &#123; &#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span>()</span><br><span class="line">b.<span class="title function_">foo</span>();  <span class="comment">// foo</span></span><br><span class="line">b.<span class="title function_">bar</span>();  <span class="comment">// bar</span></span><br><span class="line">b.<span class="title function_">baz</span>();  <span class="comment">// baz</span></span><br></pre></td></tr></table></figure>

<p>FooMixin(BarMixin(BazMixin(Vehicle)))这样子嵌套调用，不够优雅。</p>
<p>精进一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mix</span>(<span class="params">baseClass, ...Mixins</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Mixins</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, current</span>) =&gt;</span> <span class="title function_">current</span>(accumulator), baseClass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="09：代理与反射"><a href="#09：代理与反射" class="headerlink" title="09：代理与反射"></a>09：代理与反射</h3><blockquote>
<p>ES6新增的代理与反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，<strong>可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。</strong> 在对目标对象的各种操作<strong>影响目标对象之前</strong>，可以在代理对象中对这些操作加以控制。</p>
</blockquote>
<p>上面这段话是红宝书第9章开头对代理的介绍，我们可以将代理与第8章学到的一个方法 <code>Object.defineProperty()</code>进行比较，先回想一下<code>Object.defineProperty()</code>的作用是什么，它可以定义对象属性的内部特性，比如 <code>getter</code> 和 <code>setter</code>，这样就可以在我们访问对象属性之前先执行一些操作，那么我们<strong>把范围从对象的属性拓展到整个对象</strong>，就和代理的介绍中的话很像了，大概也能看明白这段话了。</p>
<h4 id="9-1代理基础"><a href="#9-1代理基础" class="headerlink" title="9.1代理基础"></a>9.1代理基础</h4><p>代理是目标对象的抽象，它<strong>类似</strong>于C++指针，因为<strong>它可以用作目标对象的替身，但又完全独立于目标对象。</strong>  目标对象<strong>可以</strong>直接被操作，也可以通过代理被操作，但是直接操作会绕过代理施予的行为。（注意，这里的类似只是为了帮助理解）</p>
<h5 id="9-1-1创建空的代理"><a href="#9-1-1创建空的代理" class="headerlink" title="9.1.1创建空的代理"></a>9.1.1创建空的代理</h5><p>空代理是最简单的代理，即除了作为一个抽象的目标对象，什么也不做。</p>
<p>代理是<strong>使用 Proxy构造函数</strong> 创建的。这个函数接收<strong>两个参数：1.目标对象，2.处理程序对象；</strong> （两个参数缺一不可）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Mac&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;</span><br><span class="line"><span class="comment">// 要创建空代理，只需要将一个简单的对象字面量作为处理程序对象即可</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target,handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问对象属性（这也是对对象的各种操作之一）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">name</span>); <span class="comment">// Mac</span></span><br><span class="line"><span class="comment">// 通过代理访问对象的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>); <span class="comment">// Mac</span></span><br></pre></td></tr></table></figure>

<p>给<strong>目标（对象的）属性</strong>赋值也会反映在两个对象上，<strong>因为两个对象访问的是同一个值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target.<span class="property">name</span> = <span class="string">&#x27;Deing&#x27;</span> <span class="comment">// 给目标属性赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">name</span>); <span class="comment">// Deing</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>); <span class="comment">// Deing</span></span><br></pre></td></tr></table></figure>

<p>给<strong>代理（对象的）属性</strong>赋值会反映在两个对象上，<strong>因为这个赋值会转移到目标对象（的对应属性）上</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;Gaga&#x27;</span> <span class="comment">// 给代理属性赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">name</span>); <span class="comment">// Gaga</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>); <span class="comment">// Gaga</span></span><br></pre></td></tr></table></figure>

<p><code>hasOwnProperty()</code> 方法在两个对象上使用<strong>都会应用到目标对象上。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>Proxy.prototype 是 undefined</strong>，因此不可以对其使用 <code>instanceof</code> 操作符，会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target <span class="keyword">instanceof</span> <span class="title class_">Proxy</span>); <span class="comment">// 报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy <span class="keyword">instanceof</span> <span class="title class_">Proxy</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p><strong>严格相等可以用来区分代理和目标。</strong> 因为就像上面提到的代理可以用作目标对象的替身，但<strong>又完全独立于目标对象。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target === proxy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>就像上面的代码所演示的，在代理对象上所执行的任何操作<strong>实际上都会应用到目标对象。</strong> 唯一可感知的不同就是代码中操作的是代理对象。</p>
<hr>
<p><strong>小结：</strong></p>
<p>上面这个小节，我们要注意的地方是，现在有两种对象了，一种是通过Object构造函数创建的普通对象，也就是我们的目标对象，另一种是通过Proxy构造函数创建的代理对象，<strong>代理对象是对目标对象的抽象，</strong> 在代理对象上执行的操作实际上都会应用到目标对象上，然后目标对象上的属性叫目标属性，代理对象上的属性叫代理属性，然后还有一个新的东西叫做<strong>处理程序对象</strong>，也就是 <code>handler</code>对象。</p>
<hr>
<h5 id="9-1-2定义捕获器"><a href="#9-1-2定义捕获器" class="headerlink" title="9.1.2定义捕获器"></a>9.1.2定义捕获器</h5><p>使用代理的主要目的是<strong>可以定义捕获器（trap）</strong>。捕获器就是在处理程序对象中定义的 <strong>“基本操作拦截器”</strong>。</p>
<p>每个处理程序对象可以包含0个或多个捕获器，<strong>每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。</strong></p>
<p>每次在代理对象上调用这些基本操作时，代理可以在这些操作<strong>传播到目标对象之前先调用</strong>捕获器函数，从而拦截并修改相应行为。</p>
<blockquote>
<p>捕获器是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个<strong>同步中断，</strong> 可以暂停程序流，转而执行一段子例程，<strong>之后再返回原始程序流。</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Macc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理程序对象</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// 定义get捕获器</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Deing&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理对象</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target,handler)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">name</span>); <span class="comment">// Macc</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>); <span class="comment">// Deing</span></span><br></pre></td></tr></table></figure>

<p>看上面的最后两行代码，需要我们注意的地方是，我们<strong>定义的捕获器只有在我们通过代理对象执行某些操作时才会触发，在目标对象上执行相同的操作仍然会产生正常的行为</strong>，这也就对应了上面我们提到的目标对象既可以直接被操作，也可以通过代理来操作，<strong>但直接操作会绕过代理施予的行为。</strong></p>
<p>倒数第二行代码就是直接操作目标对象，直接访问目标对象的name属性，绕过了捕获器，产生正常的行为，所以输出的是Macc。而倒数第一行代码则是通过代理对象去访问的name属性，因此触发了get捕获器，所以输出了Deing。</p>
<h5 id="9-1-3捕获器参数和反射API"><a href="#9-1-3捕获器参数和反射API" class="headerlink" title="9.1.3捕获器参数和反射API"></a>9.1.3捕获器参数和反射API</h5><p>所有的捕获器<strong>都可以访问相应的参数，</strong> 基于这些参数可以重建被捕获方法的原始行为。</p>
<h6 id="1-get捕获器的参数"><a href="#1-get捕获器的参数" class="headerlink" title="1.get捕获器的参数"></a>1.get捕获器的参数</h6><p>get捕获器会接收到<strong>目标对象，要查询的属性，代理对象</strong>三个参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Macc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理程序对象</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * get捕获器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; trapTarget 目标对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; property 要查询的属性</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Proxy</span>&#125; receiver 代理对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">trapTarget,property,receiver</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(trapTarget === target); <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(property); <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(receiver === proxy); <span class="comment">// true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理对象</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target,handler)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>); <span class="comment">// undefined 因为捕获器未返回任何值</span></span><br></pre></td></tr></table></figure>

<p>可以像下面这样使用这些参数重建被捕获方法的<strong>原始行为</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params">trapTarget,property,receiver</span>)&#123;</span><br><span class="line">    <span class="comment">// 重建被捕获方法的原始行为</span></span><br><span class="line">    <span class="keyword">return</span> trapTarget[property]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>所有捕获器都可以基于自己的参数重建原始行为，</strong> 但是并非所有捕获器都像get捕获器那么简单，因此手写代码重建原始行为不现实。我们可以通过<strong>调用全局Reflect对象上（封装了原始行为）的同名方法来重建原始行为。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>) <span class="comment">// 重建原始行为</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="attr">get</span>:<span class="title class_">Reflect</span>.<span class="property">get</span></span><br></pre></td></tr></table></figure>

<p>如果想要<strong>创建一个可以捕获所有方法，然后将每个方法转发给对应反射API的空代理</strong>，那么甚至不需要定义处理程序对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target,<span class="title class_">Reflect</span>)</span><br></pre></td></tr></table></figure>

<p>上面这种方法和处理程序对象传一个空对象的空代理是有区别的。</p>
<h5 id="9-1-4捕获器不变式"><a href="#9-1-4捕获器不变式" class="headerlink" title="9.1.4捕获器不变式"></a>9.1.4捕获器不变式</h5><p>使用捕获器<strong>几乎可以改变所有基本方法的行为，但也不是没有限制。</strong></p>
<p><strong>捕获器不变式（trap invariant）</strong> 因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。比如说，<strong>目标对象有一个不可配置且不可写的数据属性，</strong> 那么捕获器在返回一个与该属性不同的值时，就会抛出错误。</p>
<h5 id="9-1-5可撤销代理"><a href="#9-1-5可撤销代理" class="headerlink" title="9.1.5可撤销代理"></a>9.1.5可撤销代理</h5><p>对于使用 <code>new Proxy()</code> 创建的普通代理而言，这种联系会在代理对象的生命周期中一直持续存在。</p>
<p>Proxy暴露了 <code>revocable()</code> 方法，<strong>这个方法支持撤销代理对象与目标对象的关联。</strong></p>
<p><strong>撤销代理的操作是不可逆的。</strong></p>
<p>撤销函数 <code>revoke()</code> 是<strong>幂等的</strong>，调用多少次的结果都是一样的。</p>
<blockquote>
<p>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p>
</blockquote>
<p><strong>撤销代理后再调用</strong>代理会抛错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Macc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理程序对象 </span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Deing&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销函数与代理对象实在实例化时同时生成的</span></span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用代理</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>); <span class="comment">// Deing</span></span><br><span class="line"><span class="comment">// 撤销代理</span></span><br><span class="line"><span class="title function_">revoke</span>()</span><br><span class="line"><span class="comment">// 撤销代理后再次调用代理</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h5 id="9-1-6实用反射API"><a href="#9-1-6实用反射API" class="headerlink" title="9.1.6实用反射API"></a>9.1.6实用反射API</h5><p>首先介绍一下Reflect 对象</p>
<p>Reflect 对象不是构造函数，所以创建时不是用 new 来进行创建。</p>
<p>在 ES6 中增加这个对象的目的：</p>
<ul>
<li>将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，从 Reflect 对象上可以拿到语言内部的方法。</li>
<li>修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。</li>
<li>让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name)和 Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li>
<li>Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为</li>
</ul>
<p>上面有提到过反射API（ReflectAPI），那么在什么场景使用最好呢？</p>
<h6 id="1-反射API与对象API"><a href="#1-反射API与对象API" class="headerlink" title="1. 反射API与对象API"></a>1. 反射API与对象API</h6><p>首先要记住的两点是：</p>
<ol>
<li>反射API并<strong>不限于</strong>捕获处理程序；</li>
<li>大多数反射API方法在Object类型上都能找到对应的方法；</li>
</ol>
<blockquote>
<p>通常，object上的方法适用于通用程序，反射方法则<strong>适用于细粒度的对象控制与操作。</strong></p>
</blockquote>
<h6 id="2-状态标记"><a href="#2-状态标记" class="headerlink" title="2. 状态标记"></a>2. 状态标记</h6><p>状态标记就是对<strong>反射API返回的布尔类型的值</strong>的一种称呼，这个状态标记表示<strong>我们想要执行的操作是否执行成功了。</strong></p>
<p>有什么用呢？可以看下面的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;macc&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failure&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Object.defineProperty()</code> 方法在定义新属性发生问题时，会抛出错误，所以我们想要知道这个操作结果就要使用 <code>try...catch</code> 来获取，但是 <code>Reflect.defineProperty()</code> 则会在发生问题时返回 <code>false</code>，因此通过使用反射API，我们可以将上面的代码重构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> mark = <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(obj,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;macc&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span>(mark)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failure)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>除了 <code>Reflect.defineProperty</code> 会提供状态标记，下面这些API都会提供状态标记</p>
<table>
<thead>
<tr>
<th>方法名</th>
</tr>
</thead>
<tbody><tr>
<td><code>Reflect.preventExtensions</code></td>
</tr>
<tr>
<td><code>Reflect.setPropertyOf</code></td>
</tr>
<tr>
<td><code>Reflect.set</code></td>
</tr>
<tr>
<td><code>Reflect.deleteProperty</code></td>
</tr>
</tbody></table>
<h6 id="3-用一等函数代替操作符"><a href="#3-用一等函数代替操作符" class="headerlink" title="3.用一等函数代替操作符"></a>3.用一等函数代替操作符</h6><table>
<thead>
<tr>
<th>方法名</th>
<th>替代</th>
</tr>
</thead>
<tbody><tr>
<td><code>Reflect.get</code></td>
<td>可替代对象访问操作符 <code>.</code></td>
</tr>
<tr>
<td><code>Reflect.set</code></td>
<td>可替代 <code>=</code> 赋值操作符</td>
</tr>
<tr>
<td><code>Reflect.has</code></td>
<td>可替代 <code>in</code> 操作符 和 <code>with()</code></td>
</tr>
<tr>
<td><code>Reflect.deleteProperty</code></td>
<td>可替代 <code>delete</code> 操作符</td>
</tr>
<tr>
<td><code>Reflect.construct</code></td>
<td>可替代 <code>new</code> 操作符</td>
</tr>
</tbody></table>
<h6 id="4-安全地应用函数"><a href="#4-安全地应用函数" class="headerlink" title="4.安全地应用函数"></a>4.安全地应用函数</h6><p>设想一个场景，假设我们在通过 <code>apply</code> 函数调用函数时，被调用的函数自身也定义了自己的 <code>apply</code> 属性，那么调用的结果肯定不是我们所期望的。这种问题可以通过使用<strong>定义在 Function 原型上的 apply 方法来解决。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(<span class="title class_">Fun</span>,thisVal,args)</span><br></pre></td></tr></table></figure>

<p>但是更好的解决方式则是<strong>使用反射API Reflect.apply 来解决</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Fun</span>,thisVal,args)</span><br></pre></td></tr></table></figure>

<h5 id="9-1-7代理另一个代理"><a href="#9-1-7代理另一个代理" class="headerlink" title="9.1.7代理另一个代理"></a>9.1.7代理另一个代理</h5><p>代理可以代理另一个代理</p>
<h5 id="9-1-8代理的问题与不足"><a href="#9-1-8代理的问题与不足" class="headerlink" title="9.1.8代理的问题与不足"></a>9.1.8代理的问题与不足</h5><p>1.this指向问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123;</span><br><span class="line">  a() &#123;</span><br><span class="line">    return this === proxy</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const proxy = new Proxy(target, &#123;&#125;)</span><br><span class="line">console.log(target.a) //fasle</span><br><span class="line">console.log(proxy.a) //true</span><br></pre></td></tr></table></figure>

<h4 id="9-2代理捕获器与反射方法"><a href="#9-2代理捕获器与反射方法" class="headerlink" title="9.2代理捕获器与反射方法"></a>9.2代理捕获器与反射方法</h4><p>常用的方法(13个)：</p>
<ul>
<li>get</li>
<li>set</li>
<li>has</li>
<li>defineProperty</li>
<li>getOwnPropertyDescriptor</li>
<li>deleteProperty</li>
<li>ownKeys</li>
<li>getPrototypeOf</li>
<li>setPrototypeOf</li>
<li>isExtendsible</li>
<li>preventExtendsions</li>
<li>apply</li>
<li>constructor</li>
</ul>
<p>用法都比较简单,由于篇幅限制就不在此赘叙了</p>
<h4 id="9-3代理模式"><a href="#9-3代理模式" class="headerlink" title="9.3代理模式"></a>9.3代理模式</h4><p>使用代理可以在代码中实现一些有用的编程</p>
<ul>
<li>1，跟踪属性访问</li>
<li>2，隐藏属性</li>
<li>3，属性检验</li>
<li>4，函数与构造函数参数验证</li>
<li>5，数据绑定与可观察对象</li>
</ul>
<h3 id="10：函数"><a href="#10：函数" class="headerlink" title="10：函数"></a>10：函数</h3><p>函数的定义</p>
<p>函数有四种定义方式：</p>
<ul>
<li>1，函数声明</li>
<li>2，函数表达式</li>
<li>3，箭头函数</li>
<li>4，使用Function创建对象</li>
</ul>
<p>注意一点：第四种方式不推荐；但是对于理解函数是一个对象，函数名指向这个对象很有帮助；</p>
<h4 id="10-1箭头函数"><a href="#10-1箭头函数" class="headerlink" title="10.1箭头函数"></a>10.1箭头函数</h4><p>传参如果有一个参数可以省略小括号；</p>
<p>返回值如果是一行，可以省略return 语句；</p>
<p>值得注意的是：</p>
<p>不能使用arguments，super和new.target,也不能用于构造函数，还没有prototype属性；</p>
<h4 id="10-2函数名"><a href="#10-2函数名" class="headerlink" title="10.2函数名"></a>10.2函数名</h4><p>函数名就是指向函数的一个指针，所以一个函数可以有多个函数名的指向；</p>
<p>ESMAScript6的所有函数都暴露一个只读name属性；就是一个函数的标识符，即使没有名称，也会返回一个空字符串，如果是Function构造函数创建的，则会标识成”anonymous”</p>
<h4 id="10-3理解参数"><a href="#10-3理解参数" class="headerlink" title="10.3理解参数:"></a>10.3理解参数:</h4><p>问题：定义函数的时候需要接受两个参数，并不意味着调用的时候就传入两个参数，你可以传入一个或者是三个或者任意多个，解释器不会报错，这是为什么呢？</p>
<p>答案：因为ECMAScript函数的参数在内部表现为一个数组。函数调用时总接受一个数组，但是并不关心这个数组包含什么。如果数组什么也没有，没有问题；如果数组的元素超出了要求，也没问题。</p>
<h5 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h5><p>在使用function关键字定义（非箭头）函数时，可以在函数内部访问arguments对象，从中取得传进来的每一个参数；</p>
<p>可以使用arguments.lenth属性检查传入的参数个数；根据不同的个数实现函数的重载；</p>
<h5 id="箭头函数的参数："><a href="#箭头函数的参数：" class="headerlink" title="箭头函数的参数："></a>箭头函数的参数：</h5><p>箭头函数中不能使用arguments关键字访问，而只能通过定义的命名参数访问；</p>
<p>虽然箭头函数没有arguments对象，但是可以在包装函数找那个把它提供给箭头函数；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">bar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<h4 id="10-4函数没有重载"><a href="#10-4函数没有重载" class="headerlink" title="10.4函数没有重载"></a>10.4函数没有重载</h4><p>如何理解js的函数没哟重载？</p>
<p>ECMAScript函数没有签名，因为参数是有包含零个或者多个值的数组表示的。没有函数签名就没有重载； 后面定义同名的函数会覆盖前面定义的函数；但是可以通过判断arguments对象的长度或者参数类型做出相应的处理；ts就是这样处理的</p>
<p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function reverse(x: number | string): number | string | void &#123;</span><br><span class="line">    if (typeof x === &#x27;number&#x27;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));</span><br><span class="line">    &#125; else if (typeof x === &#x27;string&#x27;) &#123;</span><br><span class="line">        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//然而这样不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。应该如下写,前二者是规则,后者是输出</span><br><span class="line">function reverse(x: number): number;</span><br><span class="line">function reverse(x: string): string;</span><br><span class="line">function reverse(x: number | string): number | string | void &#123;</span><br><span class="line">    if (typeof x === &#x27;number&#x27;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));</span><br><span class="line">    &#125; else if (typeof x === &#x27;string&#x27;) &#123;</span><br><span class="line">        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-5默认参数"><a href="#10-5默认参数" class="headerlink" title="10.5默认参数"></a>10.5默认参数</h4><p>在ES5及以前，实现默认参数就是判断这个是不是undefined，如果是就手动给一个默认值，如果不是就不做任何操作；</p>
<p>ES6之后就支持定义函数的时候给默认参数了；</p>
<p>有这样一个需求，有下面的一个函数，定义了两个默认参数，第一个默认参数是num1 &#x3D; 10,第二个默认参数时候num2 &#x3D; 20； 第一个参数与使用默认值，第二个参数传入特定值；该怎么做的？</p>
<p>尝试1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (num1 = <span class="number">10</span>, num2 = <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(num2 = <span class="number">40</span>))  <span class="comment">// 60</span></span><br></pre></td></tr></table></figure>

<p>这里不会理会你传入的num2&#x3D;40,而是把这个表达式计算的到的值40赋值给了第一个参数，num2默认参数，所以打印60；</p>
<p>其实正确的是传入add(undefined,40),该参数undefined相当于是没有传值，可以跳过第一个参数，给第二个参数传参；</p>
<h5 id="默认参数作用域与暂时性死区"><a href="#默认参数作用域与暂时性死区" class="headerlink" title="默认参数作用域与暂时性死区"></a>默认参数作用域与暂时性死区</h5><p>参数是按照顺序初始化的，所以后定义的默认值的参数可以引用先定义的参数；</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;lsj&#x27;</span>, numerals = name</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数初始化顺序遵循“暂时性死区”规则，即前面定义的不能引用后面定义的；</li>
<li>参数也存在于自己的作用域，他们不能引用函数体的作用域；</li>
</ul>
<h4 id="10-6参数扩展与收集"><a href="#10-6参数扩展与收集" class="headerlink" title="10.6参数扩展与收集"></a>10.6参数扩展与收集</h4><h5 id="扩展参数"><a href="#扩展参数" class="headerlink" title="扩展参数"></a>扩展参数</h5><p>在给函数传参时，有时候不需要传入一个数组，而是要分开传入数组的元素；ES6之前需要借助apply（）方法，ES6中通过扩展操作符很简单的实现找各种操作；</p>
<h5 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a>收集参数</h5><p>在函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。</p>
<p>注意：</p>
<ul>
<li>收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组；</li>
<li>因为收集参数的结果可变，所以只能把它作为最后一个参数；</li>
</ul>
<p>箭头函数虽然不支持arguments对象，但是支持收集参数的定义方式，因此可以实现与arguments一样的逻辑；</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li>在函数内部使用…操作符，就是收集参数；</li>
<li>在函数调用传参的时候使用…操作符，就是扩展参数；</li>
</ul>
<h4 id="10-7函数声明与函数表达式"><a href="#10-7函数声明与函数表达式" class="headerlink" title="10.7函数声明与函数表达式"></a>10.7函数声明与函数表达式</h4><p>区别：</p>
<p>函数声明：js引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义；</p>
<p>函数表达式：必须等到代码执行到它的那一行，才会在执行上下文中生成函数定义；</p>
<p>值得注意一点是函数声明提升，在执行代码时，js引擎会先执行一遍扫描，把发现的函数声明提升到源代码书的顶部；所以就会出现在函数声明之前调用函数不会报错的原因；</p>
<h4 id="10-8函数作为值"><a href="#10-8函数作为值" class="headerlink" title="10.8函数作为值"></a>10.8函数作为值</h4><p>因为函数名在ECMAScript中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另外一个函数。</p>
<p>看看下面的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据属性名字排序</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">prototypeName</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">object1, object2</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> val1 = object1[prototypeName]</span><br><span class="line">        <span class="keyword">let</span> val2 = object2[prototypeName]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val1 &lt; val2) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val1 &gt; val2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;lsj&#x27;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;zm&#x27;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;applyÍ&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> data2 = data.<span class="title function_">sort</span>(<span class="title function_">createComparisonFunction</span>(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data2)</span><br></pre></td></tr></table></figure>

<p>很实用的一个排序方法；</p>
<p>默认情况下，sort()方法要对两个对象执行toString(),然后再来决定他们的顺序，但这样毫无意义。可以通过上面方法创建一个比较函数根据属性来做比较；</p>
<h4 id="10-9函数内部"><a href="#10-9函数内部" class="headerlink" title="10.9函数内部"></a>10.9函数内部</h4><p>类数组对象arguments：包含调用函数时传入的所有参数</p>
<p>类数组:可以通过索引访问元素，并且拥有length属性。没有数组的其它方法,例如:push，forEach，indexOf等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let foo = &#123;</span><br><span class="line">    0: &#x27;白茶&#x27;,</span><br><span class="line">    1: 23,</span><br><span class="line">    2: &#x27;man&#x27;,</span><br><span class="line">    length: 3</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>属性caller：这个属性引用的是调用当前函数的函数，如果是在全局作用域中调用则为null</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">    inner()</span><br><span class="line">    console.log(&#x27;111&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">function inner() &#123;</span><br><span class="line">    console.log(inner.caller)</span><br><span class="line">&#125;</span><br><span class="line">outer()</span><br><span class="line">----------------------------------输出</span><br><span class="line">outer() &#123;</span><br><span class="line">    inner()</span><br><span class="line">    console.log(&#x27;111&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">111</span><br></pre></td></tr></table></figure>

<p>ES6新加的属性new.target:检测函数是否是使用new 调用的，如果不是用new 调用的话，值为undefined</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function king（） &#123;</span><br><span class="line">	if（new.target）&#123;</span><br><span class="line">		console.log(&#x27;使用了new 调用&#x27;)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		console.log(&#x27;未使用了new 调用&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">new king（）//使用了new 调用</span><br><span class="line">king() //未使用了new 调用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>this：指向某个对象，这个对象我们称为函数执行的上下文对象</p>
<ul>
<li>直接调用函数时，this指向window。</li>
<li>以方法的形式调用时，this指向包含调用方法的那个对象。</li>
<li>当以构造函数的形式调用时,this就是新创建的那个对象</li>
<li>使用call(),apply(),bind()调用时,this就是指向方法中的对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.color = &#x27;blue&#x27;</span><br><span class="line">let o = &#123;</span><br><span class="line">	color: &#x27;red&#x27;</span><br><span class="line">&#125;</span><br><span class="line">function sayColor () &#123;</span><br><span class="line">	console.log(this.color)</span><br><span class="line">&#125;</span><br><span class="line">sayColor()//blue</span><br><span class="line">//以方法的形式调用时，this指向包含调用方法的那个对象,Vue的官方文档说明了：在vue中methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。所以方法中的 this自动绑定为 Vue 实例。</span><br><span class="line">o.sayColor = sayColor</span><br><span class="line">o.sayColor()//red</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//构造函数本质也只是一个函数，只是该函数会返回一个对象，当使用new操作符时，new会将this指向新创建的那个对象，</span><br><span class="line">var  a = new A();</span><br><span class="line"></span><br><span class="line">假设我们要创建一个构造函数A()的实例a，则必须使用new操作符。会经历以下4个步骤：</span><br><span class="line"></span><br><span class="line">（1）创建一个空对象（var o=new Object();）</span><br><span class="line"></span><br><span class="line">（2）将空对象的隐式原型属性赋值为构造函数A的原型（o.__proto__=A.prototype;）</span><br><span class="line"></span><br><span class="line">（3）执行构造函数中的代码，为空对象添加属性（A.call(o);），也可以理解为将构造器函数内部this指向新建的空对象。</span><br><span class="line"></span><br><span class="line">（4）返回添加属性后的对象。</span><br><span class="line"> function Person(name,age)&#123;</span><br><span class="line">   this.age = age;</span><br><span class="line">   this.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"> var lyb = new Person(name=&quot;李阳滨&quot;,age=21);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">call(),apply()接收参数的方式不同,</span><br><span class="line"></span><br><span class="line">call(),bind()区别：call()改过this的指向后，会再执行函数，bind()改过this后，不执行函数，会返回一个绑定新this的函数</span><br><span class="line"></span><br><span class="line">1.call()</span><br><span class="line">function fn1(a,b)&#123;</span><br><span class="line">  console.log(this,a+b);</span><br><span class="line">&#125;</span><br><span class="line">function fn2(a,b)&#123;</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    color: &quot;blue&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  fn1.call(obj,10,20); // obj,30</span><br><span class="line">&#125;</span><br><span class="line">fn2(1,2);</span><br><span class="line">2.apply()</span><br><span class="line">function fn1(a,b)&#123;</span><br><span class="line">  console.log(a+b);</span><br><span class="line">&#125;</span><br><span class="line">function fn2(a,b)&#123;</span><br><span class="line">  // arguments把a,b的1,2传给fn1。</span><br><span class="line">  fn1.apply(this,arguments); // 3</span><br><span class="line">  fn1.apply(this,[20,30]); // 50</span><br><span class="line">&#125;</span><br><span class="line">fn2(1,2);</span><br><span class="line">3.bind()</span><br><span class="line"> window.color = &quot;red&quot;;</span><br><span class="line"> var obj = &#123;</span><br><span class="line">   color: &quot;blue&quot;</span><br><span class="line"> &#125;</span><br><span class="line"> function fn1()&#123;</span><br><span class="line">   console.log(this.color);</span><br><span class="line"> &#125;</span><br><span class="line"> var a = fn1.bind(obj);</span><br><span class="line"> //此时this指向obj.  this.color则为obj的属性blue</span><br><span class="line"> a(); //blue</span><br></pre></td></tr></table></figure>

<p>箭头函数没有自己的this，箭头函数的this指向在定义（<strong>注意：</strong>是定义时，不是调用时）的时候继承自外层第一个普通函数的this</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  b: () =&gt; &#123;</span><br><span class="line">    console.log(this.a); // undefined</span><br><span class="line">    console.log(this); // Window </span><br><span class="line">  &#125;,</span><br><span class="line">  c: function() &#123;</span><br><span class="line">    console.log(this.a); // 10</span><br><span class="line">    console.log(this); // &#123;a: 10, b: ƒ, c: ƒ&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b(); </span><br><span class="line">obj.c();</span><br></pre></td></tr></table></figure>

<p>箭头函数不能作为构造函数使用</p>
<p>我们先了解一下构造函数的new都做了些什么？简单来说，分为四步： ① JS内部首先会先生成一个对象； ② 再把函数中的this指向该对象； ③ 然后执行构造函数中的语句； ④ 最终返回该对象实例。</p>
<p>但是！！因为箭头函数没有自己的<code>this</code>，它的<code>this</code>其实是继承了外层执行环境中的<code>this</code>，且<code>this</code>指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用new调用时会报错！</p>
<p>call | apply | bind 无法改变箭头函数中this的指向</p>
<p><code>call | apply | bind</code>方法可以用来动态修改函数执行时this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数<code>this</code>的指向。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="number">10</span>;</span><br><span class="line">let <span class="function"><span class="keyword">fun</span> = <span class="params">()</span></span> =&gt; &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span></span>;     <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">fun</span>.call(&#123; id: <span class="number">20</span> &#125;);     <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">fun</span>.apply(&#123; id: <span class="number">20</span> &#125;);    <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">fun</span>.bind(&#123; id: <span class="number">20</span> &#125;)();   <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h4 id="10-10函数属性和方法"><a href="#10-10函数属性和方法" class="headerlink" title="10.10函数属性和方法"></a>10.10函数属性和方法</h4><h5 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h5><p>每一个函数都有两个属性：length和prototype</p>
<p>length属性保存函数定义的命名参数的个数；</p>
<p>prototype是保存引用类型所有实例方法的地方，向toString(),valueOf()等方法都保存在prototype上，进而由所有实例共享；</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>函数还有下满几个方法call,apply,bind</p>
<p>都是改变this指向的；</p>
<h4 id="10-11函数表达式"><a href="#10-11函数表达式" class="headerlink" title="10.11函数表达式"></a>10.11函数表达式</h4><p>为什么有了函数声明，还会有函数表达式的出现？</p>
<p>看看下面的场景，适用于函数表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">if</span> (falg) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sayHi</span> () &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sayHi</span> () &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Yo&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器纠正这个问题的方式并不一样，多数浏览器会忽略falg直接返回第二个声明，Firefox会在flag为true时返回第一个声明。这种写法很危险，所以需要用下面的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayHi;</span><br><span class="line"><span class="keyword">if</span> (falg) &#123;</span><br><span class="line">    sayHi = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sayHi = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Yo&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个使用场景就是闭包，一个函数返回另外一个函数，然后用变量接受，也是一种函数表达式的用法；</p>
<h4 id="10-12递归"><a href="#10-12递归" class="headerlink" title="10.12递归"></a>10.12递归</h4><p>递归函数就是一个函数通过名称调用自己；</p>
<p>注意点：编写递归函数时，arguments.callee是引用当前函数的首选；</p>
<p>不过在严格模式下运行的代码不能访问argument.callee的，会访问出错，可以使用命名函数表达式达到目的；</p>
<h4 id="10-13尾调用优化"><a href="#10-13尾调用优化" class="headerlink" title="10.13尾调用优化"></a>10.13尾调用优化</h4><p>尾调用:外部函数的返回值是一个内部函数的返回值；</p>
<p>比较绕，看下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outFun</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">innerFun</span>() <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="尾调用优化的条件"><a href="#尾调用优化的条件" class="headerlink" title="尾调用优化的条件"></a>尾调用优化的条件</h5><ul>
<li>代码在严格模式下执行；</li>
<li>外部函数的返回值是对尾调用函数的调用；</li>
<li>尾调用的函数返回之后不需要执行额外的逻辑；</li>
<li>尾调用函数不是引用外部函数作用域中自由变量的闭包</li>
</ul>
<p>这种尾调用优化在递归的场景下优化效果很明显；</p>
<h4 id="10-14闭包"><a href="#10-14闭包" class="headerlink" title="10.14闭包"></a>10.14闭包</h4><h5 id="一-定义"><a href="#一-定义" class="headerlink" title="(一)定义"></a>(一)定义</h5><p>闭包是一个存在于<strong>被外部函数嵌套</strong>的内部函数中的包含被引用变量的<strong>对象</strong></p>
<h5 id="二-产生条件"><a href="#二-产生条件" class="headerlink" title="(二)产生条件"></a>(二)产生条件</h5><p>1.函数存在嵌套</p>
<p>2.内部函数引用了外部函数的数据</p>
<p>3.外部函数被调用(内部函数被定义就会产生闭包,不需要调用内部函数)</p>
<h5 id="三-作用"><a href="#三-作用" class="headerlink" title="(三)作用"></a>(三)作用</h5><p>1.正常情况下,函数执行完后内部声明的局部变量不会存在。但是闭包可以让这些变量的值始终保持在内存中。</p>
<p>2.正常情况下,函数外部不可以直接访问函数内部的局部变量。但是闭包可以读取函数内部的变量；</p>
<h5 id="补充-3"><a href="#补充-3" class="headerlink" title="补充"></a>补充</h5><p>就这么直接讲,可能当时看书还能理解闭包,但是后面再看笔记估计又会忘记,在这里贴两位博主关于闭包的理解,我觉得他们两个讲的很不错,能够帮助深刻理解闭包<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7097141521102667813#heading-0">深入理解JS闭包 - 掘金 (juejin.cn)</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/106287246">JavaScript中闭包的概念、原理、作用及应用 - 知乎 (zhihu.com)</a></p>
<h5 id="闭包引发的内存泄漏"><a href="#闭包引发的内存泄漏" class="headerlink" title="闭包引发的内存泄漏"></a>闭包引发的内存泄漏</h5><p>看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assignHandle</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.textDom&quot;</span>)</span><br><span class="line">    element.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(element.<span class="property">className</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码创建了一个闭包，即element元素的事件处理程序，而这个事件处理程序有创建了一个循环引用；匿名函数引用assignHandle的活动对象，阻止了对element的引用计数清零；只要这匿名函数存在，element的引用计数就至少是1，就是说内存不会被回收；</p>
<p>对这个例子稍加修改可以避免这种情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assignHandle</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.textDom&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> className = element.<span class="property">className</span></span><br><span class="line">    element.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(className)</span><br><span class="line">    &#125;</span><br><span class="line">    element = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改之后：闭包改为引用一个保存着element.id变量的id,从而消除了循环引用。不过，光有这一步还不足以解决内存问题；因为闭包还是会引用包含函数的活动对象，而其中包含element。即使闭包没有直接使用element，包含函数的活动对象上还是保存着这对它的引用。因此，必须把element设置为null，就解除了对这个COM对选哪个的引用，其引用计数也会减少，从而确保其内存可以在适当的时候被回收；</p>
<h4 id="10-15立即调用的函数表达式"><a href="#10-15立即调用的函数表达式" class="headerlink" title="10.15立即调用的函数表达式"></a>10.15立即调用的函数表达式</h4><p>也成为自执行函数，就是定义一个匿名函数，定义完了之后加上小括号自己调用</p>
<p>在ES6之前经常用于模拟块级作用域；</p>
<h4 id="10-16私有变量"><a href="#10-16私有变量" class="headerlink" title="10.16私有变量"></a>10.16私有变量</h4><p>严格来讲，JavaScript 没有私有成员的概念，所有对象属性都公有的。不过，倒是有私有变量的概念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数</p>
<p>特权方法（privileged method）是能够访问函数私有变量（及私有函数）的公有方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> name; </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123; </span><br><span class="line">    name = value; </span><br><span class="line"> &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Nicholas&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Nicholas&#x27; </span></span><br><span class="line">person.<span class="title function_">setName</span>(<span class="string">&#x27;Greg&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Greg&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这段代码中的构造函数定义了两个特权方法：getName()和setName()。每个方法都可以构造函数外部调用，并通过它们来读写私有的name变量。在Person构造函数外部，没有别的办法访问 name。因为两个方法都定义在构造函数内部，所以它们都是能够通过作用域链访问 name 的闭包。私有变量name 对每个Person实例而言都是独一无二的，因为每次调用构造函数都会重新创建一套变量和方法。不过这样也有个问题：必须通过构造函数来实现这种隔离。</p>
<p>构造函数模式的缺点是每个实例都会重新创建一遍新方法。</p>
<h5 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line">person1.<span class="title function_">setName</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Michael&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Michael&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Michael&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这里的Person构造函数可以访问私有变量name，跟getName()和setName()方法一样。使用这种模式，name变成了静态变量，可供所有实例使用。这意味着在任何实例上调用setName()修改这个变量都会影响其他实例。调用setName()或创建新的Person实例都要把name变量设置为一个新值。而所有实例都会返回相同的值</p>
<p>像这样创建静态私有变量可以利用原型更好地重用代码，只是每个实例没有了自己的私有变量。最终，到底是把私有变量放在实例中，还是作为静态私有变量，都需要根据自己的需求来确定。</p>
<h5 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h5><p>单例对象（singleton）就是只有一个实例的对象。</p>
<p>模块模式是在单例对象基础上加以扩展,对象字面量定义了单例对象的公共接口。如果单例对象需要进行某种初始化，并且需要访问私有变量时，那就可以采用这个模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 私有变量和私有函数 </span></span><br><span class="line"><span class="keyword">let</span> components = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">components.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">BaseComponent</span>());</span><br><span class="line"><span class="comment">// 公共接口</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="title function_">getComponentCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> components.<span class="property">length</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">registerComponent</span>(<span class="params">component</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      components.<span class="title function_">push</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h5 id="模块增强模式"><a href="#模块增强模式" class="headerlink" title="模块增强模式"></a>模块增强模式</h5><p>另一个利用模块模式的做法是在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性或方法的场景。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建对象</span></span><br><span class="line">  <span class="keyword">let</span> object = <span class="keyword">new</span> <span class="title class_">CustomType</span>();</span><br><span class="line">  <span class="comment">// 添加特权/公有属性和方法</span></span><br><span class="line">  object.<span class="property">publicProperty</span> = <span class="literal">true</span>;</span><br><span class="line">  object.<span class="property">publicMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    privateVariable++;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">privateFunction</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 返回对象</span></span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="11：期约与异步函数"><a href="#11：期约与异步函数" class="headerlink" title="11：期约与异步函数"></a>11：期约与异步函数</h3><h4 id="11-1异步编程"><a href="#11-1异步编程" class="headerlink" title="11.1异步编程"></a>11.1异步编程</h4><p>在 JavaScript 这种单线程事 件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而 时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定。</p>
<p><strong>11.1.1 同步与异步</strong></p>
<p>同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每 条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。</p>
<p>相对地，异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必 要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问 一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。</p>
<h5 id="11-1-2-以往的异步编程模式"><a href="#11-1-2-以往的异步编程模式" class="headerlink" title="11.1.2 以往的异步编程模式"></a><strong>11.1.2 以往的异步编程模式</strong></h5><p>在早期的 JavaScript 中，只支持定义回调函数 来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回 调地狱”）来解决。</p>
<p>随着代码越来越复杂，回调策略是不具有扩展性的。“回调地狱)”这个称呼可谓名至实归。 嵌套回调的代码维护起来就是噩梦。</p>
<h5 id="Evnet-Loop回顾"><a href="#Evnet-Loop回顾" class="headerlink" title="Evnet Loop回顾"></a>Evnet Loop回顾</h5><p>单线程就意味着所有的任务都需要排队，后面的任务需要等前面的任务执行完才能执行，如果前面的任务耗时过长，后面的任务就需要一直等，一些从用户角度上不需要等待的任务就会一直等待，这个从体验角度上来讲是不可接受的，所以<code>JS</code>中就出现了异步的概念。</p>
<h6 id="一-同步任务"><a href="#一-同步任务" class="headerlink" title="(一)同步任务"></a>(一)同步任务</h6><p>代码从上到下按顺序执行</p>
<h6 id="二-异步任务"><a href="#二-异步任务" class="headerlink" title="(二)异步任务"></a>(二)异步任务</h6><p>1.宏任务</p>
<p>script(整体代码)、setTimeout、setInterval、UI交互事件、postMessage、Ajax</p>
<p>2.微任务</p>
<p>Promise.then catch finally、MutaionObserver、process.nextTick(Node.js 环境)</p>
<h6 id="三-运行机制"><a href="#三-运行机制" class="headerlink" title="(三)运行机制"></a>(三)运行机制</h6><p>所有的同步任务都是在主进程执行的形成一个执行栈，主线程之外，还存在一个”任务队列”，异步任务执行队列中先执行宏任务，然后清空当次宏任务中的所有微任务，然后进行下一个tick如此形成循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">async function Prom() &#123;</span><br><span class="line">    console.log(&quot;Y&quot;)</span><br><span class="line">    await Promise.resolve()</span><br><span class="line">    console.log(&quot;X&quot;)</span><br><span class="line">&#125;</span><br><span class="line">const x1 = setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, 0);</span><br><span class="line">const x2 =setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">    Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">        console.log(4)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, 0);</span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">&#125;)</span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(6)</span><br><span class="line">&#125;)</span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(7)</span><br><span class="line">&#125;)</span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(8)</span><br><span class="line">&#125;)</span><br><span class="line">Prom()</span><br><span class="line">console.log(0)</span><br><span class="line"></span><br><span class="line">//先执行主线程:</span><br><span class="line">	同步任务:</span><br><span class="line">		prom()=================&gt;Y</span><br><span class="line">		console.log(0)=========&gt;0</span><br><span class="line">	异步宏任务:</span><br><span class="line">		x1=====================&gt;注意只是执行x1,不是执行x1中语句</span><br><span class="line">		x2</span><br><span class="line">	异步微任务:</span><br><span class="line">		Promise.resolve().then(()=&gt;&#123;...&#125;)========&gt;5 6 7 8 </span><br><span class="line">	prom中的异步语句:</span><br><span class="line">		await会阻塞程序执行,所以后面的console.log(&quot;X&quot;)写在后面跟写在Promise.resolve()里面差不		  多========================================&gt;X</span><br><span class="line">	x1中语句:</span><br><span class="line">		同步任务===================================&gt;1</span><br><span class="line">		异步任务===================================&gt;2</span><br><span class="line">	x2中语句:</span><br><span class="line">		同步任务===================================&gt;3</span><br><span class="line">		异步任务===================================&gt;4</span><br></pre></td></tr></table></figure>

<h4 id="11-2-期约"><a href="#11-2-期约" class="headerlink" title="11.2 期约"></a>11.2 期约</h4><h5 id="11-2-1-Promises-x2F-A-规范"><a href="#11-2-1-Promises-x2F-A-规范" class="headerlink" title="11.2.1 Promises&#x2F;A+规范"></a><strong>11.2.1 Promises&#x2F;A+规范</strong></h5><p>ECMAScript 6 增加了对 Promises&#x2F;A+规范的完善支持，即 Promise 类型。一经推出，Promise 就 大受欢迎，成为了主导性的异步编程机制。所有现代浏览器都支持 ES6 期约，很多其他浏览器 API（如 fetch()和 Battery Status API）也以期约为基础.</p>
<h5 id="11-2-2-期约基础"><a href="#11-2-2-期约基础" class="headerlink" title="11.2.2 期约基础"></a><strong>11.2.2 期约基础</strong></h5><p>ECMAScript 6 新增的引用类型 Promise，可以通过 new 操作符来实例化。创建新期约时需要传入 执行器（executor）函数作为参数.</p>
<p><strong>1. 期约状态机</strong></p>
<p>期约是一个有状态的对象，可能处于如下 3 种状态之一：</p>
<p>待定（pending）<br>兑现（fulfilled，有时候也称为“解决”，resolved）<br>拒绝（rejected）</p>
<p>待定（pending）是期约的最初始状态。在待定状态下，期约可以落定（settled）为代表成功的兑现 （fulfilled）状态，或者代表失败的拒绝（rejected）状态。无论落定为哪种状态都是不可逆的。只要从待 定转换为兑现或拒绝，期约的状态就不再改变。</p>
<p><strong>2. 解决值、拒绝理由及期约用例</strong></p>
<p>期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。“待定” 表示尚未开始或者正在执行中。“兑现”表示已经成功完成，而“拒绝”则表示没有成功完成。</p>
<p><strong>3. 通过执行函数控制期约状态</strong></p>
<p>控制期约状态的转换是 通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve()和 reject()。调用 resolve()会把状态切换为兑现，调用 reject()会把状态切换为拒绝。另外，调用 reject()也会抛 出错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt;</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught error (in promise)</span></span><br></pre></td></tr></table></figure>

<p><strong>4. Promise.resolve()</strong></p>
<p>期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用 Promise.resolve()静态方法，可以实例化一个解决的期约。对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此， Promise.resolve()可以说是一个幂等方法，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p === <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p));<span class="comment">// true</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p === <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)));<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>注意，这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也 可能导致不符合预期的行为：</p>
<p><strong>5. Promise.reject()</strong></p>
<p>与 Promise.resolve()类似，Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误 （这个错误不能通过 try&#x2F;catch 捕获，而只能通过拒绝处理程序捕获）。</p>
<p>这个拒绝的期约的理由就是传给 Promise.reject()的第一个参数。这个参数也会传给后续的拒 绝处理程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;rejected&gt;: 3</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, e)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>关键在于，Promise.reject()并没有照搬 Promise.resolve()的幂等逻辑。如果给它传一个期 约对象，则这个期约会成为它返回的拒绝期约的理由：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>()));</span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt;: Promise &lt;resolved&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>6. 同步&#x2F;异步执行的二元性。</strong></p>
<p>同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介.</p>
<p><strong>在前面的例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队 列来处理的。因此，try&#x2F;catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互 的方式就是使用异步结构——更具体地说，就是期约的方法。</strong></p>
<h5 id="11-2-3-期约的实例方法"><a href="#11-2-3-期约的实例方法" class="headerlink" title="11.2.3 期约的实例方法"></a><strong>11.2.3 期约的实例方法</strong></h5><p><strong>1. 实现 Thenable 接口</strong></p>
<p>在 ECMAScript 暴露的异步结构中，任何对象都有一个 then()方法。这个方法被认为实现了 Thenable 接口。</p>
<p><strong>2. Promise.prototype.then()</strong></p>
<p>Promise.prototype.then()是为期约实例添加处理程序的主要方法。这个 then()方法接收最多 两个参数：onResolved 处理程序和 onRejected 处理程序。这两个参数都是可选的，如果提供的话， 则会在期约分别进入“兑现”和“拒绝”状态时执行。</p>
<p><strong>3. Promise.prototype.catch()</strong></p>
<p>Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数： onRejected 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 Promise.prototype. then(null, onRejected)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line"><span class="keyword">let</span> onRejected = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这两种添加拒绝处理程序的方式是一样的：</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected); <span class="comment">// rejected</span></span><br><span class="line">p.<span class="title function_">catch</span>(onRejected); <span class="comment">// rejected </span></span><br></pre></td></tr></table></figure>

<p><strong>4. Promise.prototype.finally()</strong></p>
<p>Promise.prototype.finally()方法用于给期约添加 onFinally 处理程序，这个处理程序在期 约转换为解决或拒绝状态时都会执行。这个方法可以避免 onResolved 和 onRejected 处理程序中出 现冗余代码。但 onFinally 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用 于添加清理代码.</p>
<p><strong>5. 非重入期约方法</strong></p>
<p>当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处 理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联 的状态，执行顺序也是这样的。这个特性由 JavaScript 运行时保证，被称为“非重入”（non-reentrancy） 特性。</p>
<p>即使期约状态变化发生在添加处理程序之后，处理程序也会等到运行的消息队列让 它出列时才会执行.</p>
<p><strong>6. 邻近处理程序的执行顺序</strong></p>
<p>如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。无论是 then()、catch()还是 finally()添加的处理程序都是如此。</p>
<p><strong>7. 传递解决值和拒绝理由</strong></p>
<p>到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理 程序。拿到返回值后，就可以进一步对这个值进行操作。比如，第一次网络请求返回的 JSON 是发送第 二次请求必需的数据，那么第一次请求返回的值就应该传给 onResolved 处理程序继续处理。当然，失败的网络请求也应该把 HTTP 状态码传给 onRejected 处理程序。</p>
<p><strong>8. 拒绝期约与拒绝错误处理</strong></p>
<p>拒绝期约类似于 throw()表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。在期 约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>)));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>); &#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>); &#125;);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;rejected&gt;: Error: foo </span></span><br></pre></td></tr></table></figure>

<p>异步错误只能通过异步的 onRejected 处理程序 捕获：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>)).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不正确</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这不包括捕获执行函数中的错误，在解决或拒绝期约之前，仍然可以使用 try&#x2F;catch 在执行函数 中捕获错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"> <span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br></pre></td></tr></table></figure>

<h5 id="11-2-4-期约连锁与期约合成"><a href="#11-2-4-期约连锁与期约合成" class="headerlink" title="11.2.4 期约连锁与期约合成"></a>11.2.4 期约连锁与期约合成</h5><p>多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约 合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约</p>
<p><strong>1. 期约连锁</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1 executor&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2 executor&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line"> &#125;))</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p3 executor&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line"> &#125;))</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p4 executor&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line"> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1 executor（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3 秒后</span></span><br><span class="line"><span class="comment">// p4 executor（4 秒后）</span></span><br></pre></td></tr></table></figure>

<p>把生成期约的代码提取到一个工厂函数中，就可以写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">delayedResolve</span>(<span class="params">str</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">delayedResolve</span>(<span class="string">&#x27;p1 executor&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">delayedResolve</span>(<span class="string">&#x27;p2 executor&#x27;</span>))</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">delayedResolve</span>(<span class="string">&#x27;p3 executor&#x27;</span>))</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">delayedResolve</span>(<span class="string">&#x27;p4 executor&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1 executor（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 executor（4 秒后）</span></span><br></pre></td></tr></table></figure>

<p>每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简 洁地将异步任务串行化，解决之前依赖回调的难题.</p>
<p><strong>2. 期约图</strong></p>
<p><strong>3. Promise.all()和 Promise.race()</strong></p>
<p>Promise 类提供两个将多个期约实例组合成一个期约的静态方法：Promise.all()和 Promise.race()。 而合成后期约的行为取决于内部期约的行为。</p>
<p><strong>Promise.all()</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(),</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过 Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="comment">// 空的可迭代对象等价于 Promise.resolve()</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([]);</span><br><span class="line"><span class="comment">// 无效的语法</span></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">all</span>();</span><br><span class="line"><span class="comment">// TypeError: cannot read Symbol.iterator of undefined</span></span><br></pre></td></tr></table></figure>

<p>如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的 期约也会拒绝：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 永远待定</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="comment">// 一次拒绝会导致最终期约拒绝</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(),</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(),</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) undefined </span></span><br></pre></td></tr></table></figure>

<p>如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>),</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(),</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">values</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, values)); <span class="comment">// [3, undefined, 4] </span></span><br></pre></td></tr></table></figure>

<p> <strong>Promise.race()</strong></p>
<p>Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个 方法接收一个可迭代对象，返回一个新期约.</p>
<p><strong>Promise.race()不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的 期约，Promise.race()就会包装其解决值或拒绝理由并返回新期约：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决先发生，超时后的拒绝被忽略</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>),</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt;: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拒绝先发生，超时后的解决被忽略</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">4</span>),</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代顺序决定了落定顺序</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">5</span>),</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">6</span>),</span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">7</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: 5 </span></span><br></pre></td></tr></table></figure>

<h5 id="11-2-5-期约扩展"><a href="#11-2-5-期约扩展" class="headerlink" title="11.2.5 期约扩展"></a>11.2.5 期约扩展</h5><p>ES6 期约实现是很可靠的，但它也有不足之处。比如，很多第三方期约库实现中具备而 ECMAScript 规范却未涉及的两个特性：<strong>期约取消和进度追踪。</strong></p>
<p><strong>不支持期约的取消。</strong></p>
<p>执行中的期约可能会有不少离散的“阶段”，在最终解决之前必须依次经过。某些情况下，监控期约的执行进度会很有用。<strong>ECMAScript 6 期约并不支持进度追踪。</strong></p>
<h5 id="补充：手写promise"><a href="#补充：手写promise" class="headerlink" title="补充：手写promise"></a>补充：手写promise</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">// 声明构造函数</span><br><span class="line">function Promise(executor)&#123;</span><br><span class="line"></span><br><span class="line">    // 添加属性</span><br><span class="line">    this.PromiseState=&quot;pending&quot;;</span><br><span class="line">    this.PromiseResult=null</span><br><span class="line">    this.callback=[]</span><br><span class="line"></span><br><span class="line">    // 保存this</span><br><span class="line">    const that=this</span><br><span class="line"></span><br><span class="line">    // reslove</span><br><span class="line">    function reslove(data)&#123;</span><br><span class="line">        // PromiseState状态只能更改一次</span><br><span class="line">        if(that.PromiseState!==&quot;pending&quot;)&#123;return&#125;</span><br><span class="line">        // 修改PromiseState</span><br><span class="line">        that.PromiseState=&quot;fulfilled&quot;</span><br><span class="line">        // 修改PromiseResult</span><br><span class="line">        that.PromiseResult=data</span><br><span class="line">        // 调用成功的回调</span><br><span class="line">        // if(that.callback.onResloved)&#123;</span><br><span class="line">        //     that.callback.onResloved(data);</span><br><span class="line">        // &#125;</span><br><span class="line">        // 回调函数异步执行</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            // 多次调回调函数</span><br><span class="line">            that.callback.forEach(item =&gt; &#123;</span><br><span class="line">                item.onResloved(data)</span><br><span class="line">            &#125;) </span><br><span class="line">        &#125;, 0);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // reject</span><br><span class="line">    function reject(data)&#123;</span><br><span class="line">        // PromiseState状态只能更改一次</span><br><span class="line">        if (that.PromiseState !== &quot;pending&quot;) &#123; return &#125;</span><br><span class="line">        // 修改PromiseState</span><br><span class="line">        that.PromiseState = &quot;rejected&quot;</span><br><span class="line">        // 修改PromiseResult</span><br><span class="line">        that.PromiseResult = data</span><br><span class="line">        // 调用成功的回调</span><br><span class="line">        // if (that.callback.onRejected) &#123;</span><br><span class="line">        //     that.callback.onRejected(data);</span><br><span class="line">        // &#125;</span><br><span class="line">        // 回调函数异步执行</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            // 多次调回调函数</span><br><span class="line">            that.callback.forEach(item =&gt; &#123;</span><br><span class="line">                item.onRejected(data)</span><br><span class="line">                // console.log(item)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 0);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        // 同步调用[执行器]函数</span><br><span class="line">        executor(reslove,reject)</span><br><span class="line">        // console.log(123)</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">        // 处理抛出错误</span><br><span class="line">        reject(e)</span><br><span class="line">        // console.log(123)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 添加then方法</span><br><span class="line">Promise.prototype.then=function(onResloved,onRejected)&#123;</span><br><span class="line">    const that=this;</span><br><span class="line">    // 实现异常穿透</span><br><span class="line">    if(typeof onRejected !==&quot;function&quot;)&#123;</span><br><span class="line">        onRejected=reason=&gt;&#123;</span><br><span class="line">            throw reason</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 实现值传递</span><br><span class="line">    if (typeof onResloved !==&quot;function&quot;)&#123;</span><br><span class="line">        onResloved =value=&gt;value</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置then方法的返回值</span><br><span class="line">    return new Promise((reslove,reject)=&gt;&#123;</span><br><span class="line">        // 封装回调函数</span><br><span class="line">        function callback(type)&#123;</span><br><span class="line">            // 获取回调函数的执行结果</span><br><span class="line">            try &#123;</span><br><span class="line">                let result = type(that.PromiseResult)</span><br><span class="line">                // 判断返回结果是不是promise对象</span><br><span class="line">                if (result instanceof Promise) &#123;</span><br><span class="line">                    // 是promise</span><br><span class="line">                    result.then(v =&gt; &#123;</span><br><span class="line">                        reslove(v)</span><br><span class="line">                    &#125;, r =&gt; &#123;</span><br><span class="line">                        reject(r)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 不是</span><br><span class="line">                    reslove(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                // 用try/catch捕获抛出错误</span><br><span class="line">                reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // then方法处理成功的回调函数</span><br><span class="line">        if (this.PromiseState == &quot;fulfilled&quot;) &#123;</span><br><span class="line">            // 回调函数异步执行</span><br><span class="line">            setTimeout(()=&gt;&#123;</span><br><span class="line">                callback(onResloved)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        // then方法处理失败的回调函数</span><br><span class="line">        if (this.PromiseState == &quot;rejected&quot;) &#123;</span><br><span class="line">            // 回调函数异步执行</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                callback(onRejected)</span><br><span class="line">            &#125;, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.PromiseState == &quot;pending&quot;) &#123;</span><br><span class="line">            // 保存回调</span><br><span class="line">            this.callback.push(&#123;</span><br><span class="line">                onResloved:function()&#123;</span><br><span class="line">                   callback(onResloved)</span><br><span class="line">                &#125;,</span><br><span class="line">                onRejected:function()&#123;</span><br><span class="line">                   callback(onRejected)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 添加catch方法</span><br><span class="line">Promise.prototype.catch=function(onRejected)&#123;</span><br><span class="line">    return this.then(undefined,onRejected);</span><br><span class="line">&#125;</span><br><span class="line">// 添加reslove方法</span><br><span class="line">Promise.reslove=function(value)&#123;</span><br><span class="line">    return new Promise((reslove,reject)=&gt;&#123;</span><br><span class="line">        if(value instanceof Promise)&#123;</span><br><span class="line">            value.then(v=&gt;&#123;</span><br><span class="line">                reslove(v)</span><br><span class="line">            &#125;,r=&gt;&#123;</span><br><span class="line">                reject(r)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            reslove(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加reject方法</span><br><span class="line">Promise.reject=function(reason)&#123;</span><br><span class="line">    return new Promise((reslove,reject)=&gt;&#123;</span><br><span class="line">        reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加all方法</span><br><span class="line">Promise.all=function(promise)&#123;</span><br><span class="line">    return new Promise((reslove,reject)=&gt;&#123;</span><br><span class="line">        let count=0;</span><br><span class="line">        let arr=[];</span><br><span class="line">        // 遍历数组</span><br><span class="line">        for(let i=0;i&lt;promise.length;i++)[</span><br><span class="line">            promise[i].then(value=&gt;&#123;</span><br><span class="line">                // 每有一个状态是成功的就进一次</span><br><span class="line">                count++;</span><br><span class="line">                // 保存成功的值</span><br><span class="line">                arr[i]=value;</span><br><span class="line">                // 判断是否全部成功</span><br><span class="line">                if(count===promise.length)&#123;</span><br><span class="line">                    reslove(arr)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,reason=&gt;&#123;</span><br><span class="line">                reject(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 添加race方法</span><br><span class="line">Promise.race=function(promise)&#123;</span><br><span class="line">    return new Promise((reslove,reject)=&gt;&#123;</span><br><span class="line">        // 遍历数组</span><br><span class="line">        for(let i=0;i&lt;promise.length;i++)[</span><br><span class="line">            promise[i].then(value=&gt;&#123;</span><br><span class="line">                reslove(value)</span><br><span class="line">            &#125;,reason=&gt;&#123;</span><br><span class="line">                reject(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-3-异步函数"><a href="#11-3-异步函数" class="headerlink" title="11.3 异步函数"></a>11.3 异步函数</h4><p>异步函数，也称为“async&#x2F;await”（语法关键字），是 ES6 期约模式在 ECMAScript 函数中的应用。 async&#x2F;await 是 ES8 规范新增的。</p>
<h5 id="11-3-1-异步函数"><a href="#11-3-1-异步函数" class="headerlink" title="11.3.1 异步函数"></a>11.3.1 异步函数</h5><p>ES8 的 async&#x2F;await 旨在解决利用异步结构组织代码的问题。为此，ECMAScript 对函数进行了扩展， 为其增加了两个新关键字：async 和 await。</p>
<p><strong>1. async</strong></p>
<p>async 关键字用于声明异步函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">async function fn()&#123;</span><br><span class="line">            // 返回一个字符串</span><br><span class="line">            // return &#x27;尚硅谷&#x27;;</span><br><span class="line">            // 返回的结果不是一个 Promise 类型的对象, 返回的结果就是成功 Promise 对象</span><br><span class="line">            // return;</span><br><span class="line">            //抛出错误, 返回的结果是一个失败的 Promise</span><br><span class="line">            // throw new Error(&#x27;出错啦!&#x27;);</span><br><span class="line">            //返回的结果如果是一个 Promise 对象</span><br><span class="line">            return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">                resolve(&#x27;成功的数据&#x27;);</span><br><span class="line">                // reject(&quot;失败的错误&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const result = fn();</span><br><span class="line"></span><br><span class="line">        //调用 then 方法</span><br><span class="line">        result.then(value =&gt; &#123;</span><br><span class="line">            console.log(value);</span><br><span class="line">        &#125;, reason =&gt; &#123;</span><br><span class="line">            console.warn(reason);</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>2. await</strong></p>
<p>因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用 await 关键字可以暂停异步函数代码的执行，等待期约解决。</p>
<p><strong>3. await 的限制</strong></p>
<p>await 关键字期待（但实际上并不要求）一个实现 thenable 接口的对象，但常规的值也可以。如 果是实现 thenable 接口的对象，则这个对象可以由 await 来“解包”。如果不是，则这个值就被当作 已经解决的期约。</p>
<p>await 关键字必须在异步函数中使用，不能在顶级上下文如[script]标签或模块中使用。不过， 定义并立即调用异步函数是没问题的。</p>
<p>异步函数的特质不会扩展到嵌套函数。因此，await 关键字也只能直接出现在异步函数的定 义中。在同步函数内部使用 await 会抛出 SyntaxError。</p>
<h5 id="11-3-2-停止和恢复执行"><a href="#11-3-2-停止和恢复执行" class="headerlink" title="11.3.2 停止和恢复执行"></a>11.3.2 停止和恢复执行</h5><p>使用 await 关键字之后的区别其实比看上去的还要微妙一些。比如，下面的例子中按顺序调用了 3 个函数，但它们的输出结果顺序是相反的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line"><span class="title function_">baz</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// foo </span></span><br></pre></td></tr></table></figure>

<p>async&#x2F;await 中真正起作用的是 await。async 关键字，无论从哪方面来看，都不过是一个标识符。 毕竟，异步函数如果不包含 await 关键字，其执行基本上跟普通函数没有什么区别.</p>
<p>要完全理解 await 关键字，必须知道它并非只是等待一个值可用那么简单。JavaScript 运行时在碰 到 await 关键字时，会记录在哪里暂停执行。等到 await 右边的值可用了，JavaScript 运行时会向消息 队列中推送一个任务，这个任务会恢复异步函数的执行。 因此，即使 await 后面跟着一个立即可用的值，函数的其余部分也会被异步求值。下面的例子演 示了这一点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"> <span class="keyword">await</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p> 控制台中输出结果的顺序很好地解释了运行时的工作过程：<br>(1) 打印 1；<br>(2) 调用异步函数 foo()；<br>(3)（在 foo()中）打印 2；<br>(4)（在 foo()中）await 关键字暂停执行，为立即可用的值 null 向消息队列中添加一个任务；<br>(5) foo()退出；<br>(6) 打印 3；<br>(7) 同步线程的代码执行完毕；<br>(8) JavaScript 运行时从消息队列中取出任务，恢复异步函数执行；<br>(9)（在 foo()中）恢复执行，await 取得 null 值（这里并没有使用）；<br>(10)（在 foo()中）打印 4；<br>(11) foo()返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">8</span>));</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="number">6</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure>

<h5 id="11-3-3-异步函数策略"><a href="#11-3-3-异步函数策略" class="headerlink" title="11.3.3 异步函数策略"></a>11.3.3 异步函数策略</h5><p><strong>1. 实现 sleep()</strong></p>
<p>很多人在刚开始学习 JavaScript 时，想找到一个类似 Java 中 Thread.sleep()之类的函数，好在程 序中加入非阻塞的暂停。以前，这个需求基本上都通过 setTimeout()利用 JavaScript 运行时的行为来 实现的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有了异步函数之后，就不一样了。一个简单的箭头函数就可以实现 sleep()：</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">delay</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"> <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1500</span>); <span class="comment">// 暂停约 1500 毫秒</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() - t0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();<span class="comment">// 1502 </span></span><br></pre></td></tr></table></figure>



<h2 id="二、API-部分"><a href="#二、API-部分" class="headerlink" title="二、API 部分"></a>二、API 部分</h2><h3 id="12：BOM"><a href="#12：BOM" class="headerlink" title="12：BOM"></a>12：BOM</h3><p>首先看看BOM的定义：</p>
<p>浏览器对象模型，BOM是Browser Object Model 的简写方法；</p>
<h4 id="12-1window-对象"><a href="#12-1window-对象" class="headerlink" title="12.1window 对象"></a>12.1window 对象</h4><p>BOM的核心是window对象，表示浏览器的实例。window对象在浏览器中有两重身份，一个是ECMAScript中的Global对象，另一个就是浏览器窗口的JavaScript接口。这意味着网页中定义的所有对象、变量和函数都以window作为其Global对象，都可以访问其上定义的parseInt()等全局方法。</p>
<h5 id="12-1-1Global-作用域"><a href="#12-1-1Global-作用域" class="headerlink" title="12.1.1Global 作用域"></a>12.1.1Global 作用域</h5><p>因为 window 对象被复用为 ECMAScript 的 Global 对象，所以通过 var 声明的所有全局变量和函数都会变成 window 对象的属性和方法。</p>
<p>如果在这里使用 let 或 const 替代 var，则不会把变量添加给全局对象</p>
<p>访问未声明的变量会抛出错误，但是可以在 window 对象上查询是否存在可能未声明的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这会导致抛出错误，因为 oldValue 没有声明</span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue; </span><br><span class="line"><span class="comment">// 这不会抛出错误，因为这里是属性查询</span></span><br><span class="line"><span class="comment">// newValue 会被设置为 undefined </span></span><br><span class="line"><span class="keyword">var</span> newValue = <span class="variable language_">window</span>.<span class="property">oldValue</span>;</span><br></pre></td></tr></table></figure>

<p>JavaScript 中有很多对象都暴露在全局作用域中，比如 location 和 navigator, 因而它们也是 window 对象的属性。</p>
<h5 id="12-1-2窗口关系"><a href="#12-1-2窗口关系" class="headerlink" title="12.1.2窗口关系"></a>12.1.2窗口关系</h5><ul>
<li>top 对象始终指向最上层（最外层）窗口，即浏览器窗口本身。</li>
<li>parent 对象则始终指向当前窗口的父窗口。</li>
<li>self 对象，它是终极 window 属性</li>
</ul>
<p>如果当前窗口是最上层窗口，则 parent 等于 top</p>
<p>这些属性都是 window 对象的属性，因此访问 window.parent、window.top 和 window.self 都可以。</p>
<h5 id="12-1-3窗口位置与像素比"><a href="#12-1-3窗口位置与像素比" class="headerlink" title="12.1.3窗口位置与像素比"></a>12.1.3窗口位置与像素比</h5><p>现代浏览器提供了 screenLeft 和 screenTop 属性，用于表示窗口相对于屏幕左侧和顶部的位置 ，返回值的单位是 CSS 像素</p>
<p>可以使用 moveTo()和 moveBy()方法移动窗口。这两个方法都接收两个参数，其中 moveTo()接 收要移动到的新位置的绝对坐标 x 和 y；而moveBy()则接收相对当前位置在两个方向上移动的像素数。</p>
<p>依浏览器而定，以上方法可能会被部分或全部禁用。</p>
<p>&#x3D;&#x3D;像素比&#x3D;&#x3D;</p>
<p>CSS 像素是 Web 开发中使用的统一像素单位</p>
<p>比如，低分辨率平板设备上 12 像素（CSS 像素）的文字应该与高清 4K 屏幕下 12 像素（CSS 像素）的文字具有相同大小。</p>
<p>这就带来了一个问题，不同像素密度的屏幕下就会有不同的缩放系数，以便把物理像素（屏幕实际的分辨率）转换为 CSS 像素（浏览器报告的虚拟分辨率）。</p>
<p>举个例子，手机屏幕的物理分辨率可能是1920×1080，但因为其像素可能非常小，所以浏览器就需要将其分辨率降为较低的逻辑分辨率，比如640×320。这个物理像素与CSS像素之间的转换比率由window.devicePixelRatio属性提供。对于分辨率从1920×1080转换为640×320的设备，window.devicePixelRatio的值就是3。这样一来，12像素（CSS像素）的文字实际上就会用36像素的物理像素来显示</p>
<p>window.devicePixelRatio 表示物理像素与逻辑像素之间的缩放系数</p>
<h5 id="12-1-4窗口大小"><a href="#12-1-4窗口大小" class="headerlink" title="12.1.4窗口大小"></a>12.1.4窗口大小</h5><p>获取浏览器窗口大小方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// innerWidth和 innerHeight 返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）。</span></span><br><span class="line"><span class="keyword">let</span> pageWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span>,</span><br><span class="line">  pageHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">compatMode</span> == <span class="string">&quot;CSS1Compat&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// document.documentElement.clientWidth 和 document.documentElement.clientHeight返回页面视口的宽度和高度</span></span><br><span class="line">    pageWidth = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">    pageHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pageWidth = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br><span class="line">    pageHeight = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用resizeTo()和resizeBy()方法调整窗口大小。这两个方法都接收两个参数，resizeTo() 接收新的宽度和高度值，而 resizeBy()接收宽度和高度各要缩放多少。</p>
<p>与移动窗口的方法一样，缩放窗口的方法可能会被浏览器禁用，而且在某些浏览器中默认是禁用的。同样，缩放窗口的方法只能应用到最上层的 window 对象。</p>
<h5 id="12-1-5视口位置"><a href="#12-1-5视口位置" class="headerlink" title="12.1.5视口位置"></a>12.1.5视口位置</h5><p>度量文档相对于视口滚动距离的属性有两对，返回相等的值：window.pageXoffset&#x2F;window. scrollX 和 window.pageYoffset&#x2F;window.scrollY。</p>
<p>可以使用 scroll()、scrollTo()和 scrollBy()方法滚动页面。这 3 个方法都接收表示相对视口距离的 x 和 y 坐标，这两个参数在前两个方法中表示要滚动到的坐标，在最后一个方法中表示滚动的距离。</p>
<p>这几个方法也都接收一个 ScrollToOptions 字典，除了提供偏移值，还可以通过 behavior 属性 告诉浏览器是否平滑滚动。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常滚动 </span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(&#123; </span><br><span class="line"> <span class="attr">left</span>: <span class="number">100</span>, </span><br><span class="line"> <span class="attr">top</span>: <span class="number">100</span>, </span><br><span class="line"> <span class="attr">behavior</span>: <span class="string">&#x27;auto&#x27;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// 平滑滚动</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(&#123; </span><br><span class="line"> <span class="attr">left</span>: <span class="number">100</span>, </span><br><span class="line"> <span class="attr">top</span>: <span class="number">100</span>, </span><br><span class="line"> <span class="attr">behavior</span>: <span class="string">&#x27;smooth&#x27;</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="12-1-6导航与打开新窗口"><a href="#12-1-6导航与打开新窗口" class="headerlink" title="12.1.6导航与打开新窗口"></a>12.1.6导航与打开新窗口</h5><p>window.open()方法可以用于导航到指定 URL，也可以用于打开新浏览器窗口。这个方法接收 4 个参数：要加载的 URL、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。通常，调用这个方法时只传前 3 个参数，最后一个参数只有在不打开新窗口时才会使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;http://www.wrox.com/&quot;</span>, </span><br><span class="line"> <span class="string">&quot;wroxWindow&quot;</span>, </span><br><span class="line"> <span class="string">&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这行代码会打开一个可缩放的新窗口，大小为 400 像素×400 像素，位于离屏幕左边及顶边各 10 像素的位置。（类似与paypal的那个支付窗口）</p>
<p>返回值：</p>
<p>window.open()方法返回一个对新建窗口的引用。这个对象与普通 window 对象没有区别，只是为 控制新窗口提供了方便。</p>
<p>某些浏览器默认不允许缩放或移动主窗口，但可能允许缩放或移动通过 window.open()创建的窗口。跟使用任何window对象一样，可以使用这个对象操纵新打开的窗口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wroxWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;http://www.wrox.com/&quot;</span>, </span><br><span class="line"> <span class="string">&quot;wroxWindow&quot;</span>, </span><br><span class="line"> <span class="string">&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;</span>); </span><br><span class="line"><span class="comment">// 缩放</span></span><br><span class="line">wroxWin.<span class="title function_">resizeTo</span>(<span class="number">500</span>, <span class="number">500</span>); </span><br><span class="line"><span class="comment">// 移动</span></span><br><span class="line">wroxWin.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">100</span>); </span><br><span class="line"><span class="comment">// 还可以使用 close()方法像这样关闭新打开的窗口：</span></span><br><span class="line">wroxWin.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure>

<p>新创建窗口的 window 对象有一个属性 opener，指向打开它的窗口。这个属性只在弹出窗口的最 上层 window 对象（top）有定义，是指向调用 window.open()打开它的窗口或窗格的指针。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wroxWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;http://www.wrox.com/&quot;</span>, </span><br><span class="line"> <span class="string">&quot;wroxWindow&quot;</span>, </span><br><span class="line"> <span class="string">&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(wroxWin.<span class="property">opener</span> === <span class="variable language_">window</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>把 opener 设置为 null 表示新打开的标签页不需要与打开它的标签页通信，因此可以在独立进程 中运行。这个连接一旦切断，就无法恢复了。</p>
<h6 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h6><p>弹出窗口有段时间被在线广告用滥了。很多在线广告会把弹出窗口伪装成系统对话框，诱导用户点 击。因为长得像系统对话框，所以用户很难分清这些弹窗的来源。为了让用户能够区分清楚，浏览器开始对弹窗施加限制，各个浏览器实现方式不一致，作为了解！</p>
<h6 id="弹窗屏蔽程序"><a href="#弹窗屏蔽程序" class="headerlink" title="弹窗屏蔽程序"></a>弹窗屏蔽程序</h6><p>浏览器内置的弹窗屏蔽程序阻止了弹窗，那么 window.open()很可能会返回 null,也有可能抛出错误；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> blocked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> wroxWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;http://www.wrox.com&quot;</span>, <span class="string">&quot;_blank&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (wroxWin == <span class="literal">null</span>) &#123;</span><br><span class="line">    blocked = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;The popup was blocked!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-1-7定时器"><a href="#12-1-7定时器" class="headerlink" title="12.1.7定时器"></a>12.1.7定时器</h5><p>JavaScript 在浏览器中是单线程执行的，但允许使用定时器指定在某个时间之后或每隔一段时间就执行相应的代码。</p>
<ul>
<li>setTimeout()用于指定在一定时间后执行某些代码，</li>
<li>setInterval()用于指定每隔一段时间执行某些代码。</li>
</ul>
<p>调用 setTimeout()时，会返回一个表示该超时排期的数值ID,可用于取消该任务</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置超时任务</span></span><br><span class="line"><span class="keyword">let</span> timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&quot;Hello world!&quot;</span>), <span class="number">1000</span>); </span><br><span class="line"><span class="comment">// 取消超时任务</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(timeoutId);</span><br></pre></td></tr></table></figure>

<p>setInterval()与 setTimeout()的使用方法类似</p>
<p>下面是一个常见的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>,</span><br><span class="line">  intervalId = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> incrementNumber = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  num++;</span><br><span class="line">  <span class="comment">// 如果达到最大值，则取消所有未执行的任务</span></span><br><span class="line">  <span class="keyword">if</span> (num == max) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">intervalId = <span class="built_in">setInterval</span>(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>以使用 setTimeout()来实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> incrementNumber = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  num++;</span><br><span class="line">  <span class="comment">// 如果还没有达到最大值，再设置一个超时任务</span></span><br><span class="line">  <span class="keyword">if</span> (num &lt; max) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(incrementNumber, <span class="number">500</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>使用 setTimeout()时，不一定要记录超时ID，因为它会在条件满足时自动停止一般来说，最好不要使用 setInterval()。</p>
<h5 id="12-1-8系统对话框"><a href="#12-1-8系统对话框" class="headerlink" title="12.1.8系统对话框"></a>12.1.8系统对话框</h5><p>使用 alert()、confirm()和 prompt()方法，可以让浏览器调用系统对话框向用户显示消息。这 些对话框与浏览器中显示的网页无关，而且也不包含HTML。它们的外观由操作系统或者浏览器决定，无法使用 CSS 设置。此外，这些对话框都是同步的模态对话框，<strong>即在它们显示的时候，代码会停止执行</strong>，在它们消失以后，代码才会恢复执行。 一般都不用，太难看了，了解即可；</p>
<p>JavaScript 还可以显示另外两种对话框：find()和print()。这两种对话框都是异步显示的，即控 制权会立即返回给脚本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示打印对话框</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">print</span>(); </span><br><span class="line"><span class="comment">// 显示查找对话框</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">find</span>();</span><br></pre></td></tr></table></figure>

<p>因为这两种对话框是异步的，所以浏览器的对话框计数器不会涉及它们，而且用户选择禁用对话框对它们也没有影响</p>
<h4 id="12-2location-对象"><a href="#12-2location-对象" class="headerlink" title="12.2location 对象"></a>12.2location 对象</h4><p>location 是最有用的 BOM 对象之一，提供了当前窗口中加载文档的信息，以及通常的导航功能。</p>
<p>它既是 window 的属性，也是 document 的属性。也就是说，window.location 和 document.location 指向同一个对象</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>location.hash</td>
<td>“#contents”</td>
<td>URL 散列值（井号后跟零或多个字符），如果没有则为空字符串</td>
</tr>
<tr>
<td>location.host</td>
<td>“<a href="https://link.juejin.cn/?target=http://www.wrox.com:80">www.wrox.com:80</a>“</td>
<td>服务器名及端口号</td>
</tr>
<tr>
<td>location.hostname</td>
<td>“<a href="https://link.juejin.cn/?target=http://www.wrox.com">www.wrox.com</a>“</td>
<td>服务器名</td>
</tr>
<tr>
<td>location.href</td>
<td>“<a href="https://link.juejin.cn/?target=http://www.wrox.com:80/WileyCDA/?q=javascript%23contents">www.wrox.com:80/WileyCDA/?q…</a>“</td>
<td>当前加载页面的完整 URL。location 的 toString()方法返回这个值</td>
</tr>
<tr>
<td>location.pathname</td>
<td>“&#x2F;WileyCDA&#x2F;“</td>
<td>URL 中的路径和（或）文件名</td>
</tr>
<tr>
<td>location.port</td>
<td>“80”</td>
<td>请求的端口。如果 URL中没有端口，则返回空字符串</td>
</tr>
<tr>
<td>location.protocol</td>
<td>“http:”</td>
<td>页面使用的协议。通常是”http:”或”https:”</td>
</tr>
<tr>
<td>location.search</td>
<td>“?q&#x3D;javascript”</td>
<td>URL 的查询字符串。这个字符串以问号开头</td>
</tr>
<tr>
<td>location.username</td>
<td>“foouser”</td>
<td>域名前指定的用户名</td>
</tr>
<tr>
<td>location.password</td>
<td>“barpassword”</td>
<td>域名前指定的密码</td>
</tr>
<tr>
<td>location.origin</td>
<td>“<a href="https://link.juejin.cn/?target=http://www.wrox.com">www.wrox.com</a>“</td>
<td>URL 的源地址。只读</td>
</tr>
</tbody></table>
<h5 id="12-2-1查询字符串"><a href="#12-2-1查询字符串" class="headerlink" title="12.2.1查询字符串"></a>12.2.1查询字符串</h5><p>location 的多数信息都可以通过上面的属性获取。但是 URL 中的查询字符串并不容易使用。虽然 location.search 返回了从问号开始直到URL末尾的所有内容，但没有办法逐个访问每个查询参数。下面的函数解析了查询字符串，并返回一个以每个查询参数为属性的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getQueryStringArgs = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 取得没有开头问号的查询字符串</span></span><br><span class="line">  <span class="keyword">let</span> qs = location.<span class="property">search</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? location.<span class="property">search</span>.<span class="title function_">substring</span>(<span class="number">1</span>) : <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">// 保存数据的对象</span></span><br><span class="line">    args = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 把每个参数添加到 args 对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> qs.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">kv</span> =&gt;</span> kv.<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]),</span><br><span class="line">      value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (name.<span class="property">length</span>) &#123;</span><br><span class="line">      args[name] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设查询字符串为?q=javascript&amp;num=10 </span></span><br><span class="line"><span class="keyword">let</span> args = <span class="title function_">getQueryStringArgs</span>(); </span><br><span class="line"><span class="title function_">alert</span>(args[<span class="string">&quot;q&quot;</span>]); <span class="comment">// &quot;javascript&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(args[<span class="string">&quot;num&quot;</span>]); <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>

<p>查询字符串中的每个参数都是返回对象的一个属性，这样使用起来就方便了</p>
<p><strong>URLSearchParams</strong></p>
<p>URLSearchParams 提供了一组标准 API 方法，通过它们可以检查和修改查询字符串。给 URLSearchParams 构造函数传入一个查询字符串，就可以创建一个实例。这个实例上暴露了 get()、set()和 delete()等方法，可以对查询字符串执行相应操作。下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> qs = <span class="string">&quot;?q=javascript&amp;num=10&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> searchParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(qs);</span><br><span class="line"><span class="title function_">alert</span>(searchParams.<span class="title function_">toString</span>()); <span class="comment">// &quot; q=javascript&amp;num=10&quot; </span></span><br><span class="line">searchParams.<span class="title function_">has</span>(<span class="string">&quot;num&quot;</span>); <span class="comment">// true </span></span><br><span class="line">searchParams.<span class="title function_">get</span>(<span class="string">&quot;num&quot;</span>); <span class="comment">// 10 </span></span><br><span class="line">searchParams.<span class="title function_">set</span>(<span class="string">&quot;page&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(searchParams.<span class="title function_">toString</span>()); <span class="comment">// &quot; q=javascript&amp;num=10&amp;page=3&quot; </span></span><br><span class="line">searchParams.<span class="title function_">delete</span>(<span class="string">&quot;q&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(searchParams.<span class="title function_">toString</span>()); <span class="comment">// &quot; num=10&amp;page=3&quot; </span></span><br><span class="line"><span class="comment">// 大多数支持 URLSearchParams 的浏览器也支持将 URLSearchParams 的实例用作可迭代对象：</span></span><br><span class="line"><span class="keyword">let</span> qs = <span class="string">&quot;?q=javascript&amp;num=10&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> searchParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(qs);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> param <span class="keyword">of</span> searchParams) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(param);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;q&quot;, &quot;javascript&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;num&quot;, &quot;10&quot;]</span></span><br></pre></td></tr></table></figure>

<p>更多用法看下面这个文章：<a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000019099536">URLSearchParams初体验</a></p>
<h5 id="12-2-2操作地址"><a href="#12-2-2操作地址" class="headerlink" title="12.2.2操作地址"></a>12.2.2操作地址</h5><p>可以通过修改 location 对象修改浏览器的地址</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location.<span class="title function_">assign</span>(<span class="string">&quot;http://www.wrox.com&quot;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span> = <span class="string">&quot;http://www.wrox.com&quot;</span>; </span><br><span class="line">location.<span class="property">href</span> = <span class="string">&quot;http://www.wrox.com&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在这 3 种修改浏览器地址的方法中，设置 location.href 是最常见的</p>
<p>如果不希望增加历史记录，可以使用 replace()方法。这个方法接收一个 URL 参数，但重新加载后不会增加历史记录</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.<span class="title function_">replace</span>(<span class="string">&quot;http://www.wrox.com/&quot;</span>),</span><br></pre></td></tr></table></figure>

<p>reload()，它能重新加载当前显示的页面。 调用 reload()而不传参数，页面会以最有效的方式重新加载。也就是说，如果页面自上次请求以来没有修改过，浏览器可能会从缓存中加载页面。如果想强制从服务器重新加载，可以像下面这样给 reload()传个 true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location.<span class="title function_">reload</span>(); <span class="comment">// 重新加载，可能是从缓存加载</span></span><br><span class="line">location.<span class="title function_">reload</span>(<span class="literal">true</span>); <span class="comment">// 重新加载，从服务器加载</span></span><br></pre></td></tr></table></figure>

<h4 id="12-3navigator-对象"><a href="#12-3navigator-对象" class="headerlink" title="12.3navigator 对象"></a>12.3navigator 对象</h4><p>navigator 对象的属性通常用于确定浏览器的类型。</p>
<h5 id="12-3-1检测插件"><a href="#12-3-1检测插件" class="headerlink" title="12.3.1检测插件"></a>12.3.1检测插件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插件检测，IE10 及更低版本无效</span></span><br><span class="line"><span class="keyword">let</span> hasPlugin = <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  name = name.<span class="title function_">toLowerCase</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> plugin <span class="keyword">of</span> <span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">plugins</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (plugin.<span class="property">name</span>.<span class="title function_">toLowerCase</span>().<span class="title function_">indexOf</span>(name) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 检测 Flash</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">hasPlugin</span>(<span class="string">&quot;Flash&quot;</span>));</span><br><span class="line"><span class="comment">// 检测 QuickTime</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">hasPlugin</span>(<span class="string">&quot;QuickTime&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>旧版本 IE 中的插件检测</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在旧版本 IE 中检测插件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasIEPlugin</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测 Flash</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">hasIEPlugin</span>(<span class="string">&quot;ShockwaveFlash.ShockwaveFlash&quot;</span>));</span><br><span class="line"><span class="comment">// 检测 QuickTime</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">hasIEPlugin</span>(<span class="string">&quot;QuickTime.QuickTime&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="12-3-2注册处理程序-了解"><a href="#12-3-2注册处理程序-了解" class="headerlink" title="12.3.2注册处理程序(了解)"></a>12.3.2注册处理程序(了解)</h5><p>registerProtocolHandler()方法，必须传入 3 个参数：</p>
<ul>
<li>要处理的协议（如”mailto”或”ftp”）</li>
<li>处理该协议的 URL</li>
<li>以及应用名称</li>
</ul>
<p>要把一个 Web 应用程序注册为默认邮件客户端，可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="title function_">registerProtocolHandler</span>(<span class="string">&quot;mailto&quot;</span>, </span><br><span class="line"> <span class="string">&quot;http://www.somemailclient.com?cmd=%s&quot;</span>, </span><br><span class="line"> <span class="string">&quot;Some Mail Client&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="12-4screen-对象-了解"><a href="#12-4screen-对象-了解" class="headerlink" title="12.4screen 对象(了解)"></a>12.4screen 对象(了解)</h4><p>window 的另一个属性 screen 对象，是为数不多的几个在编程中很少用的 JavaScript 对象。这个对象中保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度。</p>
<h4 id="12-5history-对象"><a href="#12-5history-对象" class="headerlink" title="12.5history 对象"></a>12.5history 对象</h4><p>history 对象表示当前窗口首次使用以来用户的导航历史记录。因为 history 是 window 的属性，所以每个 window 都有自己的 history 对象。出于安全考虑，这个对象不会暴露用户访问过的 URL，但可以通过它在不知道实际 URL 的情况下前进和后退。</p>
<h5 id="12-5-1导航"><a href="#12-5-1导航" class="headerlink" title="12.5.1导航"></a>12.5.1导航</h5><p>go()方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后退一页</span></span><br><span class="line">history.<span class="title function_">go</span>(-<span class="number">1</span>); </span><br><span class="line"><span class="comment">// 前进一页</span></span><br><span class="line">history.<span class="title function_">go</span>(<span class="number">1</span>); </span><br><span class="line"><span class="comment">// 前进两页</span></span><br><span class="line">history.<span class="title function_">go</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>go()有两个简写方法：back()和 forward()。顾名思义，这两个方法模拟了浏览器的后退按钮和 前进按钮</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后退一页</span></span><br><span class="line">history.<span class="title function_">back</span>(); </span><br><span class="line"><span class="comment">// 前进一页</span></span><br><span class="line">history.<span class="title function_">forward</span>();</span><br></pre></td></tr></table></figure>

<p>history 对象还有一个 length 属性，表示历史记录中有多个条目。这个属性反映了历史记录的数 量，包括可以前进和后退的页面。对于窗口或标签页中加载的第一个页面，history.length 等于 1。通过以下方法测试这个值，可以确定用户浏览器的起点是不是你的页面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (history.<span class="property">length</span> == <span class="number">1</span>)&#123; </span><br><span class="line"> <span class="comment">// 这是用户窗口中的第一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>history 对象通常被用于创建“后退”和“前进”按钮，以及确定页面是不是用户历史记录中的第 一条记录。</p>
<h5 id="12-5-2历史状态管理"><a href="#12-5-2历史状态管理" class="headerlink" title="12.5.2历史状态管理"></a>12.5.2历史状态管理</h5><ul>
<li>hashchange 会在页面 URL 的散列变化时被触发，开发者可以在此时执行某些操作。</li>
<li>history.pushState()方法。这个方法接收 3 个参数：一个 state 对象、一个新状态的标题和一个（可选的）相对 URL。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stateObject = &#123;<span class="attr">foo</span>:<span class="string">&quot;bar&quot;</span>&#125;; </span><br><span class="line">history.<span class="title function_">pushState</span>(stateObject, <span class="string">&quot;My title&quot;</span>, <span class="string">&quot;baz.html&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因为 pushState()会创建新的历史记录，所以也会相应地启用“后退”按钮。此时单击“后退” 按钮，就会触发 window 对象上的 popstate 事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;popstate&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> state = event.<span class="property">state</span>;</span><br><span class="line">  <span class="keyword">if</span> (state) &#123;</span><br><span class="line">    <span class="comment">// 第一个页面加载时状态是 null</span></span><br><span class="line">    <span class="title function_">processState</span>(state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以通过 history.state 获取当前的状态对象，也可以使用 replaceState()并传入与 pushState()同样的前两个参数来更新状态。更新状态不会创建新历史记录，只会覆盖当前状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">replaceState</span>(&#123;<span class="attr">newFoo</span>: <span class="string">&quot;newBar&quot;</span>&#125;, <span class="string">&quot;New title&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>传给 pushState()和 replaceState()的 state 对象应该只包含可以被序列化的信息。因此， DOM 元素之类并不适合放到状态对象里保存。</p>
<h3 id="13：客户端检测"><a href="#13：客户端检测" class="headerlink" title="13：客户端检测"></a>13：客户端检测</h3><h4 id="13-1能力检测"><a href="#13-1能力检测" class="headerlink" title="13.1能力检测"></a>13.1能力检测</h4><p>能力检测（又称特性检测）即在 JavaScript 运行时中使用一套简单的检测逻辑，测试浏览器是否支 持某种特性。这这种方式不要求事先知道特定浏览器的信息，只需检测自己关心的能力是否存在即可。能力检测的基本模式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (object.<span class="property">propertyInQuestion</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 object.propertyInQuestion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该先检测最常用的方式</p>
<h5 id="13-1-1安全能力检测"><a href="#13-1-1安全能力检测" class="headerlink" title="13.1.1安全能力检测"></a>13.1.1安全能力检测</h5><p>能力检测最有效的场景是检测能力是否存在的同时，验证其是否能够展现出预期的行为。</p>
<p>比如我们需要一个排序方法sort,我们就需要sort必须是一个函数，检测方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好一些，检测 sort 是不是函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isSortable</span>(<span class="params">object</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">typeof</span> object.<span class="property">sort</span> == <span class="string">&quot;function&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13-1-2基于能力检测进行浏览器分析"><a href="#13-1-2基于能力检测进行浏览器分析" class="headerlink" title="13.1.2基于能力检测进行浏览器分析"></a>13.1.2基于能力检测进行浏览器分析</h5><p><strong>1. 检测特性</strong></p>
<p>可以按照能力将浏览器归类。如果你的应用程序需要使用特定的浏览器能力，那么最好集中检测所 有能力，而不是等到用的时候再重复检测。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测浏览器是否支持 Netscape 式的插件</span></span><br><span class="line"><span class="keyword">let</span> hasNSPlugins = !!(navigator.<span class="property">plugins</span> &amp;&amp; navigator.<span class="property">plugins</span>.<span class="property">length</span>); </span><br><span class="line"><span class="comment">// 检测浏览器是否具有 DOM Level 1 能力</span></span><br><span class="line"><span class="keyword">let</span> hasDOM1 = !!(<span class="variable language_">document</span>.<span class="property">getElementById</span> &amp;&amp; <span class="variable language_">document</span>.<span class="property">createElement</span> &amp;&amp; </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">getElementsByTagName</span>);</span><br></pre></td></tr></table></figure>

<p>一项是确定浏览器是否支持 Netscape 式的插件，另一项是检测浏览器是否具有 DOM Level 1 能力。保存在变量中的布尔值可以用在后面的条件语句中，这样比重复检测省事多了。</p>
<p><strong>2. 检测浏览器</strong></p>
<p>根据不同浏览器独有的行为推断出浏览器的身份。这里故意没有使用 navigator. userAgent 属性，后面会讨论它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BrowserDetector</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 测试条件编译</span></span><br><span class="line">    <span class="comment">// IE6~10 支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isIE_Gte6Lte10</span> = <span class="comment">/*@cc_on!@*/</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 测试 documentMode</span></span><br><span class="line">    <span class="comment">// IE7~11 支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isIE_Gte7Lte11</span> = !!<span class="variable language_">document</span>.<span class="property">documentMode</span>;</span><br><span class="line">    <span class="comment">// 测试 StyleMedia 构造函数</span></span><br><span class="line">    <span class="comment">// Edge 20 及以上版本支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isEdge_Gte20</span> = !!<span class="variable language_">window</span>.<span class="property">StyleMedia</span>;</span><br><span class="line">    <span class="comment">// 测试 Firefox 专有扩展安装 API</span></span><br><span class="line">    <span class="comment">// 所有版本的 Firefox 都支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isFirefox_Gte1</span> = <span class="keyword">typeof</span> <span class="title class_">InstallTrigger</span> !== <span class="string">&quot;undefined&quot;</span>;</span><br><span class="line">    <span class="comment">// 测试 chrome 对象及其 webstore 属性</span></span><br><span class="line">    <span class="comment">// Opera 的某些版本有 window.chrome，但没有 window.chrome.webstore</span></span><br><span class="line">    <span class="comment">// 所有版本的 Chrome 都支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isChrome_Gte1</span> = !!<span class="variable language_">window</span>.<span class="property">chrome</span> &amp;&amp; !!<span class="variable language_">window</span>.<span class="property">chrome</span>.<span class="property">webstore</span>;</span><br><span class="line">    <span class="comment">// Safari 早期版本会给构造函数的标签符追加&quot;Constructor&quot;字样，如：</span></span><br><span class="line">    <span class="comment">// window.Element.toString(); // [object ElementConstructor]</span></span><br><span class="line">    <span class="comment">// Safari 3~9.1 支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isSafari_Gte3Lte9_1</span> = <span class="regexp">/constructor/i</span>.<span class="title function_">test</span>(<span class="variable language_">window</span>.<span class="property">Element</span>);</span><br><span class="line">    <span class="comment">// 推送通知 API 暴露在 window 对象上</span></span><br><span class="line">    <span class="comment">// 使用默认参数值以避免对 undefined 调用 toString()</span></span><br><span class="line">    <span class="comment">// Safari 7.1 及以上版本支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isSafari_Gte7_1</span> = (<span class="function">(<span class="params">&#123; pushNotification = &#123;&#125; &#125; = &#123;&#125;</span>) =&gt;</span></span><br><span class="line">      pushNotification.<span class="title function_">toString</span>() == <span class="string">&quot;[object SafariRemoteNotification]&quot;</span>)(</span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">safari</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 测试 addons 属性</span></span><br><span class="line">    <span class="comment">// Opera 20 及以上版本支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isOpera_Gte20</span> = !!<span class="variable language_">window</span>.<span class="property">opr</span> &amp;&amp; !!<span class="variable language_">window</span>.<span class="property">opr</span>.<span class="property">addons</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isIE</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isIE_Gte6Lte10</span> || <span class="variable language_">this</span>.<span class="property">isIE_Gte7Lte11</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEdge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isEdge_Gte20</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="title function_">isIE</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isFirefox</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isFirefox_Gte1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isChrome</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isChrome_Gte1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isSafari</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isSafari_Gte3Lte9_1</span> || <span class="variable language_">this</span>.<span class="property">isSafari_Gte7_1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isOpera</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isOpera_Gte20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 能力检测的局限</strong></p>
<p>通过检测一种或一组能力，并不总能确定使用的是哪种浏览器。以下“浏览器检测”代码（或其他 类似代码）经常出现在很多网站中，但都没有正确使用能力检测：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要这样做！不够特殊</span></span><br><span class="line"><span class="keyword">let</span> isFirefox = !!(navigator.<span class="property">vendor</span> &amp;&amp; navigator.<span class="property">vendorSub</span>); </span><br><span class="line"><span class="comment">// 不要这样做！假设太多</span></span><br><span class="line"><span class="keyword">let</span> isIE = !!(<span class="variable language_">document</span>.<span class="property">all</span> &amp;&amp; <span class="variable language_">document</span>.<span class="property">uniqueID</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:能力检测最适合用于决定下一步该怎么做，而不一定能够作为辨识浏览器的标志。</p>
</blockquote>
<h4 id="13-2用户代理检测"><a href="#13-2用户代理检测" class="headerlink" title="13.2用户代理检测"></a>13.2用户代理检测</h4><p>其实就是：navigator.userAgent，用户代理检测被认为是不可 靠的，只应该在没有其他选项时再考虑；因为很可能被篡改；</p>
<h5 id="用户代理的历史（了解）"><a href="#用户代理的历史（了解）" class="headerlink" title="用户代理的历史（了解）"></a>用户代理的历史（了解）</h5><p>HTTP 规范（1.0 和 1.1）要求浏览器应该向服务器发送包含浏览器名称和版本信息的简短字符串。</p>
<p>其实就是ua的演变过程，有兴趣可以看看书上说的P(390页)（作为了解）</p>
<h5 id="浏览器分析"><a href="#浏览器分析" class="headerlink" title="浏览器分析"></a>浏览器分析</h5><p>想要知道自己代码运行在什么浏览器上，大部分开发者会分析 window.navigator.userAgent返回的字符串值。</p>
<p>相比于能力检测，用户代理检测还是有一定优势的，但是也存在一些缺点</p>
<p><strong>伪造用户代理</strong></p>
<p>现代浏览器都会提供 userAgent 这个只读属性，简单地给这个属性设置其他值不会有效；</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span>); </span><br><span class="line"><span class="comment">// Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) </span></span><br><span class="line"><span class="title class_">Chrome</span>/<span class="number">65.0</span><span class="number">.3325</span><span class="number">.181</span> <span class="title class_">Safari</span>/<span class="number">537.36</span> </span><br><span class="line"><span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span> = <span class="string">&#x27;foobar&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span>); </span><br><span class="line"><span class="comment">// Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) </span></span><br><span class="line"><span class="title class_">Chrome</span>/<span class="number">65.0</span><span class="number">.3325</span><span class="number">.181</span> <span class="title class_">Safari</span>/<span class="number">537.36</span></span><br></pre></td></tr></table></figure>

<p>不过，通过简单的办法可以绕过这个限制。比如，有些浏览器提供伪私有的__defineGetter__方法， 利用它可以篡改用户代理字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span>); </span><br><span class="line"><span class="comment">// Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) </span></span><br><span class="line"><span class="title class_">Chrome</span>/<span class="number">65.0</span><span class="number">.3325</span><span class="number">.181</span> <span class="title class_">Safari</span>/<span class="number">537.36</span> </span><br><span class="line"><span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="title function_">__defineGetter__</span>(<span class="string">&#x27;userAgent&#x27;</span>, <span class="function">() =&gt;</span> <span class="string">&#x27;foobar&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span>); </span><br><span class="line"><span class="comment">// foobar</span></span><br></pre></td></tr></table></figure>

<p>所以说这个UA还是不可靠的</p>
<h5 id="分析浏览器"><a href="#分析浏览器" class="headerlink" title="分析浏览器"></a>分析浏览器</h5><p>通过解析浏览器返回的用户代理字符串，可以极其准确地推断出下列相关的环境信息：</p>
<ul>
<li> 浏览器</li>
<li> 浏览器版本</li>
<li> 浏览器渲染引擎</li>
<li> 设备类型（桌面&#x2F;移动）</li>
<li> 设备生产商</li>
<li> 设备型号</li>
<li> 操作系统</li>
<li> 操作系统版本</li>
</ul>
<p>因为新浏览器、新操作系统和新硬件设备随时可能出现，其中很多可能有着类似但并不相同的用户代理字符串。UA频繁变化，推荐一些 GitHub 上维护比较频繁的第三方用户代理解析程序</p>
<h4 id="13-3软件与硬件检测（了解）"><a href="#13-3软件与硬件检测（了解）" class="headerlink" title="13.3软件与硬件检测（了解）"></a>13.3软件与硬件检测（了解）</h4><p>现代浏览器提供了一组与页面执行环境相关的信息，包括浏览器、操作系统、硬件和周边设备信息。这些属性可以通过暴露在 window.navigator 上的一组 API 获得。不过，这些 API 的跨浏览器支持还不够好，远未达到标准化的程度。</p>
<h5 id="识别浏览器与操作系统"><a href="#识别浏览器与操作系统" class="headerlink" title="识别浏览器与操作系统"></a>识别浏览器与操作系统</h5><ul>
<li>navigator.oscpu</li>
<li>navigator.vendor</li>
<li>navigator.platform</li>
<li>screen.colorDepth 和 screen.pixelDepth</li>
<li>screen.orientation</li>
</ul>
<h5 id="浏览器元数据"><a href="#浏览器元数据" class="headerlink" title="浏览器元数据"></a>浏览器元数据</h5><p><strong>Geolocation API</strong></p>
<p>navigator.geolocation 属性暴露了 Geolocation API，可以让浏览器脚本感知当前设备的地理位 置。这个 API 只在安全执行环境（通过 HTTPS 获取的脚本）中可用。</p>
<p>根据宿主系统的硬件和配置，返回结果的精度可能不一样。手机 GPS 的坐标系统可能具有极高的精度，而 IP 地址的精度就要差很多。</p>
<p><strong>Connection State 和 NetworkInformation API</strong></p>
<p>浏览器会跟踪网络连接状态并以两种方式暴露这些信息：连接事件和 navigator.onLine 属性。 在设备连接到网络时，浏览器会记录这个事实并在 window 对象上触发 online 事件。</p>
<p>这个属性返回一个布尔值，表示浏览器是否联网。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">connectionStateChange</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">onLine</span>); </span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;online&#x27;</span>, connectionStateChange); </span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;offline&#x27;</span>, connectionStateChange); </span><br><span class="line"><span class="comment">// 设备联网时：</span></span><br><span class="line"><span class="comment">// true </span></span><br><span class="line"><span class="comment">// 设备断网时：</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>navigator 对象还暴露了 NetworkInformation API，可以通过 navigator.connection 属性使用。</p>
<p><strong>Battery Status API</strong> 浏览器可以访问设备电池及充电状态的信息。navigator.getBattery()方法会返回一个期约实 例，解决为一个 BatteryManager 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="title function_">getBattery</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">b</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(b));</span><br></pre></td></tr></table></figure>

<h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><p>浏览器检测硬件的能力相当有限。不过，navigator 对象还是通过一些属性提供了基本信息。</p>
<ol>
<li>处理器核心数</li>
<li>设备内存大小</li>
<li>最大触点数</li>
</ol>
<h3 id="14：DOM"><a href="#14：DOM" class="headerlink" title="14：DOM"></a>14：DOM</h3><p>文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。</p>
<h4 id="14-1节点层级"><a href="#14-1节点层级" class="headerlink" title="14.1节点层级"></a>14.1节点层级</h4><p>根节点的唯一子节点是元素，我们称之 为文档元素（documentElement）。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之 内。每个文档只能有一个文档元素。在 HTML 页面中，文档元素始终是元素。</p>
<h5 id="14-1-1Node-类型"><a href="#14-1-1Node-类型" class="headerlink" title="14.1.1Node 类型"></a>14.1.1Node 类型</h5><p>每个节点都有 nodeType 属性，表示该节点的类型。节点类型由定义在 Node 类型上的 12 个数值常量表示：</p>
<ul>
<li>Node.ELEMENT_NODE（1）</li>
<li>Node.ATTRIBUTE_NODE（2）</li>
<li>Node.TEXT_NODE（3）</li>
<li>Node.CDATA_SECTION_NODE（4）</li>
<li>Node.ENTITY_REFERENCE_NODE（5）</li>
<li>Node.ENTITY_NODE（6）</li>
<li>Node.PROCESSING_INSTRUCTION_NODE（7）</li>
<li>Node.COMMENT_NODE（8）</li>
<li>Node.DOCUMENT_NODE（9）</li>
<li>Node.DOCUMENT_TYPE_NODE（10）</li>
<li>Node.DOCUMENT_FRAGMENT_NODE（11）</li>
<li>Node.NOTATION_NODE（12）</li>
</ul>
<p>浏览器并不支持所有节点类型。开发者最常用到的是元素节点和文本节点。</p>
<p>节点类型可通过与这些常量比较来确定，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nodeType</span> == <span class="title class_">Node</span>.<span class="property">ELEMENT_NODE</span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;Node is an element.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1. nodeName 与 nodeValue</strong></p>
<p>nodeName 与 nodeValue 保存着有关节点的信息。这两个属性的值完全取决于节点类型。在使用这两个属性前，最好先检测节点类型，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nodeType</span> == <span class="number">1</span>)&#123; </span><br><span class="line"> value = someNode.<span class="property">nodeName</span>; <span class="comment">// 会显示元素的标签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 节点关系</strong></p>
<p>总的来说就两种：&#x3D;&#x3D;父子关系，兄弟关系&#x3D;&#x3D;</p>
<ul>
<li>父节点访问子节点：childNodes</li>
<li>子节点访问父节点：parentNode</li>
<li>上一个兄弟节点：previousSibling</li>
<li>下一个兄弟节点：nextSibling</li>
<li>父节点访问第一个子节点：firstChild</li>
<li>父节点访问最后一个子节点：lastChild</li>
</ul>
<p>注意点：NodeList 并不是 Array 的实例，但可以使用中括 号访问它的值，而且它也有 length 属性。</p>
<p>判读有没有子节点还可以用：hasChildNodes()，这个方法如果返回 true 则说明节点有一个或多个子节点。</p>
<p>ownerDocument 属性是一个指向代表整个文档的文档节点 的指针。</p>
<p><strong>3. 操纵节点</strong></p>
<p>因为所有关系指针都是只读的，所以 DOM 又提供了一些操纵节点的方法</p>
<ul>
<li>appendChild()  用于在 childNodes 列表末尾添加节点。</li>
<li>insertBefore()  把节点放到 childNodes 中的特定位置而不是末尾,接收两个参数：要插入的节点和参照节点</li>
<li>replaceChild() 要替换的节点会被返回并从文档 树中完全移除，要插入的节点会取而代之,接收两个参数：要插入的节点和要替换的节点。</li>
<li>removeChild() 这个方法接收一个参数，即要移除 的节点。被移除的节点会被返回</li>
</ul>
<p>注意点: appendChild()方法返回新添加的节点，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> returnedNode = someNode.<span class="title function_">appendChild</span>(newNode); </span><br><span class="line"><span class="title function_">alert</span>(returnedNode == newNode); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(someNode.<span class="property">lastChild</span> == newNode); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果把文档中已经存在的节点传给 appendChild()，则这个节点会从之前的位置被转移到新位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 someNode 有多个子节点</span></span><br><span class="line"><span class="keyword">let</span> returnedNode = someNode.<span class="title function_">appendChild</span>(someNode.<span class="property">firstChild</span>); </span><br><span class="line"><span class="title function_">alert</span>(returnedNode == someNode.<span class="property">firstChild</span>); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(returnedNode == someNode.<span class="property">lastChild</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果参照节点是 null，则 insertBefore()与 appendChild()效果相 同，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为最后一个子节点插入</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, <span class="literal">null</span>); </span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">lastChild</span>); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 作为新的第一个子节点插入</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, someNode.<span class="property">firstChild</span>); </span><br><span class="line"><span class="title function_">alert</span>(returnedNode == newNode); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">firstChild</span>); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 插入最后一个子节点前面</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, someNode.<span class="property">lastChild</span>); </span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">childNodes</span>[someNode.<span class="property">childNodes</span>.<span class="property">length</span> - <span class="number">2</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面介绍的 4 个方法都用于操纵某个节点的子元素，也就是说使用它们之前必须先取得父节点（使用前面介绍的 parentNode属性）。并非所有节点类型都有子节点，如果在不支持子节点的节点上调用这些方法，则会导致抛出错误。</p>
<p><strong>4. 其他方法</strong></p>
<ul>
<li>cloneNode()  会返回与调用它的节点一模一样的节 点。cloneNode()方法接收一个布尔值参数，表示是否深复制。在传入 true 参数时，会进行深复制， 即复制节点及其整个子 DOM 树。如果传入 false，则只会复制调用该方法的节点。</li>
<li>normalize() 这个方法唯一的任务就是处理文档子树中的文本节 点。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点。</li>
</ul>
<h5 id="14-1-2Document-类型"><a href="#14-1-2Document-类型" class="headerlink" title="14.1.2Document 类型"></a>14.1.2Document 类型</h5><p>Document 类型是 JavaScript 中表示文档节点的类型。在浏览器中，文档对象 document 是 HTMLDocument 的实例（HTMLDocument 继承 Document），表示整个 HTML 页面。document 是 window 对象的属性，因此是一个全局对象</p>
<p><strong>文档子节点</strong></p>
<p>documentElement 属 性，始终指向 HTML 页面中的元素。</p>
<p>三个便捷属性：</p>
<ul>
<li>documentElement</li>
<li>body</li>
<li>doctype</li>
</ul>
<p>浏览器解析完这个页面之后，文档只有一个子节点，即元素。这个元素既可以通过documentElement 属性获取，也可以通过 childNodes 列表访问，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="variable language_">document</span>.<span class="property">documentElement</span>; <span class="comment">// 取得对&lt;html&gt;的引用</span></span><br><span class="line"><span class="title function_">alert</span>(html === <span class="variable language_">document</span>.<span class="property">childNodes</span>[<span class="number">0</span>]); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(html === <span class="variable language_">document</span>.<span class="property">firstChild</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这个例子表明 documentElement、firstChild 和 childNodes[0]都指向同一个值，即 元素。</p>
<p>document 对象还有一个 body 属性，直接指向元素。因为 这个元素是开发者使用最多的元素，所以 JavaScript 代码中经常可以看到 document.body</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> body = <span class="variable language_">document</span>.<span class="property">body</span>; <span class="comment">// 取得对&lt;body&gt;的引用</span></span><br></pre></td></tr></table></figure>

<p>Document 类型另一种可能的子节点是 DocumentType。标签是文档中独立的部分， 其信息可以通过 doctype 属性（在浏览器中是 document.doctype）来访问，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doctype = <span class="variable language_">document</span>.<span class="property">doctype</span>; <span class="comment">// 取得对&lt;!doctype&gt;的引用</span></span><br></pre></td></tr></table></figure>

<p>appendChild()、removeChild()和 replaceChild()方法不会用在 document 对象上。这是因为文档类型（如果存在）是只读的，而且只能有一个 Element 类型的子节点</p>
<p><strong>文档信息</strong></p>
<ul>
<li>title</li>
<li>URL</li>
<li>domain（域名）</li>
<li>referrer</li>
</ul>
<p>其中最常用的是title，包含元素中的文本，通常显示在浏 览器窗口或标签页的标题栏。通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题 栏上。 </p>
<p><strong>定位元素</strong></p>
<ul>
<li>getElementById()</li>
<li>getElementsByTagName()</li>
<li>getElementsByName()</li>
</ul>
<p>注意点:</p>
<p>如果页面中存在多个具有相同 ID 的元素，则 getElementById()返回在文档中出现的第一个元素。</p>
<p>getElementsByTagName这个方法接收一个参数，即要 获取元素的标签名，返回包含零个或多个元素的 HTMLCollection。</p>
<p>HTMLCollection 对象还有一个额外的方法 namedItem()，可通过标签的 name 属性取得某一项 的引用。</p>
<p>数值索引会调用 item()，字符串索引会调用 namedItem()。</p>
<p>要取得文档中的所有元素，可以给 getElementsByTagName()传入*。</p>
<p>getElementsByName这个 方法会返回具有给定 name 属性的所有元素。getElementsByName()方法最常用于单选按钮，因为同一字段的单选按钮必须具有相同的 name 属性才能确保把正确的值发送给服务器</p>
<p><strong>特殊集合</strong></p>
<p>document 对象上还暴露了几个特殊集合，这些集合也都是 HTMLCollection 的实例。这些集合是访问文档中公共部分的快捷方式</p>
<ul>
<li>document.anchors</li>
<li>document.applets</li>
<li>document.forms</li>
<li>document.images</li>
<li>document.links</li>
</ul>
<p><strong>DOM 兼容性检测</strong></p>
<p>document.implementation 属性是一个对象，其中提供了与浏览器 DOM 实现相关的信息和能力。</p>
<p>hasFeature()。这个方法接 收两个参数：特性名称和 DOM 版本。如果浏览器支持指定的特性和版本，则 hasFeature()方法返回 true</p>
<p>由于实现不一致，因此 hasFeature()的返回值并不可靠。目前这个方法已经被废弃，不再建议使用。</p>
<p><strong>文档写入</strong></p>
<p>write()和 writeln()方法都接收一个字符串参数，可以将 这个字符串写入网页中。write()简单地写入文本，而 writeln()还会在字符串末尾追加一个换行符 （\n）。这两个方法可以用来在页面加载期间向页面中动态添加内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        document.write(&quot;<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">\</span>&quot;<span class="attr">text</span>/<span class="attr">javascript</span>\&quot; <span class="attr">src</span>=<span class="string">\</span>&quot;<span class="attr">file.js</span>\&quot;&gt;</span>&quot; +</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">            &quot;&lt;\/script&gt;&quot;); </span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>前面的例子展示了在页面渲染期间通过 document.write()向文档中输出内容。如果是在页面加 载完之后再调用 document.write()，则输出的内容会重写整个页面</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is some content that you won&#x27;t get to see because it will be</span><br><span class="line">        overwritten.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Hello world!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子使用了 window.onload 事件处理程序，将调用 document.write()的函数推迟到页面 加载完毕后执行。执行之后，字符串”Hello world!”会重写整个页面内容</p>
<h5 id="14-1-3Element-类型"><a href="#14-1-3Element-类型" class="headerlink" title="14.1.3Element 类型"></a>14.1.3Element 类型</h5><p>nodeName 或 tagName 属性来获取元素的标签名</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以像这样取得这个元素的标签名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">tagName</span>); <span class="comment">// &quot;DIV&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">tagName</span> == div.<span class="property">nodeName</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果不确定脚本是在 HTML 文档还是 XML 文档中运行，最好将标签名转换为小 写形式，以便于比较：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.<span class="property">tagName</span> == <span class="string">&quot;div&quot;</span>)&#123; <span class="comment">// 不要这样做，可能出错！</span></span><br><span class="line"> <span class="comment">// do something here </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (element.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;div&quot;</span>)&#123; <span class="comment">// 推荐，适用于所有文档</span></span><br><span class="line"> <span class="comment">// 做点什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h6><ul>
<li>id，元素在文档中的唯一标识符；</li>
<li>title，包含元素的额外信息，通常以提示条形式展示；</li>
<li>lang，元素内容的语言代码（很少用）；</li>
<li>dir，语言的书写方向（”ltr”表示从左到右，”rtl”表示从右到左，同样很少用）；</li>
<li>className，相当于 class 属性，用于指定元素的 CSS 类（因为 class 是 ECMAScript 关键字，所以不能直接用这个名字）。</li>
</ul>
<h6 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h6><p>与属性相关的 DOM 方法主要有 3 个：</p>
<ul>
<li>getAttribute()</li>
<li>setAttribute()</li>
<li>removeAttribute()</li>
</ul>
<p><strong>取得属性</strong></p>
<p>两种方式可以取得：</p>
<ul>
<li>1，getAttribute()</li>
<li>2，DOM对象上取得</li>
</ul>
<p>比如：</p>
<p>定义了一个div</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">my_special_attribute</span>=<span class="string">&quot;hello!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就可以通过下面方法取得属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;id&quot;</span>)); <span class="comment">// &quot;myDiv&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;id&quot;</span>)); <span class="comment">// &quot;myDiv&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">id</span>)   <span class="comment">// &quot;myDiv&quot;</span></span><br><span class="line"><span class="comment">// 注意这个</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">ID</span>)   <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义属性</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;my_special_attribute&quot;</span>))  <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是：</p>
<p>getAttribute()的属性名与它们实际的属性名是一样的，因此这里要传”class”而非”className”</p>
<p>如果给定的属性不存在，则 getAttribute() 返回 null</p>
<p>属性名不区分大小写，因此”ID”和”id”被认为是同一个属性</p>
<p>getAttribute()方法也能取得不是HTML语言正式属性的自定义属性的值。</p>
<p>根据 HTML5 规范的 要求,自定义属性名应该前缀 data-以方便验证。</p>
<p>通过 DOM 对象访问的属性中有两个返回的值跟使用 getAttribute()取得的值不一样,一个是style属性，另一个是事件处理程序；</p>
<ul>
<li>style属性：在使用 getAttribute()访问 style 属性时，返回的 是 CSS 字符串。而在通过 DOM 对象的属性访问时，style 属性返回的是一个（CSSStyleDeclaration） 对象。</li>
<li>事件处理程序：如果使用 getAttribute()访问事件属性， 则返回的是字符串形式的源代码。而通过 DOM 对象的属性访问事件属性时返回的则是一个 JavaScript 函数（未指定该属性则返回 null）。</li>
</ul>
<p>考虑到以上差异，开发者在进行DOM编程时通常会放弃使用getAttribute()而只使用对象属性。getAttribute()主要用于取得自定义属性的值</p>
<p><strong>设置属性</strong></p>
<p>同样两种方式，一个是setAttribute，一个是dom对象操作；</p>
<p>setAttribute()这个方法接收两个参数：要设置的属性名 和属性的值。如果属性已经存在，则 setAttribute()会以指定的值替换原来的值；如果属性不存在， 则 setAttribute()会以指定的值创建该属性。</p>
<p>注意点：</p>
<p>setAttribute()适用于 HTML 属性，也适用于自定义属性。另外，使用 setAttribute()方法 设置的属性名会规范为小写形式，因此”ID”会变成”id”。</p>
<p>在 DOM 对象上添加自定义属性，如下面的例子所示，不会自动让它变成元素的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">mycolor</span> = <span class="string">&quot;red&quot;</span>; </span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;mycolor&quot;</span>)); <span class="comment">// null（IE 除外）</span></span><br></pre></td></tr></table></figure>

<p><strong>删除属性</strong></p>
<p>removeAttribute()用于从元素中删除属性，这样不单单是清除属性的值，而是会把整个属性完全从元素中去掉</p>
<h6 id="attributes-属性"><a href="#attributes-属性" class="headerlink" title="attributes 属性"></a>attributes 属性</h6><p>相当于是多个属性的集合</p>
<ul>
<li> getNamedItem(name)，返回 nodeName 属性等于 name 的节点；</li>
<li> removeNamedItem(name)，删除 nodeName 属性等于 name 的节点；</li>
<li> setNamedItem(node)，向列表中添加 node 节点，以其 nodeName 为索引；</li>
<li> item(pos)，返回索引位置 pos 处的节点。</li>
</ul>
<p>因为使用起来更简便，通常开发者更喜欢使用 getAttribute()、removeAttribute() 和 setAttribute()方法，</p>
<p>attributes 属性最有用的场景是需要迭代元素上所有属性的时候。</p>
<p>比如，以下代码能够迭代一个元素上的所有属性并以 attribute1&#x3D; “value1” attribute2&#x3D;”value2”的形式生成格式化字符串：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bd&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Body text&quot;</span> <span class="attr">a</span>=<span class="string">&quot;b&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:red;&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">outputAttributes</span>(<span class="params">element</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> pairs = [];</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = element.<span class="property">attributes</span>.<span class="property">length</span>; i &lt; len; ++i) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> attribute = element.<span class="property">attributes</span>[i];</span></span><br><span class="line"><span class="language-javascript">                pairs.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;attribute.nodeName&#125;</span>=&quot;<span class="subst">$&#123;attribute.nodeValue&#125;</span>&quot;`</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> pairs.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputAttributes</span>(div)) <span class="comment">// id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; a=&quot;b&quot; lang=&quot;en&quot; style=&quot;color:red;&quot; dir=&quot;ltr&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不同浏览器返回的 attributes 中的属性顺序也可能不一样。 HTML 或 XML 代码中属性出现的顺序不一定与 attributes 中的顺序一致。</p>
<h6 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h6><p>document.createElement()方法创建新元素。这个方法接收一个参数，即要创建元素的标签名。</p>
<p>要创建元素，可以使用下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用 createElement()方法创建新元素的同时也会将其 ownerDocument 属性设置为 document。</p>
<p>此时，可以再为其添加属性、添加更多子元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">id</span> = <span class="string">&quot;myNewDiv&quot;</span>; </span><br><span class="line">div.<span class="property">className</span> = <span class="string">&quot;box&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在新元素上设置这些属性只会附加信息。因为这个元素还没有添加到文档树，所以不会影响浏览器 显示。要把元素添加到文档树，可以使用 appendChild()、insertBefore()或 replaceChild()。 比如，以下代码会把刚才创建的元素添加到文档的元素中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br></pre></td></tr></table></figure>

<p>元素被添加到文档树之后，浏览器会立即将其渲染出来。之后再对这个元素所做的任何修改，都会立即在浏览器中反映出来。</p>
<h6 id="元素后代"><a href="#元素后代" class="headerlink" title="元素后代"></a>元素后代</h6><p>childNodes 属性包含元素所有的子节点，这些子节点可能是其他元素、文本节点、注释或处理指令。</p>
<p>注意空格文本元素</p>
<p>开发者正常的写法:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;ul&gt;元素会包含 7 个子元素，其中 3 个是&lt;li&gt;元素，还有 4 个 Text 节点（表示&lt;li&gt;元素周围的空格）。--&gt;</span></span><br></pre></td></tr></table></figure>

<p>经过压缩代码之后就会变成下面的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>考虑到这种情况，通常在执行某个 操作之后需要先检测一下节点的 nodeType，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = element.<span class="property">childNodes</span>.<span class="property">length</span>; i &lt; len; ++i) &#123; </span><br><span class="line"> <span class="keyword">if</span> (element.<span class="property">childNodes</span>[i].<span class="property">nodeType</span> == <span class="number">1</span>) &#123; </span><br><span class="line"> <span class="comment">// 执行某个操作</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>含有一种方式：可以使用元素的 getElementsByTagName()方法。在 元素上调用这个方法与在文档上调用是一样的，只不过搜索范围限制在当前元素之内，即只会返回当前元素的后代。如果它包含更多层级，则所有层级中的<li>元素都会返回</p>
<h5 id="14-1-4Text-类型"><a href="#14-1-4Text-类型" class="headerlink" title="14.1.4Text 类型"></a>14.1.4Text 类型</h5><p>Text 节点由 Text 类型表示，包含按字面解释的纯文本，也可能包含转义后的 HTML 字符，但不含 HTML 代码。</p>
<p>Text 节点中包含的文本可以通过 nodeValue 属性访问，也可以通过 data 属性访问，这两个属性包含相同的值。修改 nodeValue 或 data 的值，也会在另一个属性反映出来。</p>
<ul>
<li> appendData(text)，向节点末尾添加文本 text；</li>
<li> deleteData(offset, count)，从位置 offset 开始删除 count 个字符；</li>
<li> insertData(offset, text)，在位置 offset 插入 text；</li>
<li> replaceData(offset, count, text)，用 text 替换从位置 offset 到 offset + count 的</li>
<li>文本；</li>
<li> splitText(offset)，在位置 offset 将当前文本节点拆分为两个文本节点；</li>
<li> substringData(offset, count)，提取从位置 offset 到 offset + count 的文本。</li>
</ul>
<p>访问文本节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textNode = div.<span class="property">firstChild</span>; <span class="comment">// 或 div.childNodes[0]</span></span><br></pre></td></tr></table></figure>

<p>修改文本节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">firstChild</span>.<span class="property">nodeValue</span> = <span class="string">&quot;Some other message&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>需要注意，就是HTML 或 XML 代码（取决于文档类型）会被转换成实体编码，即小于号、大于号或引号会被转义，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出为&quot;Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message&quot; </span></span><br><span class="line">div.<span class="property">firstChild</span>.<span class="property">nodeValue</span> = <span class="string">&quot;Some &lt;strong&gt;other&lt;/strong&gt; message&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>实际上用innerHTML方法更多一些；</p>
<p><strong>创建文本节点</strong></p>
<p>document.createTextNode()可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。</p>
<p>创建文本节点并且把它插入到文档中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element);</span><br></pre></td></tr></table></figure>

<p>这个例子首先创建了一个</p>
<p>元素并给它添加了值为”message”的 class 属性，然后又创建了一个文本节点并添加到该元素。最后一步是把这个元素添加到文档的主体上，这样元素及其包含的文本会出现在浏览器中。</p>
<p>一般来说一个元素只包含一个文本子节点。不过，也可以让元素包含多个文本子节点，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>; </span><br><span class="line"><span class="comment">// 第一个子节点</span></span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode); </span><br><span class="line"><span class="comment">// 第二个子节点</span></span><br><span class="line"><span class="keyword">let</span> anotherTextNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Yippee!&quot;</span>); </span><br><span class="line">element.<span class="title function_">appendChild</span>(anotherTextNode); </span><br><span class="line"><span class="comment">// 插入到文档中</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element);</span><br></pre></td></tr></table></figure>

<p>在将一个文本节点作为另一个文本节点的同胞插入后，两个文本节点的文本之间不会包含空格。</p>
<p><strong>规范化文本节点</strong></p>
<p>在包含两个或多个相邻文本节点的父节点上调用 normalize()时，所有同胞文本节点会被合并为一个文本节点，这个文本节点的 nodeValue 就等于之前所有同胞节点 nodeValue 拼接在一起得到的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode); </span><br><span class="line"><span class="keyword">let</span> anotherTextNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Yippee!&quot;</span>); </span><br><span class="line">element.<span class="title function_">appendChild</span>(anotherTextNode); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element); </span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 2 </span></span><br><span class="line">element.<span class="title function_">normalize</span>(); </span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 1 </span></span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">firstChild</span>.<span class="property">nodeValue</span>); <span class="comment">// &quot;Hello world!Yippee!&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>拆分文本节点</strong></p>
<p>Text 类型定义了一个与 normalize()相反的方法——splitText()。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element); </span><br><span class="line"><span class="keyword">let</span> newNode = element.<span class="property">firstChild</span>.<span class="title function_">splitText</span>(<span class="number">5</span>); </span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">firstChild</span>.<span class="property">nodeValue</span>); <span class="comment">// &quot;Hello&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(newNode.<span class="property">nodeValue</span>); <span class="comment">// &quot; world!&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>拆分文本节点最常用于从文本节点中提取数据的 DOM 解析技术。</p>
<h5 id="14-1-5Comment-类型"><a href="#14-1-5Comment-类型" class="headerlink" title="14.1.5Comment 类型"></a>14.1.5<strong>Comment</strong> 类型</h5><p>DOM 中的注释通过 Comment 类型表示。</p>
<p>Comment 类型与 Text 类型继承同一个基类（CharacterData），因此拥有除 splitText()之外Text 节点所有的字符串操作方法。与 Text 类型相似，注释的实际内容可以通过 nodeValue 或 data属性获得。</p>
<p>注释节点可以作为父节点的子节点来访问。比如下面的 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="comment">&lt;!-- A comment --&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的注释是</p>
<p>元素的子节点，这意味着可以像下面这样访问它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> comment = div.<span class="property">firstChild</span>; </span><br><span class="line"><span class="title function_">alert</span>(comment.<span class="property">data</span>); <span class="comment">// &quot;A comment&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以使用 document.createComment()方法创建注释节点，参数为注释文本，很少用;</p>
<h5 id="14-1-6CDATASection-类型（了解）"><a href="#14-1-6CDATASection-类型（了解）" class="headerlink" title="14.1.6CDATASection 类型（了解）"></a><strong>14.1.6CDATASection</strong> 类型（了解）</h5><p>CDATASection 类型表示 XML 中特有的 CDATA 区块。CDATASection 类型继承 Text 类型，因此拥有包括 splitText()在内的所有字符串操作方法。</p>
<p>用法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>&lt;![CDATA[This is some content.]]&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里</p>
<p>的第一个子节点应该是 CDATASection 节点。但主流的四大浏览器没有一个将其识别为CDATASection。即使在有效的 XHTML 文档中，这些浏览器也不能恰当地支持嵌入的 CDATA 区块。</p>
<p>在真正的 XML 文档中，可以使用 document.createCDataSection()并传入节点内容来创建CDATA 区块。</p>
<h5 id="14-1-7DocumentType-类型-了解"><a href="#14-1-7DocumentType-类型-了解" class="headerlink" title="14.1.7DocumentType 类型(了解)"></a><strong>14.1.7DocumentType</strong> 类型(了解)</h5><p>DocumentType 类型的节点包含文档的文档类型（doctype）信息，nodeType 等于 10，不支持子节点。</p>
<p>DOM Level 1 规定了DocumentType 对象的 3 个属性：name、entities 和 notations。其中，name 是文档类型的名称，entities 是这个文档类型描述的实体的 NamedNodeMap，而 notations 是这个文档类型描述的表示法的 NamedNodeMap。因为浏览器中的文档通常是 HTML 或 XHTML 文档类型，所以 entities 和notations 列表为空。</p>
<p>只有 name 属性是有用的。这个属性包含文档类型的名称，即紧跟在&lt;!DOCTYPE 后面的那串文本。</p>
<p>比如下面的 HTML 4.01 严格文档类型：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-// W3C// DTD HTML 4.01// EN&quot;</span> </span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http:// www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于这个文档类型，name 属性的值是”html”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">doctype</span>.<span class="property">name</span>); <span class="comment">// &quot;html&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="14-1-8DocumentFragment-类型"><a href="#14-1-8DocumentFragment-类型" class="headerlink" title="14.1.8DocumentFragment 类型"></a><strong>14.1.8DocumentFragment</strong> 类型</h5><p>在所有节点类型中，DocumentFragment 类型是唯一一个在标记中没有对应表示的类型。DOM 将文档片段定义为“轻量级”文档，能够包含和操作节点，却没有完整文档那样额外的消耗。</p>
<p>DocumentFragment 节点具有以下特征：</p>
<ul>
<li> nodeType 等于 11；</li>
<li> nodeName 值为”#document-fragment”；</li>
<li> nodeValue 值为 null；</li>
<li> parentNode 值为 null；</li>
<li> 子节点可以是 Element、ProcessingInstruction、Comment、Text、CDATASection 或</li>
<li>EntityReference。</li>
</ul>
<p>出现目的：为避免多次渲染假设想给这个元素添加 3 个列表项。如果分 3 次给这个元素添加列表项，浏览器就要重新渲染3 次页面，以反映新添加的内容。为避免多次渲染，下面的代码示例使用文档片段创建了所有列表项，然后一次性将它们添加到了元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let fragment = document.createDocumentFragment(); </span><br><span class="line">let ul = document.getElementById(&quot;myList&quot;); </span><br><span class="line">for (let i = 0; i &lt; 3; ++i) &#123; </span><br><span class="line"> let li = document.createElement(&quot;li&quot;); </span><br><span class="line"> li.appendChild(document.createTextNode(`Item $&#123;i + 1&#125;`)); </span><br><span class="line"> fragment.appendChild(li); </span><br><span class="line">&#125; </span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure>

<h5 id="14-1-9Attr-类型-了解"><a href="#14-1-9Attr-类型-了解" class="headerlink" title="14.1.9Attr 类型(了解)"></a><strong>14.1.9Attr</strong> 类型(了解)</h5><p>元素数据在 DOM 中通过 Attr 类型表示。Attr 类型构造函数和原型在所有浏览器中都可以直接访问。技术上讲，属性是存在于元素 attributes 属性中的节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> attr = <span class="variable language_">document</span>.<span class="title function_">createAttribute</span>(<span class="string">&quot;align&quot;</span>); </span><br><span class="line">attr.<span class="property">value</span> = <span class="string">&quot;left&quot;</span>; </span><br><span class="line">element.<span class="title function_">setAttributeNode</span>(attr); </span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">attributes</span>[<span class="string">&quot;align&quot;</span>].<span class="property">value</span>); <span class="comment">// &quot;left&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(element.<span class="title function_">getAttributeNode</span>(<span class="string">&quot;align&quot;</span>).<span class="property">value</span>); <span class="comment">// &quot;left&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(element.<span class="title function_">getAttribute</span>(<span class="string">&quot;align&quot;</span>)); <span class="comment">// &quot;left&quot;</span></span><br></pre></td></tr></table></figure>

<p>attributes 属性和getAttributeNode()方法都返回属性对应的 Attr 节点，而 getAttribute()方法只返回属性的值。开发中用的不多；</p>
<h4 id="14-2DOM-编程"><a href="#14-2DOM-编程" class="headerlink" title="14.2DOM 编程"></a>14.2DOM 编程</h4><h5 id="14-2-1动态脚本"><a href="#14-2-1动态脚本" class="headerlink" title="14.2.1动态脚本"></a>14.2.1动态脚本</h5><p>动态脚本就是在页面初始加载时不存在，之后又通过 DOM 包含的脚本。</p>
<p>有两种方式通过 </p>
<p>动态加载外部文件很容易实现，比如下面的 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以像这样通过 DOM 编程创建这个节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>); </span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;foo.js&quot;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure>

<p>这个过程可以抽象为一个函数，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">loadScript</span><span class="params">(url)</span> &#123; </span><br><span class="line"> <span class="type">let</span> <span class="variable">script</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;script&quot;</span>); </span><br><span class="line"> script.src = url; </span><br><span class="line"> document.body.appendChild(script); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后，就可以像下面这样加载外部 JavaScript 文件了：</span></span><br><span class="line">loadScript(<span class="string">&quot;client.js&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>另一个动态插入 JavaScript 的方式是嵌入源代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; </span></span><br><span class="line"><span class="language-javascript">   		<span class="title function_">alert</span>(<span class="string">&quot;hi&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">   &#125; </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">let script = document.createElement(&quot;script&quot;); </span><br><span class="line">script.appendChild(document.createTextNode(&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;)); </span><br><span class="line">document.body.appendChild(script);</span><br></pre></td></tr></table></figure>

<p>以上代码可以在 Firefox、Safari、Chrome 和 Opera 中运行。不过在旧版本的 IE 中可能会导致问题。这是因为 IE 对 </p>
<p>但 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>); </span><br><span class="line">script.<span class="property">text</span> = <span class="string">&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure>

<p>这样修改后，上面的代码可以在 IE、Firefox、Opera 和 Safari 3 及更高版本中运行。Safari 3 之前的版本不能正确支持这个 text 属性，但这些版本却支持文本节点赋值。</p>
<p>我们就可以抽象出一个跨浏览器的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadScriptString</span>(<span class="params">code</span>)&#123; </span><br><span class="line"> <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>); </span><br><span class="line"> script.<span class="property">type</span> = <span class="string">&quot;text/javascript&quot;</span>; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> script.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(code)); </span><br><span class="line"> &#125; <span class="keyword">catch</span> (ex)&#123; </span><br><span class="line"> script.<span class="property">text</span> = code; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数可以这样调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loadScriptString</span>(<span class="string">&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以这种方式加载的代码会在全局作用域中执行，并在调用返回后立即生效。基本上，这就相当于在全局作用域中把源代码传给 eval()方法。</p>
<p>注意，通过 innerHTML 属性创建的 </p>
<h5 id="14-2-2动态样式"><a href="#14-2-2动态样式" class="headerlink" title="14.2.2动态样式"></a>14.2.2动态样式</h5><p>CSS 样式在 HTML 页面中可以通过两个元素加载。元素用于包含 CSS 外部文件，而元素用于添加嵌入样式。与动态脚本类似，动态样式也是页面初始加载时并不存在，而是在之后才添加到页面中的。 </p>
<p>来看下面这个典型的元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个元素很容易使用 DOM 编程创建出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;link&quot;</span>); </span><br><span class="line">link.<span class="property">rel</span> = <span class="string">&quot;stylesheet&quot;</span>; </span><br><span class="line">link.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>; </span><br><span class="line">link.<span class="property">href</span> = <span class="string">&quot;styles.css&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line">head.<span class="title function_">appendChild</span>(link);</span><br></pre></td></tr></table></figure>

<p>以上代码在所有主流浏览器中都能正常运行。注意应该把元素添加到元素而不是元素，这样才能保证所有浏览器都能正常运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadStyles</span>(<span class="params">url</span>)&#123; </span><br><span class="line"> <span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;link&quot;</span>); </span><br><span class="line"> link.<span class="property">rel</span> = <span class="string">&quot;stylesheet&quot;</span>; </span><br><span class="line"> link.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>; </span><br><span class="line"> link.<span class="property">href</span> = url; </span><br><span class="line"> <span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line"> head.<span class="title function_">appendChild</span>(link); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以这样调用这个 loadStyles()函数了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loadStyles</span>(<span class="string">&quot;styles.css&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过外部文件加载样式是一个异步过程。</p>
<p>另一种定义样式的方式是使用 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"> </span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123; </span></span><br><span class="line"><span class="language-css"> <span class="attribute">background-color</span>: red; </span></span><br><span class="line"><span class="language-css">&#125; </span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>逻辑上，下列 DOM 代码会有同样的效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;style&quot;</span>); </span><br><span class="line">style.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>; </span><br><span class="line">style.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;body&#123;background-color:red&#125;&quot;</span>)); </span><br><span class="line"><span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line">head.<span class="title function_">appendChild</span>(style);</span><br></pre></td></tr></table></figure>

<p>以上代码在 Firefox、Safari、Chrome 和 Opera 中都可以运行，但 IE 除外。IE 对节点会施加限制，不允许访问其子节点，这一点与它对元素施加的限制一样。事实上，IE 在执行到给[style]添加子节点的代码时，会抛出与给[script]添加子节点时同样的错误。 </p>
<p>对于 IE，解决方案是访问元素的 styleSheet 属性，这个属性又有一个 cssText 属性，然后给这个属性添加 CSS 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;style&quot;</span>); </span><br><span class="line">style.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>; </span><br><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line"> style.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;body&#123;background-color:red&#125;&quot;</span>)); </span><br><span class="line">&#125; <span class="keyword">catch</span> (ex)&#123; </span><br><span class="line">style.<span class="property">styleSheet</span>.<span class="property">cssText</span> = <span class="string">&quot;body&#123;background-color:red&#125;&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line">head.<span class="title function_">appendChild</span>(style);</span><br></pre></td></tr></table></figure>

<p>与动态添加脚本源代码类似，这里也使用了 try…catch 语句捕获 IE 抛出的错误，然后再以 IE特有的方式来设置样式。这是最终的通用函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadStyleString</span>(<span class="params">css</span>)&#123; </span><br><span class="line"> <span class="keyword">let</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;style&quot;</span>); </span><br><span class="line"> style.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>; </span><br><span class="line"> <span class="keyword">try</span>&#123; </span><br><span class="line"> style.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(css)); </span><br><span class="line"> &#125; <span class="keyword">catch</span> (ex)&#123; </span><br><span class="line"> style.<span class="property">styleSheet</span>.<span class="property">cssText</span> = css; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line"> head.<span class="title function_">appendChild</span>(style); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以这样调用这个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loadStyleString</span>(<span class="string">&quot;body&#123;background-color:red&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样添加的样式会立即生效，因此所有变化会立即反映出来。</p>
<h5 id="14-2-3操作表格"><a href="#14-2-3操作表格" class="headerlink" title="14.2.3操作表格"></a>14.2.3操作表格</h5><p>表格是 HTML 中最复杂的结构之一。通过 DOM 编程创建</p>
<p>元素，通常要涉及大量标签，包括表行、表元、表题，等等。因此，通过 DOM 编程创建和修改表格时可能要写很多代码。假设要通过DOM 来创建以下 HTML 表格：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">tbody</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 1,1<span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 2,1<span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 1,2<span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 2,2<span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面就是以 DOM 编程方式重建这个表格的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建表格</span></span><br><span class="line"><span class="keyword">let</span> table = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;table&quot;</span>); </span><br><span class="line">table.<span class="property">border</span> = <span class="number">1</span>; </span><br><span class="line">table.<span class="property">width</span> = <span class="string">&quot;100%&quot;</span>; </span><br><span class="line"><span class="comment">// 创建表体</span></span><br><span class="line"><span class="keyword">let</span> tbody = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tbody&quot;</span>); </span><br><span class="line">table.<span class="title function_">appendChild</span>(tbody); </span><br><span class="line"><span class="comment">// 创建第一行</span></span><br><span class="line"><span class="keyword">let</span> row1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tr&quot;</span>); </span><br><span class="line">tbody.<span class="title function_">appendChild</span>(row1); </span><br><span class="line"><span class="keyword">let</span> cell1_1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>); </span><br><span class="line">cell1_1.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 1,1&quot;</span>)); </span><br><span class="line">row1.<span class="title function_">appendChild</span>(cell1_1); </span><br><span class="line"><span class="keyword">let</span> cell2_1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>); </span><br><span class="line">cell2_1.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 2,1&quot;</span>)); </span><br><span class="line">row1.<span class="title function_">appendChild</span>(cell2_1); </span><br><span class="line"><span class="comment">// 创建第二行</span></span><br><span class="line"><span class="keyword">let</span> row2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tr&quot;</span>); </span><br><span class="line">tbody.<span class="title function_">appendChild</span>(row2); </span><br><span class="line"><span class="keyword">let</span> cell1_2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>); </span><br><span class="line">cell1_2.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 1,2&quot;</span>)); </span><br><span class="line">row2.<span class="title function_">appendChild</span>(cell1_2); </span><br><span class="line"><span class="keyword">let</span> cell2_2= <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>); </span><br><span class="line">cell2_2.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 2,2&quot;</span>)); </span><br><span class="line">row2.<span class="title function_">appendChild</span>(cell2_2); </span><br><span class="line"><span class="comment">// 把表格添加到文档主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(table);</span><br></pre></td></tr></table></figure>

<p>以上代码相当烦琐，也不好理解。为了方便创建表格，HTML 给DOM 、和元素添加了一些属性和方法。</p>
<p>table元素添加了以下属性和方法：</p>
<ul>
<li>caption，指向caption元素的指针（如果存在）；</li>
<li>tBodies，包含tbody元素的 HTMLCollection；</li>
<li>tFoot，指向tfoot元素（如果存在）；</li>
<li>Head，指向thead元素（如果存在）；</li>
<li>rows，包含表示所有行的 HTMLCollection；</li>
<li>createTHead()，创建thead元素，放到表格中，返回引用；</li>
<li>createTFoot()，创建tfoot元素，放到表格中，返回引用；</li>
<li>createCaption()，创建caption元素，放到表格中，返回引用；</li>
<li>deleteTHead()，删除thead元素；</li>
<li>deleteTFoot()，删除tfoot元素；</li>
<li>deleteCaption()，删除caption元素；</li>
<li>deleteRow(<em>pos</em>)，删除给定位置的行；</li>
<li>insertRow(<em>pos</em>)，在行集合中给定位置插入一行。</li>
</ul>
<p> 元素添加了以下属性和方法： </p>
<ul>
<li>rows，包含</li>
</ul>
<p>元素中所有行的 HTMLCollection； </p>
<p>deleteRow(<em>pos</em>)，删除给定位置的行；</p>
<p>insertRow(<em>pos</em>)，在行集合中给定位置插入一行，返回该行的引用。</p>
<p>  元素添加了以下属性和方法： </p>
<ul>
<li>cells，包含</li>
</ul>
<p>元素所有表元的 HTMLCollection； </p>
<p>deleteCell(<em>pos</em>)，删除给定位置的表元；</p>
<p>insertCell(<em>pos</em>)，在表元集合给定位置插入一个表元，返回该表元的引用。</p>
<p>这些属性和方法极大地减少了创建表格所需的代码量。</p>
<h5 id="14-2-4使用-NodeList"><a href="#14-2-4使用-NodeList" class="headerlink" title="14.2.4使用 NodeList"></a>14.2.4使用 <strong>NodeList</strong></h5><p>理解 NodeList 对象和相关的 NamedNodeMap、HTMLCollection，是理解 DOM 编程的关键。这3 个集合类型都是“实时的”，意味着文档结构的变化会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。实际上，NodeList 就是基于 DOM 文档的实时查询。例如，下面的代码会导致无穷循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i)&#123; </span><br><span class="line"> <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 ES6 迭代器并不会解决这个问题，因为迭代的是一个永远增长的实时集合。以下代码仍然会导致无穷循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> div <span class="keyword">of</span> <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>))&#123; </span><br><span class="line"> <span class="keyword">let</span> newDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(newDiv); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何时候要迭代 NodeList，最好再初始化一个变量保存当时查询时的长度，然后用循环变量与这个变量进行比较，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = divs.<span class="property">length</span>; i &lt; len; ++i) &#123; </span><br><span class="line"> <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，又初始化了一个保存集合长度的变量 len。因为 len 保存着循环开始时集合的长度，而这个值不会随集合增大动态增长，所以就可以避免前面例子中出现的无穷循环。</p>
<p>一般来说，最好限制操作 NodeList 的次数。因为每次查询都会搜索整个文档，所以最好把查询到的 NodeList 缓存起来。</p>
<h4 id="14-3MutationObserver-接口"><a href="#14-3MutationObserver-接口" class="headerlink" title="14.3MutationObserver 接口"></a><strong>14.3MutationObserver</strong> 接口</h4><p>DOM 规范中的 MutationObserver 接口，可以在 DOM 被修改时异步执行回调。使用 MutationObserver 可以观察整个文档、DOM 树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本，或者前三者任意组合的变化。</p>
<p>注意：新引进 MutationObserver 接口是为了取代废弃的 MutationEvent。</p>
<h5 id="14-3-1基本用法"><a href="#14-3-1基本用法" class="headerlink" title="14.3.1基本用法"></a>14.3.1基本用法</h5><p>MutationObserver 的实例要通过调用 MutationObserver 构造函数并传入一个回调函数来创建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM was mutated!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>observe()方法</strong></p>
<p>新创建的 MutationObserver 实例不会关联 DOM 的任何部分。要把这个 observer 与 DOM 关联起来，需要使用 observe()方法。这个方法接收两个必需的参数：要观察其变化的 DOM 节点，以及一个 MutationObserverInit 对象。</p>
<p>MutationObserverInit 对象用于控制观察哪些方面的变化，是一个键&#x2F;值对形式配置选项的字典。例如，下面的代码会创建一个观察者（observer）并配置它观察元素上的属性变化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Changed body class&#x27;</span>); </span><br><span class="line"><span class="comment">// Changed body class </span></span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br></pre></td></tr></table></figure>

<p>执行以上代码后，元素上任何属性发生变化都会被这个 MutationObserver 实例发现，然后就会异步执行注册的回调函数。元素后代的修改或其他非属性修改都不会触发回调进入任务队列。</p>
<p>注意，回调中的 console.log()是后执行的。这表明回调并非与实际的 DOM 变化同步执行。</p>
<p><strong>回调与 MutationRecord</strong>连续修改会生成多个 Muta</p>
<p>每个回调都会收到一个 MutationRecord 实例的数组。MutationRecord 实例包含的信息包括发生了什么变化，以及 DOM 的哪一部分受到了影响。因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的 MutationRecord 实例的数组</p>
<p>连续修改会生成多个 MutationRecord 实例，下次回调执行时就会收到包含所有这些实例的数组，顺序为变化事件发生的顺序</p>
<table>
<thead>
<tr>
<th>属 性</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>target</td>
<td>被修改影响的目标节点</td>
</tr>
<tr>
<td>type</td>
<td>字符串，表示变化的类型：”attributes”、”characterData”或”childList”</td>
</tr>
<tr>
<td>oldValue</td>
<td>如果在 MutationObserverInit 对象中启用（ attributeOldValue 或 characterData OldValue为 true）， “attributes”或”characterData”的变化事件 会设置这个属性为被替代的值”childList”类型的变化始终将这个属性设置为 null</td>
</tr>
<tr>
<td>attributeName</td>
<td>对于”attributes”类型的变化，这里保存被修改属性的名字其他变化事件会将这个属性设置为 null</td>
</tr>
<tr>
<td>attributeNamespace</td>
<td>对于使用了命名空间的”attributes”类型的变化， 这里保存被修改属性的名字其他变化事件会将这个属性设置为 null</td>
</tr>
<tr>
<td>addedNodes</td>
<td>对于”childList”类型的变化，返回包含变化中添加节点的 NodeList 默认为空 NodeList</td>
</tr>
<tr>
<td>removedNodes</td>
<td>对于”childList”类型的变化，返回包含变化中删除节点的 NodeList 默认为空 NodeList</td>
</tr>
<tr>
<td>previousSibling</td>
<td>对于”childList”类型的变化，返回变化节点的前一个同胞 Node 默认为空 NodeLis</td>
</tr>
<tr>
<td>nextSibling</td>
<td>对于”childList”类型的变化，返回变化节点的前一个同胞 Node 默认为空 NodeLis</td>
</tr>
</tbody></table>
<p>传给回调函数的第二个参数是观察变化的 MutationObserver 的实例，演示如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords, mutationObserver</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords,</span><br><span class="line">mutationObserver)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="comment">// [MutationRecord], MutationObserver</span></span><br></pre></td></tr></table></figure>

<p><strong>disconnect()方法</strong></p>
<p>默认情况下，只要被观察的元素不被垃圾回收，MutationObserver 的回调就会响应 DOM 变化事件，从而被执行。要提前终止执行回调，可以调用 disconnect()方法。下面的例子演示了同步调用disconnect()之后，不仅会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">observer.<span class="title function_">disconnect</span>(); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="comment">//（没有日志输出）</span></span><br></pre></td></tr></table></figure>

<p>要想让已经加入任务队列的回调执行，可以使用 setTimeout()让已经入列的回调执行完毕再调用disconnect()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> observer.<span class="title function_">disconnect</span>(); </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>复用 MutationObserver</strong></p>
<p>多次调用 observe()方法，可以复用一个 MutationObserver 对象观察多个不同的目标节点。此时，MutationRecord 的 target 属性可以标识发生变化事件的目标节点。</p>
<p>验证方法就是disconnect()方法是一个“一刀切”的方案，调用它会停止观察所有目标：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> </span><br><span class="line">x.<span class="property">target</span>))); </span><br><span class="line"><span class="comment">// 向页面主体添加两个子节点</span></span><br><span class="line"><span class="keyword">let</span> childA = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>), </span><br><span class="line"> childB = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(childA); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(childB); </span><br><span class="line"><span class="comment">// 观察两个子节点</span></span><br><span class="line">observer.<span class="title function_">observe</span>(childA, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line">observer.<span class="title function_">observe</span>(childB, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line">observer.<span class="title function_">disconnect</span>(); </span><br><span class="line"><span class="comment">// 修改两个子节点的属性</span></span><br><span class="line">childA.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">childB.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// （没有日志输出）</span></span><br></pre></td></tr></table></figure>

<p><strong>重用 MutationObserver</strong></p>
<p>调用 disconnect()并不会结束 MutationObserver 的生命。还可以重新使用这个观察者，再将它关联到新的目标节点。下面的示例在两个连续的异步块中先断开然后又恢复了观察者与元素的关联：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes </span></span><br><span class="line"><span class="string">changed&#x27;</span>)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 这行代码会触发变化事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">observer.<span class="title function_">disconnect</span>(); </span><br><span class="line"> <span class="comment">// 这行代码不会触发变化事件</span></span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line">&#125;, <span class="number">0</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="comment">// Reattach </span></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"> <span class="comment">// 这行代码会触发变化事件</span></span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>); </span><br><span class="line">&#125;, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed </span></span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br></pre></td></tr></table></figure>

<h5 id="14-3-2MutationObserverInit-与观察范围"><a href="#14-3-2MutationObserverInit-与观察范围" class="headerlink" title="14.3.2MutationObserverInit 与观察范围"></a><strong>14.3.2MutationObserverInit</strong> 与观察范围</h5><p>MutationObserverInit 对象用于控制对目标节点的观察范围。粗略地讲，观察者可以观察的事件包括属性变化、文本变化和子节点变化。</p>
<p>下表列出了 MutationObserverInit 对象的属性。</p>
<table>
<thead>
<tr>
<th>属 性</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>subtree</td>
<td>布尔值，表示除了目标节点，是否观察目标节点的子树（后代） 如果是 false，则只观察目标节点的变化；如果是 true，则观察目标节点及其整个子树 默认为 false</td>
</tr>
<tr>
<td>attributes</td>
<td>布尔值，表示是否观察目标节点的属性变化 默认为 false</td>
</tr>
<tr>
<td>attributeFilter</td>
<td>字符串数组，表示要观察哪些属性的变化 把这个值设置为 true 也会将 attributes 的值转换为 true 默认为观察所有属性</td>
</tr>
<tr>
<td>attributeOldValue</td>
<td>布尔值，表示 MutationRecord 是否记录变化之前的属性值 把这个值设置为 true 也会将 attributes 的值转换为 true 默认为 false</td>
</tr>
<tr>
<td>characterData</td>
<td>布尔值，表示修改字符数据是否触发变化事件 默认为 false</td>
</tr>
<tr>
<td>characterDataOldValue</td>
<td>布尔值，表示 MutationRecord 是否记录变化之前的字符数据 把这个值设置为 true 也会将 characterData 的值转换为 true 默认为 false</td>
</tr>
<tr>
<td>childList</td>
<td>布尔值，表示修改目标节点的子节点是否触发变化事件 默认为 false</td>
</tr>
</tbody></table>
<p>注意 在调用 observe()时，MutationObserverInit 对象中的 attribute、characterData和 childList 属性必须至少有一项为 true（无论是直接设置这几个属性，还是通过设置attributeOldValue 等属性间接导致它们的值转换为 true）。否则会抛出错误，因为没有任何变化事件可能触发回调。</p>
<p><strong>观察属性</strong></p>
<p>MutationObserver 可以观察节点属性的添加、移除和修改。要为属性变化注册回调，需要在MutationObserverInit 对象中将 attributes 属性设置为 true，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// 修改属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line"><span class="comment">// 移除属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeAttribute</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="comment">// 以上变化都被记录下来了</span></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br></pre></td></tr></table></figure>

<p>把 attributes 设置为 true 的默认行为是观察所有属性，但不会在 MutationRecord 对象中记录原来的属性值。如果想观察某个或某几个属性，可以使用 attributeFilter 属性来设置白名单，即一个属性名字符串数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributeFilter</span>: [<span class="string">&#x27;foo&#x27;</span>] &#125;); </span><br><span class="line"><span class="comment">// 添加白名单属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// 添加被排除的属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="comment">// 只有 foo 属性的变化被记录了</span></span><br><span class="line"><span class="comment">// [MutationRecord]</span></span><br></pre></td></tr></table></figure>

<p>如果想在变化记录中保存属性原来的值，可以将 attributeOldValue 属性设置为 true：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="property">oldValue</span>))); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributeOldValue</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>); </span><br><span class="line"><span class="comment">// 每次变化都保留了上一次的值</span></span><br><span class="line"><span class="comment">// [null, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>观察字符数据</strong></p>
<p>MutationObserver 可以观察文本节点（如 Text、Comment 或 ProcessingInstruction 节点）中字符的添加、删除和修改。要为字符数据注册回调，需要在 MutationObserverInit 对象中将characterData 属性设置为 true，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line"><span class="comment">// 创建要观察的文本节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>, &#123; <span class="attr">characterData</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 赋值为相同的字符串</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="comment">// 赋值为新字符串</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="comment">// 通过节点设置函数赋值</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"><span class="comment">// 以上变化都被记录下来了</span></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br></pre></td></tr></table></figure>

<p>将 characterData 属性设置为 true 的默认行为不会在 MutationRecord 对象中记录原来的字符数据。如果想在变化记录中保存原来的字符数据，可以将 characterDataOldValue 属性设置为 true：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="property">oldValue</span>))); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>, &#123; <span class="attr">characterDataOldValue</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"><span class="comment">// 每次变化都保留了上一次的值</span></span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>观察子节点</strong></p>
<p>MutationObserver 可以观察目标节点子节点的添加和移除。要观察子节点，需要在 MutationObserverInit 对象中将 childList 属性设置为 true。</p>
<p>下面的例子演示了添加子节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)); </span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// addedNodes: NodeList[div], </span></span><br><span class="line"><span class="comment">// attributeName: null, </span></span><br><span class="line"><span class="comment">// attributeNamespace: null, </span></span><br><span class="line"><span class="comment">// oldValue: null, </span></span><br><span class="line"><span class="comment">// nextSibling: null, </span></span><br><span class="line"><span class="comment">// previousSibling: null, </span></span><br><span class="line"><span class="comment">// removedNodes: NodeList[], </span></span><br><span class="line"><span class="comment">// target: body, </span></span><br><span class="line"><span class="comment">// type: &quot;childList&quot;, </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<p>对子节点重新排序（尽管调用一个方法即可实现）会报告两次变化事件，因为从技术上会涉及先移除和再添加：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line"><span class="comment">// 创建两个初始子节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 交换子节点顺序</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">lastChild</span>, <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>); </span><br><span class="line"><span class="comment">// 发生了两次变化：第一次是节点被移除，第二次是节点被添加</span></span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// addedNodes: NodeList[], </span></span><br><span class="line"><span class="comment">// attributeName: null, </span></span><br><span class="line"><span class="comment">// attributeNamespace: null, </span></span><br><span class="line"><span class="comment">// oldValue: null, </span></span><br><span class="line"><span class="comment">// nextSibling: null, </span></span><br><span class="line"><span class="comment">// previousSibling: div, </span></span><br><span class="line"><span class="comment">// removedNodes: NodeList[span], </span></span><br><span class="line"><span class="comment">// target: body, </span></span><br><span class="line"><span class="comment">// type: childList, </span></span><br><span class="line"><span class="comment">// &#125;, </span></span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// addedNodes: NodeList[span], </span></span><br><span class="line"><span class="comment">// attributeName: null, </span></span><br><span class="line"><span class="comment">// attributeNamespace: null, </span></span><br><span class="line"><span class="comment">// oldValue: null, </span></span><br><span class="line"><span class="comment">// nextSibling: div, </span></span><br><span class="line"><span class="comment">// previousSibling: null, </span></span><br><span class="line"><span class="comment">// removedNodes: NodeList[], </span></span><br><span class="line"><span class="comment">// target: body, </span></span><br><span class="line"><span class="comment">// type: &quot;childList&quot;, </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<p><strong>观察子树</strong></p>
<p>默认情况下，MutationObserver 将观察的范围限定为一个元素及其子节点的变化。可以把观察的范围扩展到这个元素的子树（所有后代节点），这需要在 MutationObserverInit 对象中将 subtree属性设置为 true。</p>
<p>下面的代码展示了观察元素及其后代节点属性的变化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line"><span class="comment">// 创建一个后代</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"><span class="comment">// 观察&lt;body&gt;元素及其子树</span></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 修改&lt;body&gt;元素的子树</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// 记录了子树变化的事件</span></span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// addedNodes: NodeList[], </span></span><br><span class="line"><span class="comment">// attributeName: &quot;foo&quot;, </span></span><br><span class="line"><span class="comment">// attributeNamespace: null, </span></span><br><span class="line"><span class="comment">// oldValue: null, </span></span><br><span class="line"><span class="comment">// nextSibling: null, </span></span><br><span class="line"><span class="comment">// previousSibling: null, </span></span><br><span class="line"><span class="comment">// removedNodes: NodeList[], </span></span><br><span class="line"><span class="comment">// target: div, </span></span><br><span class="line"><span class="comment">// type: &quot;attributes&quot;, </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<p>有意思的是，被观察子树中的节点被移出子树之后仍然能够触发变化事件。这意味着在子树中的节点离开该子树后，即使严格来讲该节点已经脱离了原来的子树，但它仍然会触发变化事件</p>
<p>下面的代码演示了这种情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line"><span class="keyword">let</span> subtreeRoot = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>), </span><br><span class="line"> subtreeLeaf = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>); </span><br><span class="line"><span class="comment">// 创建包含两层的子树</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(subtreeRoot); </span><br><span class="line">subtreeRoot.<span class="title function_">appendChild</span>(subtreeLeaf); </span><br><span class="line"><span class="comment">// 观察子树</span></span><br><span class="line">observer.<span class="title function_">observe</span>(subtreeRoot, &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 把节点转移到其他子树</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(subtreeLeaf, subtreeRoot); </span><br><span class="line">subtreeLeaf.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// 移出的节点仍然触发变化事件</span></span><br><span class="line"><span class="comment">// [MutationRecord]</span></span><br></pre></td></tr></table></figure>

<h5 id="14-3-3异步回调与记录队列"><a href="#14-3-3异步回调与记录队列" class="headerlink" title="14.3.3异步回调与记录队列"></a>14.3.3异步回调与记录队列</h5><p>MutationObserver 接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。为了在大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在 MutationRecord实例中，然后添加到记录队列。这个队列对每个 MutationObserver 实例都是唯一的，是所有 DOM变化事件的有序列表。</p>
<p><strong>记录队列</strong></p>
<p>每次 MutationRecord 被添加到 MutationObserver 的记录队列时，仅当之前没有已排期的微任务回调时（队列中微任务长度为 0），才会将观察者注册的回调（在初始化 MutationObserver 时传入）作为微任务调度到任务队列上。这样可以保证记录队列的内容不会被回调处理两次。</p>
<p><strong>takeRecords()方法</strong></p>
<p>调用 MutationObserver 实例的 takeRecords()方法可以清空记录队列，取出并返回其中的所有 MutationRecord 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(observer.<span class="title function_">takeRecords</span>()); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(observer.<span class="title function_">takeRecords</span>()); </span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord] </span></span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>这在希望断开与观察目标的联系，但又希望处理由于调用 disconnect()而被抛弃的记录队列中的MutationRecord 实例时比较有用。</p>
<h5 id="14-3-4性能、内存与垃圾回收"><a href="#14-3-4性能、内存与垃圾回收" class="headerlink" title="14.3.4性能、内存与垃圾回收"></a>14.3.4性能、内存与垃圾回收</h5><p>DOM Level 2 规范中描述的 MutationEvent 定义了一组会在各种 DOM 变化时触发的事件。由于浏览器事件的实现机制，这个接口出现了严重的性能问题。因此，DOM Level 3 规定废弃了这些事件。MutationObserver 接口就是为替代这些事件而设计的更实用、性能更好的方案。</p>
<p>将变化回调委托给微任务来执行可以保证事件同步触发，同时避免随之而来的混乱。为 MutationObserver 而实现的记录队列，可以保证即使变化事件被爆发式地触发，也不会显著地拖慢浏览器。</p>
<p><strong>MutationObserver 的引用</strong></p>
<p>MutationObserver 实例与目标节点之间的引用关系是非对称的。MutationObserver 拥有对要观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点。</p>
<p>然而，目标节点却拥有对 MutationObserver 的强引用。如果目标节点从 DOM 中被移除，随后被垃圾回收，则关联的 MutationObserver 也会被垃圾回收。</p>
<p><strong>MutationRecord 的引用</strong></p>
<p>记录队列中的每个 MutationRecord 实例至少包含对已有 DOM 节点的一个引用。如果变化是childList 类型，则会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个 MutationRecord，然后让它们超出作用域并被垃圾回收</p>
<p>有时候可能需要保存某个观察者的完整变化记录。保存这些 MutationRecord 实例，也就会保存它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快地释放内存，建议从每个 MutationRecord中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃 MutationRecord。</p>
<h3 id="15：DOM-扩展"><a href="#15：DOM-扩展" class="headerlink" title="15：DOM 扩展"></a>15：DOM 扩展</h3><h4 id="15-1Selectors-API"><a href="#15-1Selectors-API" class="headerlink" title="15.1Selectors API"></a>15.1Selectors API</h4><h5 id="15-1-1querySelector"><a href="#15-1-1querySelector" class="headerlink" title="15.1.1querySelector()"></a>15.1.1<strong>querySelector()</strong></h5><p>querySelector()方法接收 CSS 选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配项则返回 null。下面是一些例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得&lt;body&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> body = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;body&quot;</span>); </span><br><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的元素</span></span><br><span class="line"><span class="keyword">let</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#myDiv&quot;</span>);</span><br><span class="line"><span class="comment">// 取得类名为&quot;selected&quot;的第一个元素</span></span><br><span class="line"><span class="keyword">let</span> selected = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.selected&quot;</span>); </span><br><span class="line"><span class="comment">// 取得类名为&quot;button&quot;的图片</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;img.button&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在 Document 上使用 querySelector()方法时，会从文档元素开始搜索；在 Element 上使用querySelector()方法时，则只会从当前元素的后代中查询。</p>
<h5 id="15-1-2querySelectorAll"><a href="#15-1-2querySelectorAll" class="headerlink" title="15.1.2querySelectorAll()"></a>15.1.2<strong>querySelectorAll()</strong></h5><p>querySelectorAll()方法跟 querySelector()一样，也接收一个用于查询的参数，但它会返回所有匹配的节点，而不止一个。这个方法返回的是一个 NodeList 的静态实例。</p>
<p>再强调一次，querySelectorAll()返回的 NodeList 实例一个属性和方法都不缺，但它是一个静态的“快照”，而非“实时”的查询。这样的底层实现避免了使用 NodeList 对象可能造成的性能问题。</p>
<p>用法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的&lt;div&gt;元素中的所有&lt;em&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> ems = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>).<span class="title function_">querySelectorAll</span>(<span class="string">&quot;em&quot;</span>); </span><br><span class="line"><span class="comment">// 取得所有类名中包含&quot;selected&quot;的元素</span></span><br><span class="line"><span class="keyword">let</span> selecteds = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.selected&quot;</span>); </span><br><span class="line"><span class="comment">// 取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> strongs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p strong&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>返回的 NodeList 对象可以通过 for-of 循环、item()方法或中括号语法取得个别元素。</p>
<h5 id="15-1-3matches"><a href="#15-1-3matches" class="headerlink" title="15.1.3matches()"></a><strong>15.1.3matches()</strong></h5><p>matches()方法（在规范草案中称为 matchesSelector()）接收一个 CSS 选择符参数，如果元素匹配则该选择符返回 true，否则返回 false。</p>
<p>使用场景:</p>
<p>使用这个方法可以方便地检测某个元素会不会被 querySelector()或 querySelectorAll()方法返回。</p>
<p>所有主流浏览器都支持 matches()。Edge、Chrome、Firefox、Safari 和 Opera 完全支持，IE9~11及一些移动浏览器支持带前缀的方法。</p>
<h4 id="15-2元素遍历"><a href="#15-2元素遍历" class="headerlink" title="15.2元素遍历"></a>15.2元素遍历</h4><p>IE9 之前的版本不会把元素间的空格当成空白节点，而其他浏览器则会。这样就导致了 childNodes和 firstChild 等属性上的差异。为了弥补这个差异，同时不影响 DOM 规范，W3C 通过新的 Element Traversal 规范定义了一组新属性。</p>
<p>Element Traversal API 为 DOM 元素添加了 5 个属性：</p>
<ul>
<li>childElementCount，返回子元素数量（不包含文本节点和注释）；</li>
<li>firstElementChild，指向第一个 Element 类型的子元素（Element 版 firstChild）；</li>
<li>lastElementChild，指向最后一个 Element 类型的子元素（Element 版 lastChild）；</li>
<li>previousElementSibling ，指向前一个 Element 类型的同胞元素（ Element 版previousSibling）；</li>
<li>nextElementSibling，指向后一个 Element 类型的同胞元素（Element 版 nextSibling）。</li>
</ul>
<p>在支持的浏览器中，所有 DOM 元素都会有这些属性，为遍历 DOM 元素提供便利。这样开发者就不用担心空白文本节点的问题了。</p>
<p>举个例子，过去要以跨浏览器方式遍历特定元素的所有子元素，代码大致是这样写的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parentElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;parent&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> currentChildNode = parentElement.<span class="property">firstChild</span>; </span><br><span class="line"><span class="comment">// 没有子元素，firstChild 返回 null，跳过循环</span></span><br><span class="line"><span class="keyword">while</span> (currentChildNode) &#123; </span><br><span class="line"> <span class="keyword">if</span> (currentChildNode.<span class="property">nodeType</span> === <span class="number">1</span>) &#123; </span><br><span class="line"> <span class="comment">// 如果有元素节点，则做相应处理</span></span><br><span class="line"> <span class="title function_">processChild</span>(currentChildNode); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (currentChildNode === parentElement.<span class="property">lastChild</span>) &#123; </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> currentChildNode = currentChildNode.<span class="property">nextSibling</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Element Traversal 属性之后，以上代码可以简化如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parentElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;parent&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> currentChildElement = parentElement.<span class="property">firstElementChild</span>;</span><br><span class="line"><span class="comment">// 没有子元素，firstElementChild 返回 null，跳过循环</span></span><br><span class="line"><span class="keyword">while</span> (currentChildElement) &#123; </span><br><span class="line"> <span class="comment">// 这就是元素节点，做相应处理</span></span><br><span class="line"> <span class="title function_">processChild</span>(currentChildElement); </span><br><span class="line"> <span class="keyword">if</span> (currentChildElement === parentElement.<span class="property">lastElementChild</span>) &#123; </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> currentChildElement = currentChildElement.<span class="property">nextElementSibling</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IE9 及以上版本，以及所有现代浏览器都支持 Element Traversal 属性。</p>
<h4 id="15-3HTML5"><a href="#15-3HTML5" class="headerlink" title="15.3HTML5"></a>15.3HTML5</h4><h5 id="15-3-1CSS-类扩展"><a href="#15-3-1CSS-类扩展" class="headerlink" title="15.3.1CSS 类扩展"></a>15.3.1CSS 类扩展</h5><h6 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName()"></a><strong>getElementsByClassName()</strong></h6><p>getElementsByClassName()是 HTML5 新增的最受欢迎的一个方法，暴露在 document 对象和所有 HTML 元素上。这个方法脱胎于基于原有 DOM 特性实现该功能的 JavaScript 库，提供了性能高好的原生实现。</p>
<p>getElementsByClassName()方法接收一个参数，即包含一个或多个类名的字符串，返回类名中包含相应类的元素的 NodeList。如果提供了多个类名，则顺序无关紧要。</p>
<p>下面是几个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得所有类名中包含&quot;username&quot;和&quot;current&quot;元素</span></span><br><span class="line"><span class="comment">// 这两个类名的顺序无关紧要</span></span><br><span class="line"><span class="keyword">let</span> allCurrentUsernames = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;username current&quot;</span>); </span><br><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的元素子树中所有包含&quot;selected&quot;类的元素</span></span><br><span class="line"><span class="keyword">let</span> selected = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>).<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;selected&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>IE9 及以上版本，以及所有现代浏览器都支持 getElementsByClassName()方法。</p>
<p><strong>classList 属性</strong></p>
<p>className 是一个字符串，所以每次操作之后都需要重新设置这个值才能生效，即使只改动了部分字符串也一样.</p>
<p>以下面的 HTML代码为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;bd user disabled&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这个元素有 3 个类名。要想删除其中一个，就得先把 className 拆开，删除不想要的那个，再把包含剩余类的字符串设置回去。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要删除&quot;user&quot;类</span></span><br><span class="line"><span class="keyword">let</span> targetClass = <span class="string">&quot;user&quot;</span>; </span><br><span class="line"><span class="comment">// 把类名拆成数组</span></span><br><span class="line"><span class="keyword">let</span> classNames = div.<span class="property">className</span>.<span class="title function_">split</span>(<span class="regexp">/\s+/</span>); </span><br><span class="line"><span class="comment">// 找到要删除类名的索引</span></span><br><span class="line"><span class="keyword">let</span> idx = classNames.<span class="title function_">indexOf</span>(targetClass); </span><br><span class="line"><span class="comment">// 如果有则删除</span></span><br><span class="line"><span class="keyword">if</span> (idx &gt; -<span class="number">1</span>) &#123; </span><br><span class="line"> classNames.<span class="title function_">splice</span>(i,<span class="number">1</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 重新设置类名</span></span><br><span class="line">div.<span class="property">className</span> = classNames.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这就是从元素的类名中删除”user”类要写的代码。替换类名和检测类名也要涉及同样的算法。添加类名只涉及字符串拼接，但必须先检查一下以确保不会重复添加相同的类名。很多 JavaScript库为这些操作实现了便利方法。</p>
<p>HTML5 通过给所有元素增加 classList 属性为这些操作提供了更简单也更安全的实现方式。</p>
<p>classList 是一个新的集合类型 DOMTokenList 的实例。与其他 DOM 集合类型一样，DOMTokenList也有 length 属性表示自己包含多少项，也可以通过 item()或中括号取得个别的元素。</p>
<p>此外，DOMTokenList 还增加了以下方法。</p>
<ul>
<li> add(<em>value</em>)，向类名列表中添加指定的字符串值 value。如果这个值已经存在，则什么也不做。</li>
<li> contains(<em>value</em>)，返回布尔值，表示给定的 value 是否存在。</li>
<li> remove(<em>value</em>)，从类名列表中删除指定的字符串值 value。</li>
<li> toggle(<em>value</em>)，如果类名列表中已经存在指定的 value，则删除；如果不存在，则添加。</li>
</ul>
<p>这样以来，前面的例子中那么多行代码就可以简化成下面的一行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这行代码可以在不影响其他类名的情况下完成删除。其他方法同样极大地简化了操作类名的复杂性，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除&quot;disabled&quot;类</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;disabled&quot;</span>); </span><br><span class="line"><span class="comment">// 添加&quot;current&quot;类</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;current&quot;</span>);</span><br><span class="line"><span class="comment">// 切换&quot;user&quot;类</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&quot;user&quot;</span>); </span><br><span class="line"><span class="comment">// 检测类名</span></span><br><span class="line"><span class="keyword">if</span> (div.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&quot;bd&quot;</span>) &amp;&amp; !div.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&quot;disabled&quot;</span>))&#123; </span><br><span class="line"> <span class="comment">// 执行操作</span></span><br><span class="line">) </span><br><span class="line"><span class="comment">// 迭代类名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">class</span> <span class="title class_">of</span> div.<span class="property">classList</span>)&#123; </span><br><span class="line"> <span class="title function_">doStuff</span>(<span class="keyword">class</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加了 classList 属性之后，除非是完全删除或完全重写元素的 class 属性，否则 className属性就用不到了。IE10 及以上版本（部分）和其他主流浏览器（完全）实现了 classList 属性。</p>
<h5 id="15-3-2焦点管理"><a href="#15-3-2焦点管理" class="headerlink" title="15.3.2焦点管理"></a>15.3.2焦点管理</h5><p>HTML5 增加了辅助 DOM 焦点管理的功能。首先是 document.activeElement，始终包含当前拥有焦点的 DOM 元素。页面加载时，可以通过用户输入（按 Tab 键或代码中使用 focus()方法）让某个元素自动获得焦点。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myButton&quot;</span>); </span><br><span class="line">button.<span class="title function_">focus</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">activeElement</span> === button); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，document.activeElement 在页面刚加载完之后会设置为 document.body。而在页面完全加载之前，document.activeElement 的值为 null。</p>
<p>其次是 document.hasFocus()方法，该方法返回布尔值，表示文档是否拥有焦点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myButton&quot;</span>); </span><br><span class="line">button.<span class="title function_">focus</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">hasFocus</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>第一个方法可以用来查询文档，确定哪个元素拥有焦点，第二个方法可以查询文档是否获得了焦点，而这对于保证 Web 应用程序的无障碍使用是非常重要的。无障碍 Web 应用程序的一个重要方面就是焦点管理，而能够确定哪个元素当前拥有焦点（相比于之前的猜测）是一个很大的进步。</p>
<h5 id="15-3-3HTMLDocument-扩展"><a href="#15-3-3HTMLDocument-扩展" class="headerlink" title="15.3.3HTMLDocument 扩展"></a><strong>15.3.3HTMLDocument</strong> 扩展</h5><h6 id="readyState-属性"><a href="#readyState-属性" class="headerlink" title="readyState 属性"></a><strong>readyState 属性</strong></h6><p>readyState 是 IE4 最早添加到 document 对象上的属性，后来其他浏览器也都依葫芦画瓢地支持这个属性。最终，HTML5 将这个属性写进了标准。document.readyState 属性有两个可能的值：</p>
<ul>
<li> loading，表示文档正在加载；</li>
<li> complete，表示文档加载完成。</li>
</ul>
<p>实际开发中，最好是把 document.readState 当成一个指示器，以判断文档是否加载完毕。在这个属性得到广泛支持以前，通常要依赖 onload 事件处理程序设置一个标记，表示文档加载完了。这个属性的基本用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> == <span class="string">&quot;complete&quot;</span>)&#123; </span><br><span class="line"> <span class="comment">// 执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="compatMode-属性"><a href="#compatMode-属性" class="headerlink" title="compatMode 属性"></a><strong>compatMode 属性</strong></h6><p>作用：检测页面渲染模式</p>
<p>标准模式下 document.compatMode 的值是”CSS1Compat”，而在混杂模式下，document.compatMode 的值是”BackCompat”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">compatMode</span> == <span class="string">&quot;CSS1Compat&quot;</span>)&#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Standards mode&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Quirks mode&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HTML5 最终也把 compatMode 属性的实现标准化了。</p>
<h6 id="head-属性"><a href="#head-属性" class="headerlink" title="head 属性"></a><strong>head 属性</strong></h6><p>作为对 document.body（指向文档的元素）的补充，HTML5 增加了 document.head 属性，指向文档的元素。可以像下面这样直接取得元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="property">head</span>;</span><br></pre></td></tr></table></figure>

<h5 id="15-3-4字符集属性"><a href="#15-3-4字符集属性" class="headerlink" title="15.3.4字符集属性"></a>15.3.4字符集属性</h5><p>HTML5 增加了几个与文档字符集有关的新属性。其中，characterSet 属性表示文档实际使用的字符集，也可以用来指定新字符集。这个属性的默认值是”UTF-16”，但可以通过元素或响应头，以及新增的 characterSeet 属性来修改。下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">characterSet</span>); <span class="comment">// &quot;UTF-16&quot; </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">characterSet</span> = <span class="string">&quot;UTF-8&quot;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="15-3-5自定义数据属性"><a href="#15-3-5自定义数据属性" class="headerlink" title="15.3.5自定义数据属性"></a>15.3.5自定义数据属性</h5><p>HTML5 允许给元素指定非标准的属性，但要使用前缀 data-以便告诉浏览器，这些属性既不包含与渲染有关的信息，也不包含元素的语义信息。除了前缀，自定义属性对命名是没有限制的，data-后面跟什么都可以。下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;myDiv&quot;</span> data-appId=<span class="string">&quot;12345&quot;</span> data-myname=<span class="string">&quot;Nicholas&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>定义了自定义数据属性后，可以通过元素的 dataset 属性来访问。dataset 属性是一个DOMStringMap 的实例，包含一组键&#x2F;值对映射。元素的每个 data-name 属性在 dataset 中都可以通过 data-后面的字符串作为键来访问（例如，属性 data-myname、data-myName 可以通过 myname 访问，但要注意 data-my-name、data-My-Name 要通过 myName 来访问）。下面是一个使用自定义数据属性的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本例中使用的方法仅用于示范</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line"><span class="comment">// 取得自定义数据属性的值</span></span><br><span class="line"><span class="keyword">let</span> appId = div.<span class="property">dataset</span>.<span class="property">appId</span>; </span><br><span class="line"><span class="keyword">let</span> myName = div.<span class="property">dataset</span>.<span class="property">myname</span>; </span><br><span class="line"><span class="comment">// 设置自定义数据属性的值</span></span><br><span class="line">div.<span class="property">dataset</span>.<span class="property">appId</span> = <span class="number">23456</span>; </span><br><span class="line">div.<span class="property">dataset</span>.<span class="property">myname</span> = <span class="string">&quot;Michael&quot;</span>; </span><br><span class="line"><span class="comment">// 有&quot;myname&quot;吗？</span></span><br><span class="line"><span class="keyword">if</span> (div.<span class="property">dataset</span>.<span class="property">myname</span>)&#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;div.dataset.myname&#125;</span>`</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义数据属性非常适合需要给元素附加某些数据的场景，比如链接追踪和在聚合应用程序中标识页面的不同部分。另外，单页应用程序框架也非常多地使用了自定义数据属性。</p>
<h5 id="15-3-6插入标记"><a href="#15-3-6插入标记" class="headerlink" title="15.3.6插入标记"></a>15.3.6插入标记</h5><h6 id="innerHTML-属性"><a href="#innerHTML-属性" class="headerlink" title="innerHTML 属性"></a><strong>innerHTML 属性</strong></h6><p>在读取 innerHTML 属性时，会返回元素所有后代的 HTML 字符串，包括元素、注释和文本节点。而在写入 innerHTML 时，则会根据提供的字符串值以新的 DOM 子树替代元素中原来包含的所有节点。比如下面的 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于这里的元素而言，其 innerHTML 属性会返回以下字符串：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实际返回的文本内容会因浏览器而不同。IE 和 Opera 会把所有元素标签转换为大写，而 Safari、Chrome 和 Firefox 则会按照文档源代码的格式返回，包含空格和缩进。因此不要指望不同浏览器的innerHTML 会返回完全一样的值。</p>
<p>在写入模式下，赋给 innerHTML 属性的值会被解析为 DOM 子树，并替代元素之前的所有节点。因为所赋的值默认为 HTML，所以其中的所有标签都会以浏览器处理 HTML 的方式转换为元素,如果赋值中不包含任何 HTML 标签，则直接生成一个文本节点，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">innerHTML</span> = <span class="string">&quot;Hello world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>因为浏览器会解析设置的值，所以给 innerHTML 设置包含 HTML 的字符串时，结果会大不一样。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">innerHTML</span> = <span class="string">&quot;Hello &amp; welcome, &lt;b&gt;\&quot;reader\&quot;!&lt;/b&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这个操作的结果相当于：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>Hello <span class="symbol">&amp;amp;</span> welcome, <span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="symbol">&amp;quot;</span>reader<span class="symbol">&amp;quot;</span>!<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意 设置 innerHTML 会导致浏览器将 HTML 字符串解析为相应的 DOM 树。这意味着设置 innerHTML 属性后马上再读出来会得到不同的字符串。这是因为返回的字符串是将原始字符串对应的 DOM 子树序列化之后的结果。</p>
<p><strong>旧 IE 中的 innerHTML</strong></p>
<p>在所有现代浏览器中，通过 innerHTML 插入的 </p>
<p>而在 IE8 及之前的版本中，只要这样插入的 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 行不通</span></span><br><span class="line">div.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;script defer&gt;console.log(&#x27;hi&#x27;);&lt;\/script&gt;&quot;</span>;</span><br><span class="line">javascript</span><br><span class="line">复制代码<span class="comment">// 以下都可行</span></span><br><span class="line">div.<span class="property">innerHTML</span> = <span class="string">&quot;_&lt;script defer&gt;console.log(&#x27;hi&#x27;);&lt;\/script&gt;&quot;</span>; </span><br><span class="line">div.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;script defer&gt;console.log(&#x27;hi&#x27;);&lt;\/script&gt;&quot;</span>; </span><br><span class="line">div.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;input type=\&quot;hidden\&quot;&gt;&lt;script defer&gt;console.log(&#x27;hi&#x27;);&lt;\/script&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>作为了解，IE自己玩吧！</p>
<h6 id="outerHTML-属性"><a href="#outerHTML-属性" class="headerlink" title="outerHTML 属性"></a><strong>outerHTML 属性</strong></h6><p>与innerHTML用法基本一致，只是会替换原来的容器元素；</p>
<h6 id="insertAdjacentHTML-与-insertAdjacentText"><a href="#insertAdjacentHTML-与-insertAdjacentText" class="headerlink" title="insertAdjacentHTML()与 insertAdjacentText()"></a><strong>insertAdjacentHTML()与 insertAdjacentText()</strong></h6><p>关于插入标签的最后两个新增方法是 insertAdjacentHTML()和 insertAdjacentText()。这两个方法最早源自 IE</p>
<p>它们都接收两个参数：要插入标记的位置和要插入的 HTML 或文本。</p>
<ul>
<li> “beforebegin”，插入当前元素前面，作为前一个同胞节点；</li>
<li> “afterbegin”，插入当前元素内部，作为新的子节点或放在第一个子节点前面；</li>
<li> “beforeend”，插入当前元素内部，作为新的子节点或放在最后一个子节点后面；</li>
<li> “afterend”，插入当前元素后面，作为下一个同胞节点。</li>
</ul>
<p>第二个参数会作为 HTML 字符串解析（与 innerHTML 和outerHTML 相同）或者作为纯文本解析（与 innerText 和 outerText 相同）。如果是 HTML，则会在解析出错时抛出错误。</p>
<p>下面展示了基本用法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为前一个同胞节点插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforebegin&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); </span><br><span class="line">element.<span class="title function_">insertAdjacentText</span>(<span class="string">&quot;beforebegin&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line"><span class="comment">// 作为第一个子节点插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;afterbegin&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); </span><br><span class="line">element.<span class="title function_">insertAdjacentText</span>(<span class="string">&quot;afterbegin&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line"><span class="comment">// 作为最后一个子节点插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); </span><br><span class="line">element.<span class="title function_">insertAdjacentText</span>(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line"><span class="comment">// 作为下一个同胞节点插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;afterend&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); element. </span><br><span class="line"><span class="title function_">insertAdjacentText</span>(<span class="string">&quot;afterend&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="内存与性能问题"><a href="#内存与性能问题" class="headerlink" title="内存与性能问题"></a><strong>内存与性能问题</strong></h6><p>使用本节介绍的方法替换子节点可能在浏览器（特别是 IE）中导致内存问题。比如，如果被移除的子树元素中之前有关联的事件处理程序或其他 JavaScript 对象（作为元素的属性），那它们之间的绑定关系会滞留在内存中。如果这种替换操作频繁发生，页面的内存占用就会持续攀升。在使用 innerHTML、outerHTML 和 insertAdjacentHTML()之前，最好手动删除要被替换的元素上关联的事件处理程序和JavaScript 对象。</p>
<p>使用这些属性当然有其方便之处，特别是 innerHTML。一般来讲，插入大量的新 HTML 使用innerHTML 比使用多次 DOM 操作创建节点再插入来得更便捷。这是因为 HTML 解析器会解析设置给innerHTML（或 outerHTML）的值。解析器在浏览器中是底层代码（通常是 C++代码），比 JavaScript快得多。</p>
<p>不过，HTML 解析器的构建与解构也不是没有代价，因此最好限制使用 innerHTML 和outerHTML 的次数。</p>
<p>比如，下面的代码使用 innerHTML 创建了一些列表项：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values)&#123; </span><br><span class="line"> ul.<span class="property">innerHTML</span> += <span class="string">&#x27;&lt;li&gt;$&#123;value&#125;&lt;/li&gt;&#x27;</span>; <span class="comment">// 别这样做！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码效率低，因为每次迭代都要设置一次 innerHTML。不仅如此，每次循环还要先读取innerHTML，也就是说循环一次要访问两次 innerHTML。为此，最好通过循环先构建一个独立的字符串，最后再一次性把生成的字符串赋值给 innerHTML，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> itemsHtml = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values)&#123; </span><br><span class="line">	itemsHtml += <span class="string">&#x27;&lt;li&gt;$&#123;value&#125;&lt;/li&gt;&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line">ul.<span class="property">innerHTML</span> = itemsHtml;</span><br></pre></td></tr></table></figure>

<p>这样修改之后效率就高多了，因为只有对 innerHTML 的一次赋值。当</p>
<p><strong>跨站点脚本</strong></p>
<p>尽管 innerHTML 不会执行自己创建的 </p>
<p>如果页面中要使用用户提供的信息，则不建议使用 innerHTML。与使用 innerHTML 获得的方便相比，防止 XSS 攻击更让人头疼。最好对它们进行转义。</p>
<h5 id="15-3-7scrollIntoView"><a href="#15-3-7scrollIntoView" class="headerlink" title="15.3.7scrollIntoView()"></a><strong>15.3.7scrollIntoView()</strong></h5><p>DOM 规范中没有涉及的一个问题是如何滚动页面中的某个区域。为填充这方面的缺失，不同浏览器实现了不同的控制滚动的方式。在所有这些专有方法中，HTML5 选择了标准化 scrollIntoView()。</p>
<p>scrollIntoView()方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口。这个方法的参数如下：</p>
<p>alignToTop 是一个布尔值。</p>
<ul>
<li>true：窗口滚动后元素的顶部与视口顶部对齐。</li>
<li>false：窗口滚动后元素的底部与视口底部对齐。</li>
</ul>
<p>scrollIntoViewOptions 是一个选项对象。</p>
<ul>
<li>behavior：定义过渡动画，可取的值为”smooth”和”auto”，默认为”auto”。</li>
<li>block：定义垂直方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默认为 “start”。</li>
<li>inline：定义水平方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默认为 “nearest”。</li>
</ul>
<p>不传参数等同于 alignToTop 为 true。</p>
<p>经常应用菜单栏的滚动操作，聊天消息的回到底部等场景；</p>
<p>看下面一个例子:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow-y</span>: scroll;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>:<span class="number">1px</span> solid pink;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">line-height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>112<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>113<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>114<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>151<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>114541<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>11451<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>141411<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>11453411<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>112811<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1124231<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>11446491<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1233<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>111231231<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>11145645<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> li = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;ul&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> height = <span class="built_in">parseInt</span>(<span class="title function_">getComputedStyle</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;ul&quot;</span>)).<span class="property">height</span>);</span></span><br><span class="line"><span class="language-javascript">        li.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            item.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">style</span> = <span class="string">&quot;color:red&quot;</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 用自带的方法  但是如果父亲和爷爷都有滚动条的话，都会动</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="title function_">scrollIntoView</span>(&#123;<span class="attr">behavior</span>: <span class="string">&#x27;smooth&#x27;</span>, <span class="attr">block</span>: <span class="string">&#x27;center&#x27;</span>&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                    1. scrollTop 小于0是不动的</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                    2. li 的offsetTop 是以dom 中的为准，是不会变的，通过滚动到试图中间只是视觉上变了，所以如果scollTop 等于  的offsetTop 就到最上面了</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                    3. top-height/2 所以说当到了中间的时候才会动</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                 */</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// let top = this.offsetTop;</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// console.log(&#x27;top&#x27;, top);</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// ul.scrollTop = top - height / 2;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;)()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="15-4专有扩展"><a href="#15-4专有扩展" class="headerlink" title="15.4专有扩展"></a>15.4专有扩展</h4><h5 id="15-4-1children-属性"><a href="#15-4-1children-属性" class="headerlink" title="15.4.1children 属性"></a><strong>15.4.1children</strong> 属性</h5><p>出现的原因：IE9 之前的版本与其他浏览器在处理空白文本节点上的差异导致了 children 属性的出现。</p>
<p>children 属性是一个 HTMLCollection，只包含元素的 Element 类型的子节点。如果元素的子节点类型全部是元素类型，那 children 和 childNodes 中包含的节点应该是一样的。</p>
<h5 id="15-4-2contains-方法"><a href="#15-4-2contains-方法" class="headerlink" title="15.4.2contains()方法"></a>15.4.2contains()方法</h5><p>DOM 编程中经常需要确定一个元素是不是另一个元素的后代。IE 首先引入了 contains()方法，让开发者可以在不遍历 DOM 的情况下获取这个信息。contains()方法应该在要搜索的祖先元素上调用，参数是待确定的目标节点。</p>
<p>如果目标节点是被搜索节点的后代，contains()返回 true，否则返回 false。</p>
<p>下面看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">contains</span>(<span class="variable language_">document</span>.<span class="property">body</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>另外，使用 DOM Level 3 的 compareDocumentPosition()方法也可以确定节点间的关系。这个方法会返回表示两个节点关系的位掩码。</p>
<p>要模仿 contains()方法，就需要用到掩码 16（0x10）。compareDocumentPosition()方法的结果可以通过按位与来确定参考节点是否包含传入的节点，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">compareDocumentPosition</span>(<span class="variable language_">document</span>.<span class="property">body</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!(result &amp; <span class="number">0x10</span>));</span><br></pre></td></tr></table></figure>

<p>以上代码执行后 result 的值为 20（或 0x14，其中 0x4 表示“随后”，加上 0x10“被包含”）。对result 和 0x10 应用按位与会返回非零值，而两个叹号将这个值转换成对应的布尔值。</p>
<p>IE9 及之后的版本，以及所有现代浏览器都支持 contains()和 compareDocumentPosition()方法。</p>
<h5 id="15-4-3插入标记"><a href="#15-4-3插入标记" class="headerlink" title="15.4.3插入标记"></a>15.4.3插入标记</h5><p>HTML5 将 IE 发明的 innerHTML 和 outerHTML 纳入了标准，但还有两个属性没有入选。这两个剩下的属性是 innerText 和 outerText。</p>
<h6 id="innerText-属性"><a href="#innerText-属性" class="headerlink" title="innerText 属性"></a><strong>innerText 属性</strong></h6><p>innerText 属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。在用于读取值时，innerText 会按照深度优先的顺序将子树中所有文本节点的值拼接起来。</p>
<p>来看下面的 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span> </span><br><span class="line"> 	<span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对这个例子中的而言，innerText 属性会返回以下字符串：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is a paragraph with a list following it. </span><br><span class="line">Item 1 </span><br><span class="line">Item 2 </span><br><span class="line">Item 3</span><br></pre></td></tr></table></figure>

<p>注意不同浏览器对待空格的方式不同，因此格式化之后的字符串可能包含也可能不包含原始 HTML代码中的缩进。</p>
<p>设置 innerText 会移除元素之前所有的后代节点，完全改变 DOM 子树。此外，设置 innerText也会编码出现在字符串中的 HTML 语法字符（小于号、大于号、引号及和号）。下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">innerText</span> = <span class="string">&quot;Hello &amp; welcome, &lt;b&gt;\&quot;reader\&quot;!&lt;/b&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>执行之后的结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;content&quot;</span>&gt;<span class="title class_">Hello</span> &amp;amp; welcome, &amp;lt;b&amp;gt;&amp;quot;reader&amp;quot;!&amp;lt;<span class="regexp">/b&amp;gt;&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<p>因为设置 innerText 只能在容器元素中生成一个文本节点，所以为了保证一定是文本节点，就必须进行 HTML 编码。innerText 属性可以用于去除 HTML 标签。</p>
<p>一个很有意思的题目，去除所有的html标签，可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">innerText</span> = div.<span class="property">innerText</span>;</span><br></pre></td></tr></table></figure>

<p>执行以上代码后，容器元素的内容只会包含原先的文本内容。</p>
<h6 id="outerText-属性"><a href="#outerText-属性" class="headerlink" title="outerText 属性"></a><strong>outerText 属性</strong></h6><p>outerText 与 innerText 是类似的，只不过作用范围包含调用它的节点。</p>
<p>outerText 是一个非标准的属性，而且也没有被标准化的前景。因此，不推荐依赖这个属性实现重要的操作。除 Firefox 之外所有主流浏览器都支持 outerText。</p>
<h5 id="15-4-4滚动"><a href="#15-4-4滚动" class="headerlink" title="15.4.4滚动"></a>15.4.4滚动</h5><p>如前所述，滚动是 HTML5 之前 DOM 标准没有涉及的领域。虽然 HTML5 把 scrollIntoView()标准化了，但不同浏览器中仍然有其他专有方法。比如，scrollIntoViewIfNeeded()作 为HTMLElement 类型的扩展可以在所有元素上调用。</p>
<p>考虑到 scrollIntoView()是唯一一个所有浏览器都支持的方法，所以只用它就可以了。</p>
<h3 id="16：DOM2-和-DOM3"><a href="#16：DOM2-和-DOM3" class="headerlink" title="16：DOM2 和 DOM3"></a>16：DOM2 和 DOM3</h3><h4 id="16-1DOM-的演进"><a href="#16-1DOM-的演进" class="headerlink" title="16.1DOM 的演进"></a>16.1DOM 的演进</h4><p>DOM2 和 DOM3 Core 模块的目标是扩展 DOM API，满足 XML 的所有需求并提供更好的错误处理和特性检测。</p>
<h5 id="16-1-1XML-命名空间（了解）"><a href="#16-1-1XML-命名空间（了解）" class="headerlink" title="16.1.1XML 命名空间（了解）"></a>16.1.1XML 命名空间（了解）</h5><p>XML 命名空间可以实现在一个格式规范的文档中混用不同的 XML 语言，而不必担心元素命名冲突。严格来讲，XML 命名空间在 XHTML 中才支持，HTML 并不支持。作为了解</p>
<h5 id="16-2其他变化"><a href="#16-2其他变化" class="headerlink" title="16.2其他变化"></a>16.2其他变化</h5><p><strong>DocumentType 的变化</strong></p>
<p>DocumentType 新增了 3 个属性：publicId、systemId 和 internalSubset。</p>
<p>publicId、systemId 属性表示文档类型声明中有效但无法使用 DOM1 API 访问的数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-// W3C// DTD XHTML 1.0 Strict// EN&quot;</span> </span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;</span> </span></span><br><span class="line"><span class="meta">[<span class="meta">&lt;!ELEMENT <span class="keyword">name</span> (<span class="keyword">#PCDATA</span>)&gt;</span>] &gt;</span></span><br></pre></td></tr></table></figure>

<p>publicId 是”-&#x2F;&#x2F; W3C&#x2F;&#x2F; DTD XHTML 1.0 Strict&#x2F;&#x2F; EN”，</p>
<p>systemId 是”<a href="https://link.juejin.cn/?target=http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd%22%E3%80%82">www.w3.org/TR/xhtml1/D…</a></p>
<p>internalSubset 是”<!ELEMENT name (#PCDATA)>“。</p>
<p>通常在网页中很少需要访问这些信息。</p>
<p><strong>Document 的变化</strong></p>
<p>importNode()这个方法的目的是从其他文档获取一个节点并导入到新文档，以便将其插入新文档。</p>
<p>importNode()方法跟 cloneNode()方法类似，同样接收两个参数：要复制的节点和表示是否同时复制子树的布尔值，返回结果是适合在当前文档中使用的新节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newNode = <span class="variable language_">document</span>.<span class="title function_">importNode</span>(oldNode, <span class="literal">true</span>); <span class="comment">// 导入节点及所有后代</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(newNode);</span><br></pre></td></tr></table></figure>

<p>这个方法在 HTML 中使用得并不多，在 XML 文档中的使用会更多一些</p>
<p>DOM2 View 给 Document 类型增加了新属性 defaultView，是一个指向拥有当前文档的窗口（或窗格）的指针。IE8 及更早版本支持等价的 parentWindow 属性，Opera 也支持这个属性。因此要确定拥有文档的窗口，可以使用以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parentWindow = <span class="variable language_">document</span>.<span class="property">defaultView</span> || <span class="variable language_">document</span>.<span class="property">parentWindow</span>;</span><br></pre></td></tr></table></figure>

<p>DOM2 Core 还针对 document.implementation 对象增加了两个新方法：createDocumentType()和 createDocument()。</p>
<p>前者用于创建 DocumentType 类型的新节点，接收 3 个参数：文档类型名称、publicId 和 systemId。</p>
<p>比如，以下代码可以创建一个新的 HTML 4.01 严格型文档：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let doctype = document.implementation.createDocumentType(&quot;html&quot;, </span><br><span class="line"> &quot;-// W3C// DTD HTML 4.01// EN&quot;, </span><br><span class="line"> &quot;http://www.w3.org/TR/html4/strict.dtd&quot;);</span><br></pre></td></tr></table></figure>

<p>createDocument()接 收 3 个参数：文档元素的namespaceURI、文档元素的标签名和文档类型。</p>
<p>比如，下列代码可以创建一个空的 XML 文档：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doc = <span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">createDocument</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>要创建一个 XHTML 文档，可以使用以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doctype = <span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">createDocumentType</span>(<span class="string">&quot;html&quot;</span>, </span><br><span class="line"> <span class="string">&quot;-// W3C// DTD XHTML 1.0 Strict// EN&quot;</span>, </span><br><span class="line"> <span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> doc = <span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">createDocument</span>(<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>, </span><br><span class="line"> <span class="string">&quot;html&quot;</span>, doctype);</span><br></pre></td></tr></table></figure>

<p>这里使用了适当的命名空间和文档类型创建一个新 XHTML文档。这个文档只有一个文档元素，其他一切都需要另行添加。</p>
<p>DOM2 HTML 模块也为 document.implamentation 对象添加了 createHTMLDocument()方法。使用这个方法可以创建一个完整的 HTML 文档，包含、、和元素。这个方法只接收一个参数，即新创建文档的标题（放到元素中），返回一个新的 HTML 文档。 </p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> htmldoc = <span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">createHTMLDocument</span>(<span class="string">&quot;New Doc&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(htmldoc.<span class="property">title</span>); <span class="comment">// &quot;New Doc&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> htmldoc.<span class="property">body</span>); <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>createHTMLDocument()方法创建的对象是 HTMLDocument 类型的实例，因此包括该类型所有相关的方法和属性，包括 title 和 body 属性。</p>
<p><strong>Node 的变化</strong></p>
<p>DOM3 新增了两个用于比较节点的方法：isSameNode()和 isEqualNode()。</p>
<p>这两个方法都接收一个节点参数，如果这个节点与参考节点相同或相等，则返回 true。节点相同，意味着引用同一个对象；节点相等，意味着节点类型相同，拥有相等的属性（nodeName、nodeValue 等），而且 attributes和 childNodes 也相等（即同样的位置包含相等的值）。</p>
<p>来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">div1.<span class="title function_">setAttribute</span>(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;box&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> div2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">div2.<span class="title function_">setAttribute</span>(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;box&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(div1.<span class="title function_">isSameNode</span>(div1)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(div1.<span class="title function_">isEqualNode</span>(div2)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(div1.<span class="title function_">isSameNode</span>(div2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这里创建了包含相同属性的两个元素。这两个元素相等，但不相同。</p>
<p>DOM3 也增加了给 DOM 节点附加额外数据的方法。setUserData()方法接收 3 个参数：键、值、处理函数，用于给节点追加数据。</p>
<p>可以像下面这样把数据添加到一个节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setUserData</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>然后，可以通过相同的键再取得这个信息，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">getUserData</span>(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>setUserData()的处理函数会在包含数据的节点被复制、删除、重命名或导入其他文档的时候执行，可以在这时候决定如何处理用户数据。处理函数接收 5 个参数：表示操作类型的数值（1 代表复制，2 代表导入，3 代表删除，4 代表重命名）、数据的键、数据的值、源节点和目标节点。删除节点时，源节点为 null；除复制外，目标节点都为 null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">div.<span class="title function_">setUserData</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>, <span class="keyword">function</span>(<span class="params">operation, key, value, src, dest</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (operation == <span class="number">1</span>) &#123; </span><br><span class="line"> dest.<span class="title function_">setUserData</span>(key, value, <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;); &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">let</span> newDiv = div.<span class="title function_">cloneNode</span>(<span class="literal">true</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newDiv.<span class="title function_">getUserData</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里先创建了一个元素，然后给它添加了一些数据，包含用户的名字。在使用 cloneNode()复制这个元素时，就会调用处理函数，从而将同样的数据再附加给复制得到的目标节点。然后，在副本节点上调用 getUserData()能够取得附加到源节点上的数据。</p>
<p><strong>内嵌窗格的变化</strong></p>
<p>DOM2 HTML 给 HTMLIFrameElement（即，内嵌窗格）类型新增了一个属性，叫contentDocument。这个属性包含代表子内嵌窗格中内容的 document 对象的指针。下面的例子展示了如何使用这个属性： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myIframe&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> iframeDoc = iframe.<span class="property">contentDocument</span>;</span><br></pre></td></tr></table></figure>

<p>contentDocument 属性是 Document 的实例，拥有所有文档属性和方法，因此可以像使用其他HTML 文档一样使用它。还有一个属性 contentWindow，返回相应窗格的 window 对象，这个对象上有一个 document 属性。所有现代浏览器都支持 contentDocument 和 contentWindow 属性。</p>
<h4 id="16-2样式"><a href="#16-2样式" class="headerlink" title="16.2样式"></a>16.2样式</h4><p>HTML 中的样式有 3 种定义方式：外部样式表（通过元素）、文档样式表（使用元素）和元素特定样式（使用 style 属性）。 </p>
<h5 id="16-2-1存取元素样式"><a href="#16-2-1存取元素样式" class="headerlink" title="16.2.1存取元素样式"></a>16.2.1存取元素样式</h5><p>任何支持 style 属性的 HTML 元素在 JavaScript 中都会有一个对应的 style 属性。这个 style 属性是 CSSStyleDeclaration 类型的实例，其中包含通过 HTML style 属性为元素设置的所有样式信息，但不包含通过层叠机制从文档样式和外部样式中继承来的样式。</p>
<p>因为 CSS 属性名使用连字符表示法,所以在 JavaScript 中这些属性必须转换为驼峰大小写形式。</p>
<table>
<thead>
<tr>
<th>CSS 属性</th>
<th>JavaScript 属性</th>
</tr>
</thead>
<tbody><tr>
<td>background-image</td>
<td>style.backgroundImage</td>
</tr>
<tr>
<td>color</td>
<td>style.color</td>
</tr>
<tr>
<td>display</td>
<td>style.display</td>
</tr>
<tr>
<td>font-family</td>
<td>style.fontFamily</td>
</tr>
</tbody></table>
<p>大多数属性名会这样直接转换过来。但有一个 CSS 属性名不能直接转换，它就是 float。因为float 是 JavaScript 的保留字，所以不能用作属性名。DOM2 Style 规定它在 style 对象中对应的属性应该是 cssFloat。</p>
<p>任何时候，只要获得了有效 DOM 元素的引用，就可以通过 JavaScript 来设置样式。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line"><span class="comment">// 设置背景颜色</span></span><br><span class="line">myDiv.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;red&quot;</span>; </span><br><span class="line"><span class="comment">// 修改大小</span></span><br><span class="line">myDiv.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&quot;100px&quot;</span>; </span><br><span class="line">myDiv.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&quot;200px&quot;</span>; </span><br><span class="line"><span class="comment">// 设置边框</span></span><br><span class="line">myDiv.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&quot;1px solid black&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>像这样修改样式时，元素的外观会自动更新。</p>
<p>通过 style 属性设置的值也可以通过 style 对象获取。比如下面的 HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: blue; width: 10px; height: 25px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个元素 style 属性的值可以像这样通过代码获取：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDiv.<span class="property">style</span>.<span class="property">backgroundColor</span>); <span class="comment">// &quot;blue&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDiv.<span class="property">style</span>.<span class="property">width</span>); <span class="comment">// &quot;10px&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDiv.<span class="property">style</span>.<span class="property">height</span>); <span class="comment">// &quot;25px&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果元素上没有 style 属性，则 style 对象包含所有可能的 CSS 属性的空值。</p>
<p><strong>DOM 样式属性和方法</strong></p>
<ul>
<li>cssText，包含 style 属性中的 CSS 代码。</li>
<li>length，应用给元素的 CSS 属性数量。</li>
<li>parentRule，表示 CSS 信息的 CSSRule 对象（下一节会讨论 CSSRule 类型）。</li>
<li>getPropertyCSSValue(<em>propertyName</em>)，返回包含 CSS 属性 <em>propertyName</em> 值的 CSSValue对象（已废弃）。</li>
<li>getPropertyPriority(<em>propertyName</em>)，如果 CSS 属性 <em>propertyName</em> 使用了!important则返回”important”，否则返回空字符串。</li>
<li>getPropertyValue(<em>propertyName</em>)，返回属性 <em>propertyName</em> 的字符串值。</li>
<li>item(<em>index</em>)，返回索引为 <em>index</em> 的 CSS 属性名。</li>
<li>removeProperty(<em>propertyName</em>)，从样式中删除 CSS 属性 <em>propertyName</em>。</li>
<li>setProperty(<em>propertyName, value, priority</em>)，设置 CSS 属性 <em>propertyName</em> 的值为<em>value</em>，<em>priority</em> 是”important”或空字符串。</li>
</ul>
<p>如果一个元素通过 style 属性设置了边框，而赋给 cssText属性的值不包含边框，则元素的边框会消失。下面的例子演示了 cssText 的使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myDiv.<span class="property">style</span>.<span class="property">cssText</span> = <span class="string">&quot;width: 25px; height: 100px; background-color: green&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDiv.<span class="property">style</span>.<span class="property">cssText</span>);</span><br></pre></td></tr></table></figure>

<p>设置 cssText 是一次性修改元素多个样式最快捷的方式，因为所有变化会同时生效。</p>
<p><strong>计算样式</strong></p>
<p>style 对象中包含支持 style 属性的元素为这个属性设置的样式信息，但不包含从其他样式表层叠继承的同样影响该元素的样式信息。</p>
<p>DOM2 Style在document.defaultView上增加了getComputedStyle()方法。这个方法接收两个参数：要取得计算样式的元素和伪元素字符串；</p>
<p>如果不需要查询伪元素，则第二个参数可以传 null。getComputedStyle()方法返回一个 CSSStyleDeclaration对象（与 style 属性的类型一样），包含元素的计算样式。</p>
<p>假设有如下 HTML 页面：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Computed Styles Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"> </span></span><br><span class="line"><span class="language-css">     <span class="selector-id">#myDiv</span> &#123; </span></span><br><span class="line"><span class="language-css">     <span class="attribute">background-color</span>: blue; </span></span><br><span class="line"><span class="language-css">     <span class="attribute">width</span>: <span class="number">100px</span>; </span></span><br><span class="line"><span class="language-css">     <span class="attribute">height</span>: <span class="number">200px</span>; </span></span><br><span class="line"><span class="language-css">     &#125; </span></span><br><span class="line"><span class="language-css"> 	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span> 	</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"> 	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: red; border: 1px solid black&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面的代码从这个元素获取了计算样式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> computedStyle = <span class="variable language_">document</span>.<span class="property">defaultView</span>.<span class="title function_">getComputedStyle</span>(myDiv, <span class="literal">null</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(computedStyle.<span class="property">backgroundColor</span>); <span class="comment">// &quot;red&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(computedStyle.<span class="property">width</span>); <span class="comment">// &quot;100px&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(computedStyle.<span class="property">height</span>); <span class="comment">// &quot;200px&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(computedStyle.<span class="property">border</span>); <span class="comment">// &quot;1px solid black&quot;（在某些浏览器中）</span></span><br></pre></td></tr></table></figure>

<p>在取得这个元素的计算样式时，得到的背景颜色是”red”，宽度为”100px”，高度为”200px”。背景颜色不是”blue”，因为元素样式覆盖了它。</p>
<p>border 属性不一定返回样式表中实际的 border 规则（某些浏览器会）。这种不一致性是因浏览器解释简写样式的方式造成的，比如 border 实际上会设置一组别的属性。在设置 border 时，实际上设置的是 4 条边的线条宽度、颜色和样式（border-left-width、border-top-color、border-bottom-style 等）。因此，即使 computedStyle.border 在所有浏览器中都不会返回值computedStyle.borderLeftWidth 也一定会返回值</p>
<p>注意 浏览器虽然会返回样式值，但返回值的格式不一定相同。比如，Firefox 和 Safari 会把所有颜色值转换为 RGB 格式（如红色会变成 rgb(255,0,0)），而 Opera 把所有颜色转换为十六进制表示法（如红色会变成#ff0000）。因此在使用 getComputedStyle()时一定要多测试几个浏览器。</p>
<p>关于计算样式要记住一点，在所有浏览器中计算样式都是只读的，不能修改 getComputedStyle()方法返回的对象。而且，计算样式还包含浏览器内部样式表中的信息。因此有默认值的 CSS 属性会出现在计算样式里。</p>
<h5 id="16-2-2操作样式表"><a href="#16-2-2操作样式表" class="headerlink" title="16.2.2操作样式表"></a>16.2.2操作样式表</h5><p>CSSStyleSheet 类型表示 CSS 样式表，包括使用元素和通过元素定义的样式表。注意，这两个元素本身分别是 HTMLLinkElement 和 HTMLStyleElement。CSSStyleSheet 类型是一个通用样式表类型，可以表示以任何方式在 HTML 中定义的样式表。另外，元素特定的类型允许修改HTML 属性，而 CSSStyleSheet 类型的实例则是一个只读对象（只有一个属性例外）。 </p>
<p>CSSStyleSheet类型继承StyleSheet，后者可用作非CSS样式表的基类。以下是CSSStyleSheet从 StyleSheet 继承的属性</p>
<ul>
<li>disabled，布尔值，表示样式表是否被禁用了（这个属性是可读写的，因此将它设置为 true会禁用样式表）。</li>
<li>href，如果是使用包含的样式表，则返回样式表的 URL，否则返回 null。</li>
<li>media，样式表支持的媒体类型集合，这个集合有一个 length 属性和一个 item()方法，跟所有 DOM 集合一样。同样跟所有 DOM 集合一样，也可以使用中括号访问集合中特定的项。如果样式表可用于所有媒体，则返回空列表。</li>
<li>ownerNode，指向拥有当前样式表的节点，在 HTML 中要么是元素要么是元素（在 XML 中可以是处理指令）。如果当前样式表是通过@import 被包含在另一个样式表中，则这个属性值为 null。 </li>
<li>parentStyleSheet，如果当前样式表是通过@import 被包含在另一个样式表中，则这个属性指向导入它的样式表。</li>
<li>title，ownerNode 的 title 属性。</li>
<li>type，字符串，表示样式表的类型。对 CSS 样式表来说，就是”text&#x2F;css”。</li>
<li>cssRules，当前样式表包含的样式规则的集合。</li>
<li>ownerRule，如果样式表是使用@import 导入的，则指向导入规则；否则为 null。</li>
<li>deleteRule(<em>index</em>)，在指定位置删除 cssRules 中的规则。</li>
<li>insertRule(<em>rule</em>, <em>index</em>)，在指定位置向 cssRules 中插入规则。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sheet = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="variable language_">document</span>.<span class="property">styleSheets</span>.<span class="property">length</span>; i &lt; len; i++) &#123; </span><br><span class="line"> sheet = <span class="variable language_">document</span>.<span class="property">styleSheets</span>[i]; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(sheet.<span class="property">href</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码输出了文档中每个样式表的 href 属性（元素没有这个属性） </p>
<p><strong>CSS 规则</strong></p>
<p>CSSRule 类型表示样式表中的一条规则。这个类型也是一个通用基类，很多类型都继承它,但其中最常用的是表示样式信息的 CSSStyleRule,以下是 CSSStyleRule 对象上可用的属性。</p>
<ul>
<li>cssText，返回整条规则的文本。这里的文本可能与样式表中实际的文本不一样，因为浏览器内部处理样式表的方式也不一样。Safari 始终会把所有字母都转换为小写。</li>
<li>parentRule，如果这条规则被其他规则（如@media）包含，则指向包含规则，否则就是 null</li>
<li>parentStyleSheet，包含当前规则的样式表。</li>
<li>selectorText，返回规则的选择符文本。这里的文本可能与样式表中实际的文本不一样，因为浏览器内部处理样式表的方式也不一样。这个属性在 Firefox、Safari、Chrome 和 IE 中是只读的，在 Opera 中是可以修改的。</li>
<li>style，返回 CSSStyleDeclaration 对象，可以设置和获取当前规则中的样式。</li>
<li>type，数值常量，表示规则类型。对于样式规则，它始终为 1。</li>
</ul>
<p>在这些属性中，使用最多的是 cssText、selectorText 和 style。</p>
<p>多数情况下，使用 style 属性就可以实现操作样式规则的任务了。这个对象可以像每个元素上的style 对象一样，用来读取或修改规则的样式。比如下面这个 CSS 规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.box</span> &#123; </span><br><span class="line">   <span class="attribute">background-color</span>: blue; </span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100px</span>; </span><br><span class="line">   <span class="attribute">height</span>: <span class="number">200px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设这条规则位于页面中的第一个样式表中，而且是该样式表中唯一一条 CSS 规则，则下列代码可以获取它的所有信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sheet = <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">let</span> rules = sheet.<span class="property">cssRules</span> || sheet.<span class="property">rules</span>; <span class="comment">// 取得规则集合</span></span><br><span class="line"><span class="keyword">let</span> rule = rules[<span class="number">0</span>]; <span class="comment">// 取得第一条规则</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">selectorText</span>); <span class="comment">// &quot;div.box&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">style</span>.<span class="property">cssText</span>); <span class="comment">// 完整的 CSS 代码</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">style</span>.<span class="property">backgroundColor</span>); <span class="comment">// &quot;blue&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">style</span>.<span class="property">width</span>); <span class="comment">// &quot;100px&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">style</span>.<span class="property">height</span>); <span class="comment">// &quot;200px&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用这些接口，可以像确定元素 style 对象中包含的样式一样，确定一条样式规则的样式信息。与元素的场景一样，也可以修改规则中的样式，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sheet = <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">let</span> rules = sheet.<span class="property">cssRules</span> || sheet.<span class="property">rules</span>; <span class="comment">// 取得规则集合</span></span><br><span class="line"><span class="keyword">let</span> rule = rules[<span class="number">0</span>]; <span class="comment">// 取得第一条规则</span></span><br><span class="line">rule.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;red&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，这样修改规则会影响到页面上所有应用了该规则的元素。如果页面上有两个</p>
<p>元素有”box”类，则这两个元素都会受到这个修改的影响。</p>
<p><strong>创建规则</strong></p>
<p>DOM 规定，可以使用 insertRule()方法向样式表中添加新规则。这个方法接收两个参数：规则的文本和表示插入位置的索引值。下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sheet.<span class="title function_">insertRule</span>(<span class="string">&quot;body &#123; background-color: silver &#125;&quot;</span>, <span class="number">0</span>); <span class="comment">// 使用 DOM 方法</span></span><br></pre></td></tr></table></figure>

<p>这个例子插入了一条改变文档背景颜色的规则。这条规则是作为样式表的第一条规则（位置 0）插入的，顺序对规则层叠是很重要的。</p>
<p><strong>删除规则</strong></p>
<p>支持从样式表中删除规则的 DOM 方法是 deleteRule()，它接收一个参数：要删除规则的索引。要删除样式表中的第一条规则，可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sheet.<span class="title function_">deleteRule</span>(<span class="number">0</span>); <span class="comment">// 使用 DOM 方法</span></span><br></pre></td></tr></table></figure>

<p>与添加规则一样，删除规则并不是 Web 开发中常见的做法。考虑到可能影响 CSS 层叠的效果，删除规则时要慎重。</p>
<h5 id="16-2-3元素尺寸"><a href="#16-2-3元素尺寸" class="headerlink" title="16.2.3元素尺寸"></a>16.2.3元素尺寸</h5><h6 id="偏移尺寸"><a href="#偏移尺寸" class="headerlink" title="偏移尺寸"></a><strong>偏移尺寸</strong></h6><p>offsetHeight，元素在垂直方向上占用的像素尺寸，包括它的高度、水平滚动条高度（如果可见）和上、下边框的高度。</p>
<p>offsetLeft，元素左边框外侧距离包含元素左边框内侧的像素数。</p>
<p>offsetTop，元素上边框外侧距离包含元素上边框内侧的像素数。</p>
<p>offsetWidth，元素在水平方向上占用的像素尺寸，包括它的宽度、垂直滚动条宽度（如果可见）和左、右边框的宽度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getElementLeft</span>(<span class="params">element</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> actualLeft = element.<span class="property">offsetLeft</span>; </span><br><span class="line"> <span class="keyword">let</span> current = element.<span class="property">offsetParent</span>; </span><br><span class="line"> <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123; </span><br><span class="line"> actualLeft += current.<span class="property">offsetLeft</span>; </span><br><span class="line"> current = current.<span class="property">offsetParent</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> actualLeft; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getElementTop</span>(<span class="params">element</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> actualTop = element.<span class="property">offsetTop</span>; </span><br><span class="line"> <span class="keyword">let</span> current = element.<span class="property">offsetParent</span>; </span><br><span class="line"> <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123; </span><br><span class="line"> actualTop += current.<span class="property">offsetTop</span>; </span><br><span class="line"> current = current.<span class="property">offsetParent</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> actualTop; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数使用 offsetParent 在 DOM 树中逐级上溯，将每一级的偏移属性相加，最终得到元素的实际偏移量。</p>
<h6 id="客户端尺寸"><a href="#客户端尺寸" class="headerlink" title="客户端尺寸"></a><strong>客户端尺寸</strong></h6><p>元素的客户端尺寸（client dimensions）包含元素内容及其内边距所占用的空间。客户端尺寸只有两个相关属性：clientWidth 和 clientHeight。其中，clientWidth 是内容区宽度加左、右内边距宽度，clientHeight 是内容区高度加上、下内边距高度。</p>
<p>客户端尺寸实际上就是元素内部的空间，因此不包含滚动条占用的空间。这两个属性最常用于确定浏览器视口尺寸，即检测 document.documentElement 的 clientWidth 和 clientHeight。这两个属性表示视口（或元素）的尺寸。</p>
<p>注意:与偏移尺寸一样，客户端尺寸也是只读的，而且每次访问都会重新计算。</p>
<h6 id="滚动尺寸"><a href="#滚动尺寸" class="headerlink" title="滚动尺寸"></a><strong>滚动尺寸</strong></h6><p>最后一组尺寸是滚动尺寸（scroll dimensions），提供了元素内容滚动距离的信息。有些元素，比如无须任何代码就可以自动滚动，而其他元素则需要使用 CSS 的 overflow 属性令其滚动。滚动尺寸相关的属性有如下 4 个。</p>
<ul>
<li> scrollHeight，没有滚动条出现时，元素内容的总高度。</li>
<li> scrollLeft，内容区左侧隐藏的像素数，设置这个属性可以改变元素的滚动位置。</li>
<li> scrollTop，内容区顶部隐藏的像素数，设置这个属性可以改变元素的滚动位置。</li>
<li> scrollWidth，没有滚动条出现时，元素内容的总宽度。</li>
</ul>
<p>scrollWidth 和 scrollHeight 可以用来确定给定元素内容的实际尺寸。例如，元素是浏览器中滚动视口的元素。因此，document.documentElement.scrollHeight 就是整个页面垂直方向的总高度。</p>
<p>scrollWidth 和 scrollHeight 与 clientWidth 和 clientHeight 之间的关系在不需要滚动的文档上是分不清的。如果文档尺寸超过视口尺寸，则在所有主流浏览器中这两对属性都不相等，scrollWidth 和 scollHeight 等于文档内容的宽度，而 clientWidth 和 clientHeight 等于视口的大小。</p>
<p>scrollLeft 和 scrollTop 属性可以用于确定当前元素滚动的位置，或者用于设置它们的滚动位置。元素在未滚动时，这两个属性都等于 0。如果元素在垂直方向上滚动，则 scrollTop 会大于 0，表示元素顶部不可见区域的高度。如果元素在水平方向上滚动，则 scrollLeft 会大于 0，表示元素左侧不可见区域的宽度。因为这两个属性也是可写的，所以把它们都设置为 0 就可以重置元素的滚动位置</p>
<p>下面这个函数检测元素是不是位于顶部，如果不是则把它滚动回顶部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">scrollToTop</span>(<span class="params">element</span>) &#123; </span><br><span class="line">   <span class="keyword">if</span> (element.<span class="property">scrollTop</span> != <span class="number">0</span>) &#123; </span><br><span class="line">   		element.<span class="property">scrollTop</span> = <span class="number">0</span>; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数使用 scrollTop 获取并设置值。</p>
<p><strong>确定元素尺寸</strong></p>
<p>浏览器在每个元素上都暴露了 getBoundingClientRect()方法，返回一个 DOMRect 对象，包含6 个属性：left、top、right、bottom、height 和 width。这些属性给出了元素在页面中相对于视口的位置。</p>
<h4 id="16-3遍历"><a href="#16-3遍历" class="headerlink" title="16.3遍历"></a>16.3遍历</h4><p>DOM2 Traversal and Range 模块定义了两个类型用于辅助顺序遍历 DOM 结构。这两个类型—— NodeIterator 和 TreeWalker——从某个起点开始执行对 DOM 结构的深度优先遍历。</p>
<h5 id="16-3-1NodeIterator"><a href="#16-3-1NodeIterator" class="headerlink" title="16.3.1NodeIterator"></a>16.3.1NodeIterator</h5><p>NodeIterator 类型是两个类型中比较简单的，可以通过 document.createNodeIterator()方法创建其实例。这个方法接收以下 4 个参数。</p>
<ul>
<li> root，作为遍历根节点的节点。</li>
<li> whatToShow，数值代码，表示应该访问哪些节点。</li>
<li> filter，NodeFilter 对象或函数，表示是否接收或跳过特定节点。</li>
<li> entityReferenceExpansion，布尔值，表示是否扩展实体引用。这个参数在 HTML 文档中没有效果，因为实体引用永远不扩展。</li>
</ul>
<p>whatToShow 参数是一个位掩码，通过应用一个或多个过滤器来指定访问哪些节点。这个参数对应的常量是在 NodeFilter 类型中定义的。</p>
<ul>
<li> NodeFilter.SHOW_ALL，所有节点。</li>
<li> NodeFilter.SHOW_ELEMENT，元素节点。</li>
<li> NodeFilter.SHOW_ATTRIBUTE，属性节点。由于 DOM 的结构，因此实际上用不上。</li>
<li> NodeFilter.SHOW_TEXT，文本节点。</li>
<li> NodeFilter.SHOW_CDATA_SECTION，CData 区块节点。不是在 HTML 页面中使用的。</li>
<li> NodeFilter.SHOW_ENTITY_REFERENCE，实体引用节点。不是在 HTML 页面中使用的。</li>
<li> NodeFilter.SHOW_ENTITY，实体节点。不是在 HTML 页面中使用的。</li>
<li> NodeFilter.SHOW_PROCESSING_INSTRUCTION，处理指令节点。不是在 HTML 页面中使用的。</li>
<li> NodeFilter.SHOW_COMMENT，注释节点。</li>
<li> NodeFilter.SHOW_DOCUMENT，文档节点。</li>
<li> NodeFilter.SHOW_DOCUMENT_TYPE，文档类型节点。</li>
<li> NodeFilter.SHOW_DOCUMENT_FRAGMENT，文档片段节点。不是在 HTML 页面中使用的。</li>
<li> NodeFilter.SHOW_NOTATION，记号节点。不是在 HTML 页面中使用的。</li>
</ul>
<p>这些值除了 NodeFilter.SHOW_ALL 之外，都可以组合使用。比如，可以像下面这样使用按位或操作组合多个选项：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> whatToShow = <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span> | <span class="title class_">NodeFilter</span>.<span class="property">SHOW_TEXT</span>;</span><br></pre></td></tr></table></figure>

<p>createNodeIterator()方法的 filter 参数可以用来指定自定义 NodeFilter 对象，或者一个作为节点过滤器的函数。NodeFilter 对象只有一个方法 acceptNode()，如果给定节点应该访问就返回 NodeFilter.FILTER_ACCEPT，否则返回 NodeFilter.FILTER_SKIP。因为 NodeFilter 是一个抽象类型，所以不可能创建它的实例。只要创建一个包含 acceptNode()的对象，然后把它传给createNodeIterator()就可以了。</p>
<p>以下代码定义了只接收</p>
<p>元素的节点过滤器对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> filter = &#123; </span><br><span class="line"> <span class="title function_">acceptNode</span>(<span class="params">node</span>) &#123; </span><br><span class="line"> 	<span class="keyword">return</span> node.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;p&quot;</span> ?</span><br><span class="line">    <span class="title class_">NodeFilter</span>.<span class="property">FILTER_ACCEPT</span> : </span><br><span class="line">	 	<span class="title class_">NodeFilter</span>.<span class="property">FILTER_SKIP</span>; </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> iterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(root, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, </span><br><span class="line"> filter, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>filter 参数还可以是一个函数，与 acceptNode()的形式一样，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> filter = <span class="keyword">function</span>(<span class="params">node</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> node.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;p&quot;</span> ? </span><br><span class="line"> <span class="title class_">NodeFilter</span>.<span class="property">FILTER_ACCEPT</span> : </span><br><span class="line"> <span class="title class_">NodeFilter</span>.<span class="property">FILTER_SKIP</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> iterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(root, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, </span><br><span class="line"> filter, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>通常，JavaScript 会使用这种形式，因为更简单也更像普通 JavaScript 代码。如果不需要指定过滤器，则可以给这个参数传入 null。</p>
<p>要创建一个简单的遍历所有节点的 NodeIterator，可以使用以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(<span class="variable language_">document</span>, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ALL</span>, </span><br><span class="line"> <span class="literal">null</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>NodeIterator 的两个主要方法是 nextNode()和 previousNode()。nextNode()方法在 DOM子树中以深度优先方式进前一步，而 previousNode()则是在遍历中后退一步。创建 NodeIterator对象的时候，会有一个内部指针指向根节点，因此第一次调用 nextNode()返回的是根节点。当遍历到达 DOM 树最后一个节点时，nextNode()返回 null。previousNode()方法也是类似的。当遍历到达DOM 树最后一个节点时，调用 previousNode()返回遍历的根节点后，再次调用也会返回 null。</p>
<p>以下面的 HTML 片段为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设想要遍历</p>
<p>元素内部的所有元素，那么可以使用如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> iterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(div, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, </span><br><span class="line"> <span class="literal">null</span>, <span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> node = iterator.<span class="title function_">nextNode</span>(); </span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">tagName</span>); <span class="comment">// 输出标签名</span></span><br><span class="line"> node = iterator.<span class="title function_">nextNode</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中第一次调用 nextNode()返回</p>
<p>元素。因为 nextNode()在遍历到达 DOM 子树末尾时返回 null，所以这里通过 while 循环检测每次调用 nextNode()的返回值是不是 null。以上代码执行后会输出以下标签名：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">DIV</span> </span><br><span class="line"><span class="selector-tag">P</span> </span><br><span class="line"><span class="selector-tag">B</span> </span><br><span class="line"><span class="selector-tag">UL</span> </span><br><span class="line"><span class="selector-tag">LI</span> </span><br><span class="line"><span class="selector-tag">LI</span> </span><br><span class="line"><span class="selector-tag">LI</span></span><br></pre></td></tr></table></figure>

<p>如果只想遍历</p>
<p>元素，可以传入一个过滤器，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> filter = <span class="keyword">function</span>(<span class="params">node</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> node.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;li&quot;</span> ? </span><br><span class="line"> <span class="title class_">NodeFilter</span>.<span class="property">FILTER_ACCEPT</span> : </span><br><span class="line"> <span class="title class_">NodeFilter</span>.<span class="property">FILTER_SKIP</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> iterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(div, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, </span><br><span class="line"> filter, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> node = iterator.<span class="title function_">nextNode</span>(); </span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">tagName</span>); <span class="comment">// 输出标签名</span></span><br><span class="line"> node = iterator.<span class="title function_">nextNode</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，遍历只会输出元素的标签。</p>
<p>nextNode()和 previousNode()方法共同维护 NodeIterator 对 DOM 结构的内部指针，因此修改 DOM 结构也会体现在遍历中。</p>
<h5 id="16-3-2TreeWalker"><a href="#16-3-2TreeWalker" class="headerlink" title="16.3.2TreeWalker"></a>16.3.2TreeWalker</h5><p>TreeWalker 是 NodeIterator 的高级版。除了包含同样的 nextNode()、previousNode()方法，TreeWalker 还添加了如下在 DOM 结构中向不同方向遍历的方法。</p>
<ul>
<li> parentNode()，遍历到当前节点的父节点。</li>
<li> firstChild()，遍历到当前节点的第一个子节点。</li>
<li> lastChild()，遍历到当前节点的最后一个子节点。</li>
<li> nextSibling()，遍历到当前节点的下一个同胞节点。</li>
<li> previousSibling()，遍历到当前节点的上一个同胞节点。</li>
</ul>
<p>TreeWalker 对象要调用 document.createTreeWalker()方法来创建，这个方法接收与document.createNodeIterator()同样的参数：作为遍历起点的根节点、要查看的节点类型、节点过滤器和一个表示是否扩展实体引用的布尔值。因为两者很类似，所以 TreeWalker 通常可以取代NodeIterator，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> filter = <span class="keyword">function</span>(<span class="params">node</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> node.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;li&quot;</span> ? </span><br><span class="line"> <span class="title class_">NodeFilter</span>.<span class="property">FILTER_ACCEPT</span> : </span><br><span class="line"> <span class="title class_">NodeFilter</span>.<span class="property">FILTER_SKIP</span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> walker = <span class="variable language_">document</span>.<span class="title function_">createTreeWalker</span>(div, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, </span><br><span class="line"> filter, <span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> node = iterator.<span class="title function_">nextNode</span>(); </span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">tagName</span>); <span class="comment">// 输出标签名</span></span><br><span class="line"> node = iterator.<span class="title function_">nextNode</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的是，节点过滤器（filter）除了可以返回 NodeFilter.FILTER_ACCEPT 和 NodeFilter. FILTER_SKIP，还可以返回 NodeFilter.FILTER_REJECT。在使用 NodeIterator 时，NodeFilter. FILTER_SKIP 和 NodeFilter.FILTER_REJECT 是一样的。但在使用 TreeWalker 时，NodeFilter. FILTER_SKIP 表示跳过节点，访问子树中的下一个节点，而 NodeFilter.FILTER_REJECT 则表示跳过该节点以及该节点的整个子树。</p>
<p>例如，如果把前面示例中的过滤器函数改为返回 NodeFilter. FILTER_REJECT（而不是 NodeFilter.FILTER_SKIP），则会导致遍历立即返回，不会访问任何节点。这是因为第一个返回的元素是</p>
<p>，其中标签名不是”li”，因此过滤函数返回 NodeFilter.FILTER_ REJECT，表示要跳过整个子树。因为</p>
<p>本身就是遍历的根节点，所以遍历会就此结束。</p>
<p>当然，TreeWalker 真正的威力是可以在 DOM 结构中四处游走。如果不使用过滤器，单纯使用TreeWalker 的漫游能力同样可以在 DOM 树中访问元素，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> walker = <span class="variable language_">document</span>.<span class="title function_">createTreeWalker</span>(div, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, <span class="literal">null</span>, <span class="literal">false</span>); </span><br><span class="line">walker.<span class="title function_">firstChild</span>(); <span class="comment">// 前往&lt;p&gt; </span></span><br><span class="line">walker.<span class="title function_">nextSibling</span>(); <span class="comment">// 前往&lt;ul&gt; </span></span><br><span class="line"><span class="keyword">let</span> node = walker.<span class="title function_">firstChild</span>(); <span class="comment">// 前往第一个&lt;li&gt; </span></span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">tagName</span>); </span><br><span class="line"> node = walker.<span class="title function_">nextSibling</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们知道</p>
<p>元素在文档结构中的位置，所以可以直接定位过去。先使用 firstChild()前 往元素，再通过 nextSibling()前往元素，然后使用 firstChild()到达第一个元素。注意，此时的 TreeWalker 只返回元素（这是因为传给 createTreeWalker()的第二个参数）。最后就可以使用 nextSibling()访问每个元素，直到再也没有元素，此时方法返回 null。</p>
<p>TreeWalker 类型也有一个名为 currentNode 的属性，表示遍历过程中上一次返回的节点（无论使用的是哪个遍历方法）。可以通过修改这个属性来影响接下来遍历的起点，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = walker.<span class="title function_">nextNode</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(node === walker.<span class="property">currentNode</span>); <span class="comment">// true </span></span><br><span class="line">walker.<span class="property">currentNode</span> = <span class="variable language_">document</span>.<span class="property">body</span>; <span class="comment">// 修改起点</span></span><br></pre></td></tr></table></figure>

<p>相比于 NodeIterator，TreeWalker 类型为遍历 DOM 提供了更大的灵活性。</p>
<h4 id="16-4范围（了解）"><a href="#16-4范围（了解）" class="headerlink" title="16.4范围（了解）"></a>16.4范围（了解）</h4><h5 id="16-4-1DOM-范围"><a href="#16-4-1DOM-范围" class="headerlink" title="16.4.1DOM 范围"></a>16.4.1DOM 范围</h5><p>DOM2 在 Document 类型上定义了一个 createRange()方法，暴露在 document 对象上。使用这个方法可以创建一个 DOM 范围对象，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>();</span><br></pre></td></tr></table></figure>

<p>与节点类似，这个新创建的范围对象是与创建它的文档关联的，不能在其他文档中使用。然后可以使用这个范围在后台选择文档特定的部分。创建范围并指定它的位置之后，可以对范围的内容执行一些操作，从而实现对底层 DOM 树更精细的控制。</p>
<p>每个范围都是 Range 类型的实例，拥有相应的属性和方法。下面的属性提供了与范围在文档中位置相关的信息。</p>
<ul>
<li> startContainer，范围起点所在的节点（选区中第一个子节点的父节点）。</li>
<li> startOffset，范围起点在 startContainer 中的偏移量。如果 startContainer 是文本节点、注释节点或 CData 区块节点，则 startOffset 指范围起点之前跳过的字符数；否则，表示范围中第一个节点的索引。</li>
<li> endContainer，范围终点所在的节点（选区中最后一个子节点的父节点）。</li>
<li> endOffset，范围起点在 startContainer 中的偏移量（与 startOffset 中偏移量的含义相同）。</li>
<li> commonAncestorContainer，文档中以startContainer和endContainer为后代的最深的节点。</li>
</ul>
<p>这些属性会在范围被放到文档中特定位置时获得相应的值。</p>
<h5 id="16-4-2简单选择"><a href="#16-4-2简单选择" class="headerlink" title="16.4.2简单选择"></a>16.4.2简单选择</h5><p>通过范围选择文档中某个部分最简单的方式，就是使用 selectNode()或 selectNodeContents()方法。这两个方法都接收一个节点作为参数，并将该节点的信息添加到调用它的范围。selectNode()方法选择整个节点，包括其后代节点，而 selectNodeContents()只选择节点的后代。</p>
<p>假设有如下 HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以下 JavaScript 代码可以访问并创建相应的范围：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range1 = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(), </span><br><span class="line"> range2 = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(), </span><br><span class="line"> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>); </span><br><span class="line">range1.<span class="title function_">selectNode</span>(p1); </span><br><span class="line">range2.<span class="title function_">selectNodeContents</span>(p1);</span><br></pre></td></tr></table></figure>

<p>例子中的这两个范围包含文档的不同部分。range1 包含</p>
<p>元素及其所有后代，而 range2 包含<strong>元素、文本节点”Hello”和文本节点” world!”</strong></p>
<p>调用 selectNode()时，startContainer、endContainer 和 commonAncestorContainer 都等于传入节点的父节点。在这个例子中，这几个属性都等于 document.body。startOffset 属性等于传入节点在其父节点 childNodes 集合中的索引（在这个例子中，startOffset 等于 1，因为 DOM的合规实现把空格当成文本节点），而 endOffset 等于 startOffset 加 1（因为只选择了一个节点）。</p>
<p>在调用 selectNodeContents()时，startContainer、endContainer 和 commonAncestor Container 属性就是传入的节点，在这个例子中是</p>
<p>元素。startOffset 属性始终为 0，因为范围从传入节点的第一个子节点开始，而 endOffset 等于传入节点的子节点数量（node.child Nodes.length），在这个例子中等于 2。</p>
<p>在像上面这样选定节点或节点后代之后，还可以在范围上调用相应的方法，实现对范围中选区的更精细控制。</p>
<ul>
<li>setStartBefore(<em>refNode</em>)，把范围的起点设置到 <em>refNode</em> 之前，从而让 <em>refNode</em> 成为选区的第一个子节点。startContainer 属性被设置为 refNode.parentNode，而 startOffset属性被设置为 <em>refNode</em> 在其父节点 childNodes 集合中的索引。</li>
<li>setStartAfter(<em>refNode</em>)，把范围的起点设置到 <em>refNode</em> 之后，从而将 <em>refNode</em> 排除在选区之外，让其下一个同胞节点成为选区的第一个子节点。startContainer 属性被设置为refNode.parentNode，startOffset 属性被设置为 <em>refNode</em> 在其父节点 childNodes 集合中的索引加 1。</li>
<li>setEndBefore(<em>refNode</em>)，把范围的终点设置到 <em>refNode</em> 之前，从而将 <em>refNode</em> 排除在选区之外、让其上一个同胞节点成为选区的最后一个子节点。endContainer 属性被设置为 refNode. parentNode，endOffset 属性被设置为 <em>refNode</em> 在其父节点 childNodes 集合中的索引。</li>
<li>setEndAfter(<em>refNode</em>)，把范围的终点设置到 <em>refNode</em> 之后，从而让 <em>refNode</em> 成为选区的最后一个子节点。endContainer 属性被设置为 refNode.parentNode，endOffset 属性被设置为 <em>refNode</em> 在其父节点 childNodes 集合中的索引加 1。</li>
</ul>
<p>调用这些方法时，所有属性都会自动重新赋值。不过，为了实现复杂的选区，也可以直接修改这些属性的值。</p>
<h5 id="16-4-3复杂选择"><a href="#16-4-3复杂选择" class="headerlink" title="16.4.3复杂选择"></a>16.4.3复杂选择</h5><p>要创建复杂的范围，需要使用 setStart()和 setEnd()方法。这两个方法都接收两个参数：参照节点和偏移量。对 setStart()来说，参照节点会成为 startContainer，而偏移量会赋值给 startOffset。 对 setEnd()而言，参照节点会成为 endContainer，而偏移量会赋值给 endOffset。</p>
<p>使用这两个方法，可以模拟 selectNode()和 selectNodeContents()的行为。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range1 = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(), </span><br><span class="line"> range2 = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(), </span><br><span class="line"> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>), </span><br><span class="line"> p1Index = -<span class="number">1</span>, </span><br><span class="line"> i, </span><br><span class="line"> len; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = p1.<span class="property">parentNode</span>.<span class="property">childNodes</span>.<span class="property">length</span>; i &lt; len; i++) &#123; </span><br><span class="line"> <span class="keyword">if</span> (p1.<span class="property">parentNode</span>.<span class="property">childNodes</span>[i] === p1) &#123; </span><br><span class="line"> p1Index = i; </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">range1.<span class="title function_">setStart</span>(p1.<span class="property">parentNode</span>, p1Index); </span><br><span class="line">range1.<span class="title function_">setEnd</span>(p1.<span class="property">parentNode</span>, p1Index + <span class="number">1</span>); </span><br><span class="line">range2.<span class="title function_">setStart</span>(p1, <span class="number">0</span>); </span><br><span class="line">range2.<span class="title function_">setEnd</span>(p1, p1.<span class="property">childNodes</span>.<span class="property">length</span>);</span><br></pre></td></tr></table></figure>

<p>注意，要选择节点（使用 range1），必须先确定给定节点（p1）在其父节点 childNodes 集合中的索引。而要选择节点的内容（使用 range2），则不需要这样计算，因为可以直接给 setStart()和setEnd()传默认值。虽然可以模拟 selectNode()和 selectNodeContents()，但 setStart()和setEnd()真正的威力还是选择节点中的某个部分。</p>
<p>假设我们想通过范围从前面示例中选择从”Hello”中的”llo”到” world!”中的”o”的部分。很简单，第一步是取得所有相关节点的引用，如下面的代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>), </span><br><span class="line"> helloNode = p1.<span class="property">firstChild</span>.<span class="property">firstChild</span>, </span><br><span class="line"> worldNode = p1.<span class="property">lastChild</span></span><br></pre></td></tr></table></figure>

<p>文本”Hello”其实是</p>
<p>的孙子节点，因为它是<strong>的子节点。为此可以使用 p1.firstChild 取 得，而使用 p1.firstChild.firstChild 取得”Hello”这个文本节点。文本节点” world!”是</strong></p>
<p><strong>的第二个（也是最后一个）子节点，因此可以使用 p1.lastChild 来取得它。然后，再创建范围，指定其边界，如下所示：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(); </span><br><span class="line">range.<span class="title function_">setStart</span>(helloNode, <span class="number">2</span>); </span><br><span class="line">range.<span class="title function_">setEnd</span>(worldNode, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>因为选区起点在”Hello”中的字母”e”之后，所以要给 setStart()传入 helloNode 和偏移量 2 （”e”后面的位置，”H”的位置是 0）。要设置选区终点，则要给 setEnd()传入 worldNode 和偏移量 3，即不属于选区的第一个字符的位置，也就是”r”的位置 3（位置 0 是一个空格）。</p>
<p>因为 helloNode 和 worldNode 是文本节点，所以它们会成为范围的 startContainer 和endContainer，这样 startOffset 和 endOffset 实际上表示每个节点中文本字符的位置，而不是子节点的位置（传入元素节点时的情形）。而 commonAncestorContainer 是</p>
<p>元素，即包含这两个节点的第一个祖先节点。</p>
<p>当然，只选择文档中的某个部分并不是特别有用，除非可以对选中部分执行操作。</p>
<h5 id="16-4-4操作范围"><a href="#16-4-4操作范围" class="headerlink" title="16.4.4操作范围"></a>16.4.4操作范围</h5><p>创建范围之后，浏览器会在内部创建一个文档片段节点，用于包含范围选区中的节点。为操作范围的内容，选区中的内容必须格式完好。在前面的例子中，因为范围的起点和终点都在文本节点内部，并不是完好的 DOM 结构，所以无法在 DOM 中表示。不过，范围能够确定缺失的开始和结束标签，从而可以重构出有效的 DOM 结构，以便后续操作。</p>
<p><strong>仍以前面例子中的范围来说，范围发现选区中缺少一个开始的<b>标签，于是会在后台动态补上这个标签，同时还需要补上封闭”He”的结束标签</strong>，结果会把 DOM 修改为这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一个方法最容易理解和使用：deleteContents()。顾名思义，这个方法会从文档中删除范围包含的节点。下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>), </span><br><span class="line"> helloNode = p1.<span class="property">firstChild</span>.<span class="property">firstChild</span>, </span><br><span class="line"> worldNode = p1.<span class="property">lastChild</span>, </span><br><span class="line"> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(); </span><br><span class="line">range.<span class="title function_">setStart</span>(helloNode, <span class="number">2</span>); </span><br><span class="line">range.<span class="title function_">setEnd</span>(worldNode, <span class="number">3</span>); </span><br><span class="line">range.<span class="title function_">deleteContents</span>();</span><br></pre></td></tr></table></figure>

<p>执行上面的代码之后，页面中的 HTML 会变成这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;/<span class="name">b</span>&gt;</span>rld!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为前面介绍的范围选择过程通过修改底层 DOM 结构保证了结构完好，所以即使删除范围之后，剩下的 DOM 结构照样是完好的。</p>
<p>另一个方法 extractContents()跟 deleteContents()类似，也会从文档中移除范围选区。但不同的是，extractContents()方法返回范围对应的文档片段。这样，就可以把范围选中的内容插入文档中其他地方。来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>), </span><br><span class="line"> helloNode = p1.<span class="property">firstChild</span>.<span class="property">firstChild</span>, </span><br><span class="line"> worldNode = p1.<span class="property">lastChild</span>, </span><br><span class="line"> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>();</span><br><span class="line">range.<span class="title function_">setStart</span>(helloNode, <span class="number">2</span>); </span><br><span class="line">range.<span class="title function_">setEnd</span>(worldNode, <span class="number">3</span>); </span><br><span class="line"><span class="keyword">let</span> fragment = range.<span class="title function_">extractContents</span>(); </span><br><span class="line">p1.<span class="property">parentNode</span>.<span class="title function_">appendChild</span>(fragment);</span><br></pre></td></tr></table></figure>

<p>这个例子提取了范围的文档片段，然后把它添加到文档元素的最后。（别忘了，在把文档片段传给 appendChild()时，只会添加片段的子树，不包含片段自身。）结果就会得到如下 HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;/<span class="name">b</span>&gt;</span>rld!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> wo</span><br></pre></td></tr></table></figure>

<p>如果不想把范围从文档中移除，也可以使用 cloneContents()创建一个副本，然后把这个副本插入到文档其他地方。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>), </span><br><span class="line"> helloNode = p1.<span class="property">firstChild</span>.<span class="property">firstChild</span>, </span><br><span class="line"> worldNode = p1.<span class="property">lastChild</span>, </span><br><span class="line"> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(); </span><br><span class="line">range.<span class="title function_">setStart</span>(helloNode, <span class="number">2</span>); </span><br><span class="line">range.<span class="title function_">setEnd</span>(worldNode, <span class="number">3</span>); </span><br><span class="line"><span class="keyword">let</span> fragment = range.<span class="title function_">cloneContents</span>(); </span><br><span class="line">p1.<span class="property">parentNode</span>.<span class="title function_">appendChild</span>(fragment);</span><br></pre></td></tr></table></figure>

<p>这个方法跟 extractContents()很相似，因为它们都返回文档片段。主要区别是 cloneContents()返回的文档片段包含范围中节点的副本，而非实际的节点。执行上面操作之后，HTML 页面会变成这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> wo</span><br></pre></td></tr></table></figure>

<p>此时关键是要知道，为保持结构完好而拆分节点的操作，只有在调用前述方法时才会发生。在 DOM被修改之前，原始 HTML 会一直保持不变。</p>
<h5 id="16-4-5范围插入"><a href="#16-4-5范围插入" class="headerlink" title="16.4.5范围插入"></a>16.4.5范围插入</h5><p>上一节介绍了移除和复制范围的内容，本节来看一看怎么向范围中插入内容。使用 insertNode()方法可以在范围选区的开始位置插入一个节点。例如，假设我们想在前面例子中的 HTML中插入如下 HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>Inserted text<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以使用下列代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>), </span><br><span class="line"> helloNode = p1.<span class="property">firstChild</span>.<span class="property">firstChild</span>, </span><br><span class="line"> worldNode = p1.<span class="property">lastChild</span>, </span><br><span class="line"> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(); </span><br><span class="line">range.<span class="title function_">setStart</span>(helloNode, <span class="number">2</span>); </span><br><span class="line">range.<span class="title function_">setEnd</span>(worldNode, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> span = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>); </span><br><span class="line">span.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>; </span><br><span class="line">span.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Inserted text&quot;</span>)); </span><br><span class="line">range.<span class="title function_">insertNode</span>(span);</span><br></pre></td></tr></table></figure>

<p>运行上面的代码会得到如下 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>Inserted text<span class="tag">&lt;/<span class="name">span</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，正好插入到”Hello”中的”llo”之前，也就是范围选区的前面。同时，也要注意原始的 HTML 并没有添加或删除<strong>元素，因为这里并没有使用之前提到的方法。使用这个技术可以插入有用的信息，比如在外部链接旁边插入一个小图标。</strong></p>
<p>除了向范围中插入内容，还可以使用 surroundContents()方法插入包含范围的内容。这个方法接收一个参数，即包含范围内容的节点。调用这个方法时，后台会执行如下操作：</p>
<p>(1) 提取出范围的内容；</p>
<p>(2) 在原始文档中范围之前所在的位置插入给定的节点；</p>
<p>(3) 将范围对应文档片段的内容添加到给定节点。</p>
<p>这种功能适合在网页中高亮显示某些关键词，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>), </span><br><span class="line"> helloNode = p1.<span class="property">firstChild</span>.<span class="property">firstChild</span>, </span><br><span class="line"> worldNode = p1.<span class="property">lastChild</span>, </span><br><span class="line"> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>();</span><br><span class="line"></span><br><span class="line">range.<span class="title function_">selectNode</span>(helloNode); </span><br><span class="line"><span class="keyword">let</span> span = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>); </span><br><span class="line">span.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;yellow&quot;</span>; </span><br><span class="line">range.<span class="title function_">surroundContents</span>(span);</span><br></pre></td></tr></table></figure>

<p>执行以上代码会以黄色背景高亮显示范围选择的文本。得到的 HTML 如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;background-color:yellow&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了插入元素，范围中必须包含完整的 DOM 结构。如果范围中包含部分选择的非文节点，这个操作会失败并报错。另外，如果给定的节点是 Document、DocumentType 或 DocumentFragment类型，也会导致抛出错误。</p>
<h5 id="16-4-6范围折叠"><a href="#16-4-6范围折叠" class="headerlink" title="16.4.6范围折叠"></a>16.4.6范围折叠</h5><p>如果范围并没有选择文档的任何部分，则称为折叠（collapsed）。折叠范围有点类似文本框：如果文本框中有文本，那么可以用鼠标选中以高亮显示全部文本。这时候，如果再单击鼠标，则选区会被移除，光标会落在某两个字符中间。而在折叠范围时，位置会被设置为范围与文档交界的地方，可能是范围选区的开始处，也可能是结尾处。</p>
<p>折叠范围可以使用 collapse()方法，这个方法接收一个参数：布尔值，表示折叠到范围哪一端。true 表示折叠到起点，false 表示折叠到终点。要确定范围是否已经被折叠，可以检测范围的 collapsed属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range.<span class="title function_">collapse</span>(<span class="literal">true</span>); <span class="comment">// 折叠到起点</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(range.<span class="property">collapsed</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>

<p>测试范围是否被折叠，能够帮助确定范围中的两个节点是否相邻。例如有以下 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span> </span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果事先并不知道标记的结构（比如自动生成的标记），则可以像下面这样创建一个范围：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>), </span><br><span class="line"> p2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p2&quot;</span>), </span><br><span class="line"> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(); </span><br><span class="line">range.<span class="title function_">setStartAfter</span>(p1); </span><br><span class="line">range.<span class="title function_">setStartBefore</span>(p2); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(range.<span class="property">collapsed</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，创建的范围是折叠的，因为 p1 后面和 p2 前面没有任何内容。</p>
<h5 id="16-4-7范围比较"><a href="#16-4-7范围比较" class="headerlink" title="16.4.7范围比较"></a>16.4.7范围比较</h5><p>如果有多个范围，则可以使用 compareBoundaryPoints()方法确定范围之间是否存在公共的边界（起点或终点）。这个方法接收两个参数：要比较的范围和一个常量值，表示比较的方式。这个常量参数包括：</p>
<ul>
<li> Range.START_TO_START（0），比较两个范围的起点；</li>
<li> Range.START_TO_END（1），比较第一个范围的起点和第二个范围的终点；</li>
<li> Range.END_TO_END（2），比较两个范围的终点；</li>
<li> Range.END_TO_START（3），比较第一个范围的终点和第二个范围的起点。</li>
</ul>
<p>compareBoundaryPoints()方法在第一个范围的边界点位于第二个范围的边界点之前时返回-1，在两个范围的边界点相等时返回 0，在第一个范围的边界点位于第二个范围的边界点之后时返回 1。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range1 = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(); </span><br><span class="line"><span class="keyword">let</span> range2 = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(); </span><br><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>); </span><br><span class="line">range1.<span class="title function_">selectNodeContents</span>(p1); </span><br><span class="line">range2.<span class="title function_">selectNodeContents</span>(p1); </span><br><span class="line">range2.<span class="title function_">setEndBefore</span>(p1.<span class="property">lastChild</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(range1.<span class="title function_">compareBoundaryPoints</span>(<span class="title class_">Range</span>.<span class="property">START_TO_START</span>, range2)); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(range1.<span class="title function_">compareBoundaryPoints</span>(<span class="title class_">Range</span>.<span class="property">END_TO_END</span>, range2));  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在这段代码中，两个范围的起点是相等的，因为它们都是 selectNodeContents()默认返回的值。</p>
<p>因此，比较二者起点的方法返回 0。不过，因为 range2 的终点被使用 setEndBefore()修改了，所以</p>
<p>导致 range1 的终点位于 range2 的终点之后（见图 16-11），结果这个方法返回了 1。</p>
<h5 id="16-4-8复制范围"><a href="#16-4-8复制范围" class="headerlink" title="16.4.8复制范围"></a>16.4.8复制范围</h5><p>调用范围的 cloneRange()方法可以复制范围。这个方法会创建调用它的范围的副本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newRange = range.<span class="title function_">cloneRange</span>();</span><br></pre></td></tr></table></figure>

<p>新范围包含与原始范围一样的属性，修改其边界点不会影响原始范围。</p>
<h5 id="16-4-9清理"><a href="#16-4-9清理" class="headerlink" title="16.4.9清理"></a>16.4.9清理</h5><p>在使用完范围之后，最好调用 detach()方法把范围从创建它的文档中剥离。调用 detach()之后，就可以放心解除对范围的引用，以便垃圾回收程序释放它所占用的内存。下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range.<span class="title function_">detach</span>(); <span class="comment">// 从文档中剥离范围</span></span><br><span class="line">range = <span class="literal">null</span>; <span class="comment">// 解除引用</span></span><br></pre></td></tr></table></figure>

<p>这两步是最合理的结束使用范围的方式。剥离之后的范围就不能再使用了。</p>
<h3 id="17：事件"><a href="#17：事件" class="headerlink" title="17：事件"></a>17：事件</h3><p>JavaScript 与 HTML 的交互是通过事件实现的，事件代表文档或浏览器窗口中某个有意义的时刻。可以使用仅在事件发生时执行的监听器（也叫处理程序）订阅事件。在传统软件工程领域，这个模型叫“观察者模式”，其能够做到页面行为（在 JavaScript 中定义）与页面展示（在 HTML 和 CSS 中定义）的分离。</p>
<h4 id="17-1事件流"><a href="#17-1事件流" class="headerlink" title="17.1事件流"></a>17.1事件流</h4><p>事件流描述了页面接收事件的顺序。结果非常有意思，IE 和 Netscape 开发团队提出了几乎完全相反的事件流方案。IE 将支持事件冒泡流，而 Netscape Communicator 将支持事件捕获流。</p>
<h5 id="17-1-1事件冒泡"><a href="#17-1-1事件冒泡" class="headerlink" title="17.1.1事件冒泡"></a>17.1.1事件冒泡</h5><p>IE 事件流被称为事件冒泡，这是因为事件被定义为从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）。</p>
<p>在点击页面中的元素后，click 事件会以如下顺序发生：</p>
<p>元素，即被点击的元素，最先触发 click 事件。然后，click 事件沿 DOM 树一路向上，在经过的每个节点上依次触发，直至到达 document 对象。图 17-1 形象地展示了这个过程。</p>
<p>所有现代浏览器都支持事件冒泡，只是在实现方式上会有一些变化。IE5.5及早期版本会跳过元素（从直接到 document）。现代浏览器中的事件会一直冒泡到 window 对象。</p>
<h5 id="17-1-2事件捕获"><a href="#17-1-2事件捕获" class="headerlink" title="17.1.2事件捕获"></a>17.1.2事件捕获</h5><p>Netscape Communicator 团队提出了另一种名为事件捕获的事件流。事件捕获的意思是最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。事件捕获实际上是为了在事件到达最终目标前拦截事件。如果前面的例子使用事件捕获，则点击</p>
<p>元素会以下列顺序触发 click 事件：</p>
<p>在事件捕获中，click 事件首先由 document 元素捕获，然后沿 DOM 树依次向下传播，直至到达实际的目标元素</p>
<p>虽然这是 Netscape Communicator 唯一的事件流模型，但事件捕获得到了所有现代浏览器的支持。实际上，所有浏览器都是从 window 对象开始捕获事件，而 DOM2 Events规范规定的是从 document 开始。</p>
<p>由于旧版本浏览器不支持，因此实际当中几乎不会使用事件捕获。通常建议使用事件冒泡，特殊情况下可以使用事件捕获。</p>
<h5 id="17-1-3DOM-事件流"><a href="#17-1-3DOM-事件流" class="headerlink" title="17.1.3DOM 事件流"></a>17.1.3DOM 事件流</h5><p>DOM2 Events 规范规定事件流分为 3 个阶段：事件捕获、到达目标和事件冒泡。事件捕获最先发生，为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。</p>
<h4 id="17-2事件处理程序"><a href="#17-2事件处理程序" class="headerlink" title="17.2事件处理程序"></a>17.2事件处理程序</h4><p>为响应事件而调用的函数被称为事件处理程序（或事件监听器）。事件处理程序的名字以”on”开头，因此 click 事件的处理程序叫作 onclick，而 load 事件的处理程序叫作 onload。</p>
<h5 id="17-2-1HTML-事件处理程序"><a href="#17-2-1HTML-事件处理程序" class="headerlink" title="17.2.1HTML 事件处理程序"></a>17.2.1HTML 事件处理程序</h5><p>特定元素支持的每个事件都可以使用事件处理程序的名字以 HTML 属性的形式来指定。此时属性的值必须是能够执行的 JavaScript 代码。</p>
<p>例如，要在按钮被点击时执行某些 JavaScript 代码，可以使用以下 HTML 属性：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;Clicked&#x27;)&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击这个按钮后，控制台会输出一条消息。这种交互能力是通过为 onclick 属性指定 JavaScript代码值来实现的。注意，因为属性的值是 JavaScript 代码，所以不能在未经转义的情况下使用 HTML 语法字符，比如和号（&amp;）、双引号（”）、小于号（&lt;）和大于号（&gt;）。</p>
<p>此时，为了避免使用 HTML 实体，可以使用单引号代替双引号。如果确实需要使用双引号，则要把代码改成下面这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(<span class="symbol">&amp;quot;</span>Clicked<span class="symbol">&amp;quot;</span>)&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 HTML 中定义的事件处理程序可以包含精确的动作指令，也可以调用在页面其他地方定义的脚本，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"></span>) &#123; </span></span><br><span class="line"><span class="language-javascript">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello world!&quot;</span>); </span></span><br><span class="line"><span class="language-javascript">    &#125; </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;showMessage()&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，单击按钮会调用 showMessage()函数。showMessage()函数是在单独的 </p>
<p>以这种方式指定的事件处理程序有一些特殊的地方。首先，会创建一个函数来封装属性的值。这个函数有一个特殊的局部变量 event，其中保存的就是 event 对象（本章后面会讨论）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输出&quot;click&quot; --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(event.type)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有了这个对象，就不用开发者另外定义其他变量，也不用从包装函数的参数列表中去取了。</p>
<p>在这个函数中，this 值相当于事件的目标元素，如下面的例子所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输出&quot;Click Me&quot; --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(this.value)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个动态创建的包装函数还有一个特别有意思的地方，就是其作用域链被扩展了。在这个函数中，document 和元素自身的成员都可以被当成局部变量来访问。这是通过使用 with 实现的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="title function_">with</span>(<span class="params"><span class="variable language_">document</span></span>) &#123; </span><br><span class="line">         <span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span></span>) &#123; </span><br><span class="line">         	<span class="comment">// 属性值</span></span><br><span class="line">    	&#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着事件处理程序可以更方便地访问自己的属性。下面的代码与前面的示例功能一样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输出&quot;Click Me&quot; --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(value)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果这个元素是一个表单输入框，则作用域链中还会包含表单元素，事件处理程序对应的函数等价于如下这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="title function_">with</span>(<span class="params"><span class="variable language_">document</span></span>) &#123; </span><br><span class="line">         <span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span>.form</span>) &#123;</span><br><span class="line">             <span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span></span>) &#123; </span><br><span class="line">             <span class="comment">// 属性值</span></span><br><span class="line">             &#125; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上，经过这样的扩展，事件处理程序的代码就可以不必引用表单元素，而直接访问同一表单中的其他成员了。下面的例子就展示了这种成员访问模式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Echo Username&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(username.value)&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击这个例子中的按钮会显示出文本框中包含的文本。注意，事件处理程序中的代码直接引用了username。</p>
<p>缺点：时机问题</p>
<p>有可能 HTML 元素已经显示在页面上，用户都与其交互了，而事件处理程序的代码还无法执行。为此，大多数 HTML 事件处理程序会封装在 try&#x2F;catch 块中，以便在这种情况下静默失败，如下面的例子所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;try&#123;showMessage();&#125;catch(ex) &#123;console.log(&#x27;出错了&#x27;)&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> showMessage</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 延迟执行</span></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      showMessage = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;正常&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">5000</span>);</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，如果在 showMessage()函数被定义之前点击了按钮，就不会发生 JavaScript 错误了，这是因为错误在浏览器收到之前已经被拦截了。</p>
<p>另一个问题是对事件处理程序作用域链的扩展在不同浏览器中可能导致不同的结果。不同JavaScript 引擎中标识符解析的规则存在差异，因此访问无限定的对象成员可能导致错误。</p>
<p>使用 HTML 指定事件处理程序的最后一个问题是 HTML 与 JavaScript 强耦合。如果需要修改事件处理程序，则必须在两个地方，即 HTML 和 JavaScript 中，修改代码。这也是很多开发者不使用 HTML事件处理程序，而使用 JavaScript 指定事件处理程序的主要原因。</p>
<h5 id="17-2-2DOM-事件处理程序"><a href="#17-2-2DOM-事件处理程序" class="headerlink" title="17.2.2DOM 事件处理程序"></a>17.2.2DOM 事件处理程序</h5><p>DOM0处理：</p>
<p>每个元素（包括 window 和 document）都有通常小写的事件处理程序属性，比如 onclick。只要把这个属性赋值为一个函数即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里先从文档中取得按钮，然后给它的 onclick 事件处理程序赋值一个函数。注意，前面的代码在运行之后才会给事件处理程序赋值。因此如果在页面中上面的代码出现在按钮之后，则有可能出现用户点击按钮没有反应的情况。</p>
<p>像这样使用 DOM0 方式为事件处理程序赋值时，所赋函数被视为元素的方法。因此，事件处理程序会在元素的作用域中运行，即 this 等于元素。下面的例子演示了使用 this 引用元素本身：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>); <span class="comment">// &quot;myBtn&quot; </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>点击按钮，这段代码会显示元素的 ID。这个 ID 是通过 this.id 获取的。不仅仅是 id，在事件处理程序里通过 this 可以访问元素的任何属性和方法。以这种方式添加事件处理程序是注册在事件流的冒泡阶段的。</p>
<p>通过将事件处理程序属性的值设置为 null，可以移除通过 DOM0 方式添加的事件处理程序，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span>; <span class="comment">// 移除事件处理程序</span></span><br></pre></td></tr></table></figure>

<h5 id="17-2-3DOM2处理："><a href="#17-2-3DOM2处理：" class="headerlink" title="17.2.3DOM2处理："></a>17.2.3DOM2处理：</h5><p>DOM2 Events 为事件处理程序的赋值和移除定义了两个方法：addEventListener()和 removeEventListener()。这两个方法暴露在所有 DOM 节点上，它们接收 3 个参数：事件名、事件处理函数和一个布尔值，true 表示在捕获阶段调用事件处理程序，false（默认值）表示在冒泡阶段调用事件处理程序。</p>
<p>仍以给按钮添加 click 事件处理程序为例，可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>); </span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码为按钮添加了会在事件冒泡阶段触发的 onclick 事件处理程序（因为最后一个参数值为false）。与 DOM0 方式类似，这个事件处理程序同样在被附加到的元素的作用域中运行。使用 DOM2方式的主要优势是可以为同一个事件添加多个事件处理程序。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>); </span><br><span class="line">&#125;, <span class="literal">false</span>); </span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>这里给按钮添加了两个事件处理程序。多个事件处理程序以添加顺序来触发，因此前面的代码会先打印元素 ID，然后显示消息“Hello world!”。</p>
<p>通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()并传入与添加时同样的参数来移除。这意味着使用 addEventListener()添加的匿名函数无法移除，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>); </span><br><span class="line"> &#125;, <span class="literal">false</span>); </span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 没有效果！</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>); </span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>这个例子通过 addEventListener()添加了一个匿名函数作为事件处理程序。然后，又以看起来相同的参数调用了 removeEventListener()。但实际上，第二个参数与传给 addEventListener()的完全不是一回事。传给 removeEventListener()的事件处理函数必须与传给 addEventListener()的是同一个，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>); </span><br><span class="line">&#125;; </span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>); </span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>); <span class="comment">// 有效果！</span></span><br></pre></td></tr></table></figure>

<p>这个例子有效，因为调用 addEventListener()和 removeEventListener()时传入的是同一个函数。</p>
<p>大多数情况下，事件处理程序会被添加到事件流的冒泡阶段，主要原因是跨浏览器兼容性好。把事件处理程序注册到捕获阶段通常用于在事件到达其指定目标之前拦截事件。如果不需要拦截，则不要使用事件捕获。</p>
<h5 id="17-2-4IE-事件处理程序"><a href="#17-2-4IE-事件处理程序" class="headerlink" title="17.2.4IE 事件处理程序"></a>17.2.4IE 事件处理程序</h5><p>IE 实现了与 DOM 类似的方法，即 attachEvent()和 detachEvent()。这两个方法接收两个同样的参数：事件处理程序的名字和事件处理函数。因为 IE8 及更早版本只支持事件冒泡，所以使用attachEvent()添加的事件处理程序会添加到冒泡阶段。</p>
<p>要使用 attachEvent()给按钮添加 click 事件处理程序，可以使用以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="title function_">attachEvent</span>(<span class="string">&quot;onclick&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意，attachEvent()的第一个参数是”onclick”，而不是 DOM 的 addEventListener()方法的”click”。</p>
<p>IE 中使用 attachEvent()与使用 DOM0 方式的主要区别是事件处理程序的作用域。使用 DOM0方式时，事件处理程序中的 this 值等于目标元素。而使用 attachEvent()时，事件处理程序是在全局作用域中运行的，因此 this 等于 window。来看下面使用 attachEvent()的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="title function_">attachEvent</span>(<span class="string">&quot;onclick&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>); <span class="comment">// true </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>理解这些差异对编写跨浏览器代码是非常重要的。</p>
<p>与使用 addEventListener()一样，使用 attachEvent()方法也可以给一个元素添加多个事件处理程序。比如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="title function_">attachEvent</span>(<span class="string">&quot;onclick&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>); </span><br><span class="line">&#125;); </span><br><span class="line">btn.<span class="title function_">attachEvent</span>(<span class="string">&quot;onclick&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里调用了两次 attachEvent()，分别给同一个按钮添加了两个不同的事件处理程序。不过，与DOM 方法不同，这里的事件处理程序会以添加它们的顺序反向触发。换句话说，在点击例子中的按钮后，控制台中会先打印出”Hello world!”，然后再打印出”Clicked”。</p>
<p>使用 attachEvent()添加的事件处理程序将使用 detachEvent()来移除，只要提供相同的参数。与使用 DOM 方法类似，作为事件处理程序添加的匿名函数也无法移除。但只要传给 detachEvent()方法相同的函数引用，就可以移除。下面的例子演示了附加和剥离事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>); </span><br><span class="line">&#125;; </span><br><span class="line">btn.<span class="title function_">attachEvent</span>(<span class="string">&quot;onclick&quot;</span>, handler); </span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line">btn.<span class="title function_">detachEvent</span>(<span class="string">&quot;onclick&quot;</span>, handler);</span><br></pre></td></tr></table></figure>

<p>这里先把事件处理程序保存到变量 handler，之后又将其传给 detachEvent()来移除事件处理程序。</p>
<h5 id="17-2-5跨浏览器事件处理程序"><a href="#17-2-5跨浏览器事件处理程序" class="headerlink" title="17.2.5跨浏览器事件处理程序"></a>17.2.5跨浏览器事件处理程序</h5><p>为此，需要先创建一个 addHandler()方法。这个方法的任务是根据需要分别使用 DOM0 方式、DOM2 方式或 IE 方式来添加事件处理程序。这个方法会在 EventUtil 对象（本章示例使用的对象）上添加一个方法，以实现跨浏览器事件处理。添加的这个 addHandler()方法接收 3 个参数：目标元素、事件名和事件处理函数。</p>
<p>有了 addHandler()，还要写一个也接收同样的 3 个参数的 removeHandler()。这个方法的任务是移除之前添加的事件处理程序，不管是通过何种方式添加的，默认为 DOM0 方式。</p>
<p>以下就是包含这两个方法的 EventUtil 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">EventUtil</span> = &#123;</span><br><span class="line">    <span class="attr">addHandler</span>: <span class="keyword">function</span> (<span class="params">element, type, handler</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">            element.<span class="title function_">addEventListener</span>(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">attachEvent</span>) &#123;</span><br><span class="line">            element.<span class="title function_">attachEvent</span>(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">removeHandler</span>: <span class="keyword">function</span> (<span class="params">element, type, handler</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element.<span class="property">removeEventListener</span>) &#123;</span><br><span class="line">            element.<span class="title function_">removeEventListener</span>(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">detachEvent</span>) &#123;</span><br><span class="line">            element.<span class="title function_">detachEvent</span>(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>两个方法都是首先检测传入元素上是否存在 DOM2 方式。如果有 DOM2 方式，就使用该方式，传入事件类型和事件处理函数，以及表示冒泡阶段的第三个参数 false。否则，如果存在 IE 方式，则使用该方式。注意这时候必须在事件类型前加上”on”，才能保证在 IE8 及更早版本中有效。最后是使用DOM0 方式（在现代浏览器中不会到这一步）。注意使用 DOM0 方式时使用了中括号计算属性名，并将事件处理程序或 null 赋给了这个属性。</p>
<p>可以像下面这样使用 EventUtil 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>) </span><br><span class="line"><span class="keyword">let</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="title class_">EventUtil</span>.<span class="title function_">addHandler</span>(btn, <span class="string">&quot;click&quot;</span>, handler); </span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line"><span class="title class_">EventUtil</span>.<span class="title function_">removeHandler</span>(btn, <span class="string">&quot;click&quot;</span>, handler);</span><br></pre></td></tr></table></figure>

<p>这里的 addHandler()和 removeHandler()方法并没有解决所有跨浏览器一致性问题，比如 IE的作用域问题、多个事件处理程序执行顺序问题等。不过，这两个方法已经实现了跨浏览器添加和移除事件处理程序。另外也要注意，DOM0 只支持给一个事件添加一个处理程序。好在 DOM0 浏览器已经很少有人使用了，所以影响应该不大。</p>
<h4 id="17-3事件对象"><a href="#17-3事件对象" class="headerlink" title="17.3事件对象"></a>17.3事件对象</h4><p>在 DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为 event 的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型，以及可能与特定事件相关的任何其他数据。例如，鼠标操作导致的事件会生成鼠标位置信息，而键盘操作导致的事件会生成与被按下的键有关的信息。所有浏览器都支持这个 event 对象，尽管支持方式不同。</p>
<h5 id="17-3-1DOM-事件对象"><a href="#17-3-1DOM-事件对象" class="headerlink" title="17.3.1DOM 事件对象"></a>17.3.1DOM 事件对象</h5><p>在 DOM 合规的浏览器中，event 对象是传给事件处理程序的唯一参数。不管以哪种方式（DOM0或 DOM2）指定事件处理程序，都会传入这个 event 对象。下面的例子展示了在两种方式下都可以使用事件对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>); <span class="comment">// &quot;click&quot; </span></span><br><span class="line">&#125;; </span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>); <span class="comment">// &quot;click&quot; </span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>这个例子中的两个事件处理程序都会在控制台打出 event.type 属性包含的事件类型。这个属性中始终包含被触发事件的类型，如”click”（与传给 addEventListener()和 removeEventListener()方法的事件名一致）。</p>
<p>在通过 HTML 属性指定的事件处理程序中，同样可以使用变量 event 引用事件对象。下面的例子中演示了如何使用这个变量：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(event.type)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以这种方式提供 event 对象，可以让 HTML 属性中的代码实现与 JavaScript 函数同样的功能。</p>
<p>如前所述，事件对象包含与特定事件相关的属性和方法。不同的事件生成的事件对象也会包含不同的属性和方法。不过，所有事件对象都会包含下表列出的这些公共属性和方法。</p>
<table>
<thead>
<tr>
<th>属性&#x2F;方法</th>
<th>类 型</th>
<th>读&#x2F;写</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>bubbles</td>
<td>布尔值</td>
<td>只读</td>
<td>表示事件是否冒泡</td>
</tr>
<tr>
<td>cancelable</td>
<td>布尔值</td>
<td>只读</td>
<td>表示是否可以取消事件的默认行为</td>
</tr>
<tr>
<td>currentTarget</td>
<td>元素</td>
<td>只读</td>
<td>当前事件处理程序所在的元素</td>
</tr>
<tr>
<td>defaultPrevented</td>
<td>布尔值</td>
<td>只读</td>
<td>true 表示已经调用 preventDefault()方法（DOM3 Events 中新增）</td>
</tr>
<tr>
<td>detail</td>
<td>整数</td>
<td>只读</td>
<td>事件相关的其他信息</td>
</tr>
<tr>
<td>eventPhase</td>
<td>整数</td>
<td>只读</td>
<td>表示调用事件处理程序的阶段：1 代表捕获阶段，2 代表到达目标，3 代表冒泡阶段</td>
</tr>
<tr>
<td>preventDefault()</td>
<td>函数</td>
<td>只读</td>
<td>用于取消事件的默认行为。只有 cancelable 为 true 才可以调用这个方法</td>
</tr>
<tr>
<td>stopImmediatePropagation()</td>
<td>函数</td>
<td>只读</td>
<td>用于取消所有后续事件捕获或事件冒泡，并阻止调用任何后续事件处理程序（DOM3 Events 中新增）</td>
</tr>
<tr>
<td>stopPropagation()</td>
<td>函数</td>
<td>只读</td>
<td>用于取消所有后续事件捕获或事件冒泡。只有 bubbles为 true 才可以调用这个方法</td>
</tr>
<tr>
<td>target</td>
<td>元素</td>
<td>只读</td>
<td>事件目标</td>
</tr>
<tr>
<td>trusted</td>
<td>布尔值</td>
<td>只读</td>
<td>true 表示事件是由浏览器生成的。false 表示事件是开发者通过 JavaScript 创建的（DOM3 Events 中新增）</td>
</tr>
<tr>
<td>type</td>
<td>字符串</td>
<td>只读</td>
<td>被触发的事件类型</td>
</tr>
<tr>
<td>View</td>
<td>AbstractView</td>
<td>只读</td>
<td>与事件相关的抽象视图。等于事件所发生的 window 对象</td>
</tr>
</tbody></table>
<p>在事件处理程序内部，this 对象始终等于 currentTarget 的值，而 target 只包含事件的实际目标。如果事件处理程序直接添加在了意图的目标，则 this、currentTarget 和 target 的值是一样的。下面的例子展示了这两个属性都等于 this 的情形：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">currentTarget</span> === <span class="variable language_">this</span>); <span class="comment">// true </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span> === <span class="variable language_">this</span>); <span class="comment">// true </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码检测了 currentTarget 和 target 的值是否等于 this。因为 click 事件的目标是按钮，所以这 3 个值是相等的。如果这个事件处理程序是添加到按钮的父节点（如 document.body）上，那么它们的值就不一样了。比如下面的例子在 document.body 上添加了单击处理程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">currentTarget</span> === <span class="variable language_">document</span>.<span class="property">body</span>); <span class="comment">// true </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">document</span>.<span class="property">body</span>); <span class="comment">// true </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span> === <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>)); <span class="comment">// true </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种情况下点击按钮，this 和 currentTarget 都等于 document.body，这是因为它是注册事件处理程序的元素。而 target 属性等于按钮本身，这是因为那才是 click 事件真正的目标。由于按钮本身并没有注册事件处理程序，因此 click 事件冒泡到 document.body，从而触发了在它上面注册的处理程序。</p>
<p>type 属性在一个处理程序处理多个事件时很有用。比如下面的处理程序中就使用了 event.type：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> handler = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.<span class="property">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;click&quot;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;mouseover&quot;</span>:</span><br><span class="line">            event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;mouseout&quot;</span>:</span><br><span class="line">            event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">btn.<span class="property">onclick</span> = handler;</span><br><span class="line">btn.<span class="property">onmouseover</span> = handler;</span><br><span class="line">btn.<span class="property">onmouseout</span> = handler;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，函数 handler 被用于处理 3 种不同的事件：click、mouseover 和 mouseout。当按钮被点击时，应该在控制台打印一条消息，如前面的例子所示。而把鼠标放到按钮上，会导致按钮背景变成红色，接着把鼠标从按钮上移开，背景颜色应该又恢复成默认值。这个函数使用 event.type属性确定了事件类型，从而可以做出不同的响应。</p>
<p>preventDefault()方法用于阻止特定事件的默认动作。比如，链接的默认行为就是在被单击时导航到 href 属性指定的 URL。如果想阻止这个导航行为，可以在 onclick 事件处理程序中取消，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myLink&quot;</span>); </span><br><span class="line">link.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> event.<span class="title function_">preventDefault</span>(); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>任何可以通过 preventDefault()取消默认行为的事件，其事件对象的 cancelable 属性都会设置为 true。</p>
<p>stopPropagation()方法用于立即阻止事件流在 DOM 结构中传播，取消后续的事件捕获或冒泡。例如，直接添加到按钮的事件处理程序中调用 stopPropagation()，可以阻止 document.body 上注册的事件处理程序执行。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>); </span><br><span class="line"> event.<span class="title function_">stopPropagation</span>(); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Body clicked&quot;</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果这个例子中不调用stopPropagation()，那么点击按钮就会打印两条消息。但这里由于click事件不会传播到 document.body，因此 onclick 事件处理程序永远不会执行。</p>
<p>eventPhase 属性可用于确定事件流当前所处的阶段。如果事件处理程序在捕获阶段被调用，则eventPhase 等于 1；如果事件处理程序在目标上被调用，则 eventPhase 等于 2；如果事件处理程序在冒泡阶段被调用，则 eventPhase 等于 3。不过要注意的是，虽然“到达目标”是在冒泡阶段发生的，但其 eventPhase 仍然等于 2。下面的例子展示了 eventPhase 在不同阶段的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">eventPhase</span>); <span class="comment">// 2 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">eventPhase</span>); <span class="comment">// 1 </span></span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">onclick</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">eventPhase</span>); <span class="comment">// 3 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，点击按钮首先会触发注册在捕获阶段的 document.body 上的事件处理程序，显示 eventPhase 为 1。接着，会触发按钮本身的事件处理程序（尽管是注册在冒泡阶段），此时显示 eventPhase 等于 2。最后触发的是注册在冒泡阶段的 document.body 上的事件处理程序，显示eventPhase 为 3。而当 eventPhase 等于 2 时，this、target 和 currentTarget 三者相等。</p>
<p>注意 event 对象只在事件处理程序执行期间存在，一旦执行完毕，就会被销毁。</p>
<h5 id="17-3-2IE-事件对象"><a href="#17-3-2IE-事件对象" class="headerlink" title="17.3.2IE 事件对象"></a>17.3.2IE 事件对象</h5><p>与 DOM 事件对象不同， IE 事件对象可以基于事件处理程序被指定的方式以不同方式来访问。如果事件处理程序是使用 DOM0 方式指定的，则 event 对象只是 window 对象的一个属性，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> event = <span class="variable language_">window</span>.<span class="property">event</span>; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>); <span class="comment">// &quot;click&quot; </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里，window.event 中保存着 event 对象，其 event.type 属性保存着事件类型（IE 的这个属性的值与 DOM 事件对象中一样）。不过，如果事件处理程序是使用 attachEvent()指定的，则 event对象会作为唯一的参数传给处理函数，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="title function_">attachEvent</span>(<span class="string">&quot;onclick&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>); <span class="comment">// &quot;click&quot; </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用 attachEvent()时，event 对象仍然是 window 对象的属性（像 DOM0 方式那样），只是出于方便也将其作为参数传入。</p>
<p>如果是使用 HTML 属性方式指定的事件处理程序，则 event 对象同样可以通过变量 event 访问（与DOM 模型一样）。下面是在 HTML 事件属性中使用 event.type 的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(event.type)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>IE 事件对象也包含与导致其创建的特定事件相关的属性和方法，其中很多都与相关的 DOM 属性和方法对应。与 DOM 事件对象一样，基于触发的事件类型不同，event 对象中包含的属性和方法也不一样。不过，所有 IE 事件对象都会包含下表所列的公共属性和方法。</p>
<table>
<thead>
<tr>
<th>属性&#x2F;方法</th>
<th>类 型</th>
<th>读&#x2F;写</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>cancelBubble</td>
<td>布尔值</td>
<td>读&#x2F;写</td>
<td>默认为 false，设置为 true 可以取消冒泡（与 DOM 的stopPropagation()方法相同）</td>
</tr>
<tr>
<td>returnValue</td>
<td>布尔值</td>
<td>读&#x2F;写</td>
<td>默认为 true，设置为 false 可以取消事件默认行为（与 DOM 的 preventDefault()方法相同）</td>
</tr>
<tr>
<td>srcElement</td>
<td>元素</td>
<td>只读</td>
<td>事件目标（与 DOM 的 target 属性相同）</td>
</tr>
<tr>
<td>type</td>
<td>字符串</td>
<td>只读</td>
<td>触发的事件类型</td>
</tr>
</tbody></table>
<p>由于事件处理程序的作用域取决于指定它的方式，因此 this 值并不总是等于事件目标。为此，更好的方式是使用事件对象的 srcElement 属性代替 this。下面的例子表明，不同事件对象上的srcElement 属性中保存的都是事件目标：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">event</span>.<span class="property">srcElement</span> === <span class="variable language_">this</span>); <span class="comment">// true </span></span><br><span class="line">&#125;; </span><br><span class="line">btn.<span class="title function_">attachEvent</span>(<span class="string">&quot;onclick&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">srcElement</span> === <span class="variable language_">this</span>); <span class="comment">// false </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在第一个以 DOM0 方式指定的事件处理程序中，srcElement 属性等于 this，而在第二个事件处理程序中（运行在全局作用域下），两个值就不相等了。</p>
<p>returnValue 属性等价于 DOM 的 preventDefault()方法，都是用于取消给定事件默认的行为。只不过在这里要把 returnValue 设置为 false 才是阻止默认动作。下面是一个设置该属性的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myLink&quot;</span>); </span><br><span class="line">link.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">window</span>.<span class="property">event</span>.<span class="property">returnValue</span> = <span class="literal">false</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，returnValue 在 onclick 事件处理程序中被设置为 false，阻止了链接的默认行为。与 DOM 不同，没有办法通过 JavaScript 确定事件是否可以被取消。</p>
<p>cancelBubble 属性与 DOMstopPropagation()方法用途一样，都可以阻止事件冒泡。因为 IE8及更早版本不支持捕获阶段，所以只会取消冒泡。stopPropagation()则既取消捕获也取消冒泡。下面是一个取消冒泡的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>); </span><br><span class="line"> <span class="variable language_">window</span>.<span class="property">event</span>.<span class="property">cancelBubble</span> = <span class="literal">true</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Body clicked&quot;</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过在按钮的 onclick 事件处理程序中将 cancelBubble 设置为 true，可以阻止事件冒泡到document.body，也就阻止了调用注册在它上面的事件处理程序。于是，点击按钮只会输出一条消息。</p>
<h5 id="17-3-3跨浏览器事件对象"><a href="#17-3-3跨浏览器事件对象" class="headerlink" title="17.3.3跨浏览器事件对象"></a>17.3.3跨浏览器事件对象</h5><p>虽然 DOM 和 IE 的事件对象并不相同，但它们有足够的相似性可以实现跨浏览器方案。DOM 事件对象中包含 IE 事件对象的所有信息和能力，只是形式不同。这些共性可让两种事件模型之间的映射成为可能。本章前面的 EventUtil 对象可以像下面这样再添加一些方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">EventUtil</span> = &#123;</span><br><span class="line">    <span class="attr">addHandler</span>: <span class="keyword">function</span> (<span class="params">element, type, handler</span>) &#123;</span><br><span class="line">        <span class="comment">// 为节省版面，删除了之前的代码</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getEvent</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> event ? event : <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getTarget</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> event.<span class="property">target</span> || event.<span class="property">srcElement</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">preventDefault</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.<span class="property">preventDefault</span>) &#123;</span><br><span class="line">            event.<span class="title function_">preventDefault</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            event.<span class="property">returnValue</span> = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">removeHandler</span>: <span class="keyword">function</span> (<span class="params">element, type, handler</span>) &#123;</span><br><span class="line">        <span class="comment">// 为节省版面，删除了之前的代码</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">stopPropagation</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.<span class="property">stopPropagation</span>) &#123;</span><br><span class="line">            event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            event.<span class="property">cancelBubble</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里一共给 EventUtil 增加了 4 个新方法。首先是 getEvent()，其返回对 event 对象的引用。IE 中事件对象的位置不同，而使用这个方法可以不用管事件处理程序是如何指定的，都可以获取到event 对象。使用这个方法的前提是，事件处理程序必须接收 event 对象，并把它传给这个方法。下面是使用 EventUtil 中这个方法统一获取 event 对象的一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> event = <span class="title class_">EventUtil</span>.<span class="title function_">getEvent</span>(event); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 DOM 合规的浏览器中，event 对象会直接传入并返回。而在 IE 中，event 对象可能并没有被定义（因为使用了 attachEvent()），因此返回 window.event。这样就可以确保无论使用什么浏览器，都可以获取到事件对象。</p>
<p>第二个方法是 getTarget()，其返回事件目标。在这个方法中，首先检测 event 对象是否存在target 属性。如果存在就返回这个值；否则，就返回 event.srcElement 属性。下面是使用这个方法的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> event = <span class="title class_">EventUtil</span>.<span class="title function_">getEvent</span>(event); </span><br><span class="line"> <span class="keyword">let</span> target = <span class="title class_">EventUtil</span>.<span class="title function_">getTarget</span>(event); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第三个方法是 preventDefault()，其用于阻止事件的默认行为。在传入的 event 对象上，如果有 preventDefault()方法，就调用这个方法；否则，就将 event.returnValue 设置为 false。下面是使用这个方法的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myLink&quot;</span>); </span><br><span class="line">link.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> event = <span class="title class_">EventUtil</span>.<span class="title function_">getEvent</span>(event); </span><br><span class="line"> <span class="title class_">EventUtil</span>.<span class="title function_">preventDefault</span>(event); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码能在所有主流浏览器中阻止单击链接后跳转到其他页面。这里首先通过 EventUtil. getEvent()获取事件对象，然后又把它传给了 EventUtil.preventDefault()以阻止默认行为。</p>
<p>第四个方法 stopPropagation()以类似的方式运行。同样先检测用于停止事件流的 DOM 方法，如果没有再使用 cancelBubble 属性。下面是使用这个通用 stopPropagation()方法的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>); </span><br><span class="line"> event = <span class="title class_">EventUtil</span>.<span class="title function_">getEvent</span>(event); </span><br><span class="line"> <span class="title class_">EventUtil</span>.<span class="title function_">stopPropagation</span>(event); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Body clicked&quot;</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样，先通过 EventUtil.getEvent()获取事件对象，然后又把它传给了 EventUtil.stop Propagation()。不过，这个方法在浏览器上可能会停止事件冒泡，也可能会既停止事件冒泡也停止事件捕获。</p>
<h4 id="17-4事件类型"><a href="#17-4事件类型" class="headerlink" title="17.4事件类型"></a>17.4事件类型</h4><p>DOM3 Events 定义了如下事件类型。</p>
<ol>
<li> 用户界面事件（UIEvent）：涉及与 BOM 交互的通用浏览器事件。</li>
<li> 焦点事件（FocusEvent）：在元素获得和失去焦点时触发。</li>
<li> 鼠标事件（MouseEvent）：使用鼠标在页面上执行某些操作时触发。</li>
<li> 滚轮事件（WheelEvent）：使用鼠标滚轮（或类似设备）时触发。</li>
<li> 输入事件（InputEvent）：向文档中输入文本时触发。</li>
<li> 键盘事件（KeyboardEvent）：使用键盘在页面上执行某些操作时触发。</li>
<li> 合成事件（CompositionEvent）：在使用某种 IME（Input Method Editor，输入法编辑器）输入字符时触发。</li>
</ol>
<h5 id="17-4-1用户界面事件"><a href="#17-4-1用户界面事件" class="headerlink" title="17.4.1用户界面事件"></a>17.4.1用户界面事件</h5><p>用户界面事件或 UI 事件不一定跟用户操作有关。这类事件在 DOM 规范出现之前就已经以某种形式存在了，保留它们是为了向后兼容。UI 事件主要有以下几种。</p>
<ul>
<li>DOMActivate：元素被用户通过鼠标或键盘操作激活时触发（比 click 或 keydown 更通用）。这个事件在 DOM3 Events 中已经废弃。因为浏览器实现之间存在差异，所以不要使用它。</li>
<li>load：在 window 上当页面加载完成后触发，在窗套（）上当所有窗格（）都加载完成后触发，在元素上当图片加载完成后触发，在元素上当相应对象加载完成后触发。 </li>
<li>unload：在 window 上当页面完全卸载后触发，在窗套上当所有窗格都卸载完成后触发，在元素上当相应对象卸载完成后触发。 </li>
<li>abort：在元素上当相应对象加载完成前被用户提前终止下载时触发。 </li>
<li>error：在 window 上当 JavaScript 报错时触发，在元素上当无法加载指定图片时触发，在元素上当无法加载相应对象时触发，在窗套上当一个或多个窗格无法完成加载时触发。 </li>
<li>select：在文本框（或 textarea）上当用户选择了一个或多个字符时触发。</li>
<li>resize：在 window 或窗格上当窗口或窗格被缩放时触发。</li>
<li>scroll：当用户滚动包含滚动条的元素时在元素上触发。元素包含已加载页面的滚动条。</li>
<li>大多数 HTML 事件与 window 对象和表单控件有关。</li>
<li>除了 DOMActivate，这些事件在 DOM2 Events 中都被归为 HTML Events（DOMActivate 在 DOM2中仍旧是 UI 事件）。</li>
</ul>
<h6 id="load-事件"><a href="#load-事件" class="headerlink" title="load 事件"></a><strong>load 事件</strong></h6><p>load 事件可能是 JavaScript 中最常用的事件。在 window 对象上，load 事件会在整个页面（包括所有外部资源如图片、JavaScript 文件和 CSS 文件）加载完成后触发。可以通过两种方式指定 load 事件处理程序。第一种是 JavaScript 方式，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Loaded!&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这是使用 addEventListener()方法来指定事件处理程序。与其他事件一样，事件处理程序会接收到一个 event 对象。这个 event 对象并没有提供关于这种类型事件的额外信息，虽然在 DOM 合规的浏览器中，event.target 会被设置为 document，但在 IE8 之前的版本中，不会设置这个对象的srcElement 属性。</p>
<p>第二种指定 load 事件处理程序的方式是向元素添加 onload 属性，如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    	 <span class="tag">&lt;<span class="name">title</span>&gt;</span>Load Event Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;console.log(&#x27;Loaded!&#x27;)&quot;</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一般来说，任何在 window 上发生的事件，都可以通过给元素上对应的属性赋值来指定，这是因为 HTML 中没有 window 元素。这实际上是为了保证向后兼容的一个策略，但在所有浏览器中都能得到很好的支持。实际开发中要尽量使用 JavaScript 方式。</p>
<p>注意 根据 DOM2 Events，load 事件应该在 document 而非 window 上触发。可是为了向后兼容，所有浏览器都在 window 上实现了 load 事件。</p>
<p>图片上也会触发load事件，包括DOM中的图片和非DOM中的图片。可以在HTML中直接给元素的 onload 属性指定事件处理程序，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;smile.gif&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;console.log(&#x27;Image loaded.&#x27;)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子会在图片加载完成后输出一条消息。同样，使用 JavaScript 也可以为图片指定事件处理程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myImage&quot;</span>); </span><br><span class="line">image.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">src</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里使用 JavaScript 为图片指定了 load 事件处理程序。处理程序会接收到 event 对象，虽然这个对象上没有多少有用的信息。这个事件的目标是元素，因此可以直接从 event.target.src 属性中取得图片地址并打印出来。</p>
<h6 id="unload-事件"><a href="#unload-事件" class="headerlink" title="unload 事件"></a><strong>unload 事件</strong></h6><p>与 load 事件相对的是 unload 事件，unload 事件会在文档卸载完成后触发。unload 事件一般是在从一个页面导航到另一个页面时触发，最常用于清理引用，以避免内存泄漏。与 load 事件类似，unload 事件处理程序也有两种指定方式。第一种是 JavaScript 方式，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unload&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Unloaded!&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个事件生成的 event 对象在 DOM 合规的浏览器中只有 target 属性（值为 document）。IE8 及更早版本在这个事件上不提供 srcElement 属性。</p>
<p>第二种方式与 load 事件类似，就是给元素添加 onunload 属性：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">     	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Unload Event Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">onunload</span>=<span class="string">&quot;console.log(&#x27;Unloaded!&#x27;)&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>	</span><br></pre></td></tr></table></figure>

<p>无论使用何种方式，都要注意事件处理程序中的代码。因为 unload 事件是在页面卸载完成后触发的，所以不能使用页面加载后才有的对象。此时要访问 DOM 或修改页面外观都会导致错误。</p>
<blockquote>
<p>注意 根据 DOM2 Events，unload 事件应该在而非 window 上触发。可是为了向后兼容，所有浏览器都在 window 上实现了 unload 事件。</p>
</blockquote>
<h6 id="resize-事件"><a href="#resize-事件" class="headerlink" title="resize 事件"></a><strong>resize 事件</strong></h6><p>当浏览器窗口被缩放到新高度或宽度时，会触发 resize 事件。这个事件在 window 上触发，因此可以通过 JavaScript 在 window 上或者为元素添加 onresize 属性来指定事件处理程序。优先使用 JavaScript 方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Resized&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>类似于其他在 window 上发生的事件，此时会生成 event 对象，且这个对象的 target 属性在 DOM合规的浏览器中是 document。而 IE8 及更早版本中并没有提供可用的属性。</p>
<p>不同浏览器在决定何时触发 resize 事件上存在重要差异。IE、Safari、Chrome 和 Opera 会在窗口缩放超过 1 像素时触发 resize 事件，然后随着用户缩放浏览器窗口不断触发。Firefox 早期版本则只在用户停止缩放浏览器窗口时触发 resize 事件。无论如何，都应该避免在这个事件处理程序中执行过多计算。否则可能由于执行过于频繁而导致浏览器响应明确变慢。</p>
<blockquote>
<p>注意 浏览器窗口在最大化和最小化时也会触发 resize 事件。</p>
</blockquote>
<h6 id="scroll-事件"><a href="#scroll-事件" class="headerlink" title="scroll 事件"></a><strong>scroll 事件</strong></h6><p>虽然 scroll 事件发生在 window 上，但实际上反映的是页面中相应元素的变化。在混杂模式下，可以通过元素检测 scrollLeft 和 scrollTop 属性的变化。而在标准模式下，这些变化在除早期版的 Safari 之外的所有浏览器中都发生在元素上（早期版的 Safari 在上跟踪滚动位置）。下面的代码演示了如何处理这些差异：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">compatMode</span> == <span class="string">&quot;CSS1Compat&quot;</span>) &#123; </span><br><span class="line"> 	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>); </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> 	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上事件处理程序会在页面滚动时输出垂直方向上滚动的距离，而且适用于不同渲染模式。因为Safari 3.1 之前不支持 document.compatMode，所以早期版本会走第二个分支。</p>
<p>类似于 resize，scroll 事件也会随着文档滚动而重复触发，因此最好保持事件处理程序的代码尽可能简单。</p>
<h5 id="17-4-2焦点事件"><a href="#17-4-2焦点事件" class="headerlink" title="17.4.2焦点事件"></a>17.4.2焦点事件</h5><p>焦点事件在页面元素获得或失去焦点时触发。这些事件可以与 document.hasFocus()和document.activeElement 一起为开发者提供用户在页面中导航的信息。焦点事件有以下 6 种。</p>
<ul>
<li>blur：当元素失去焦点时触发。这个事件不冒泡，所有浏览器都支持。</li>
<li>DOMFocusIn：当元素获得焦点时触发。这个事件是 focus 的冒泡版。Opera 是唯一支持这个事件的主流浏览器。DOM3 Events 废弃了 DOMFocusIn，推荐 focusin。</li>
<li>DOMFocusOut：当元素失去焦点时触发。这个事件是 blur 的通用版。Opera 是唯一支持这个事件的主流浏览器。DOM3 Events 废弃了 DOMFocusOut，推荐 focusout。</li>
<li>focus：当元素获得焦点时触发。这个事件不冒泡，所有浏览器都支持。</li>
<li>focusin：当元素获得焦点时触发。这个事件是 focus 的冒泡版。</li>
<li>focusout：当元素失去焦点时触发。这个事件是 blur 的通用版。</li>
</ul>
<p>焦点事件中的两个主要事件是 focus 和 blur，这两个事件在 JavaScript 早期就得到了浏览器支持。它们最大的问题是不冒泡。这导致 IE后来又增加了 focusin 和 focusout，Opera又增加了 DOMFocusIn和 DOMFocusOut。IE 新增的这两个事件已经被 DOM3 Events 标准化。</p>
<p>当焦点从页面中的一个元素移到另一个元素上时，会依次发生如下事件。</p>
<ul>
<li>(1) focuscout 在失去焦点的元素上触发。</li>
<li>(2) focusin 在获得焦点的元素上触发。</li>
<li>(3) blur 在失去焦点的元素上触发。</li>
<li>(4) DOMFocusOut 在失去焦点的元素上触发。</li>
<li>(5) focus 在获得焦点的元素上触发。</li>
<li>(6) DOMFocusIn 在获得焦点的元素上触发。</li>
</ul>
<p>其中，blur、DOMFocusOut 和 focusout 的事件目标是失去焦点的元素，而 focus、DOMFocusIn和 focusin 的事件目标是获得焦点的元素。</p>
<h5 id="17-4-3鼠标和滚轮事件"><a href="#17-4-3鼠标和滚轮事件" class="headerlink" title="17.4.3鼠标和滚轮事件"></a>17.4.3鼠标和滚轮事件</h5><p>鼠标事件是 Web 开发中最常用的一组事件，这是因为鼠标是用户的主要定位设备。DOM3 Events定义了 9 种鼠标事件。</p>
<ul>
<li>click：在用户单击鼠标主键（通常是左键）或按键盘回车键时触发。这主要是基于无障碍的考虑，让键盘和鼠标都可以触发 onclick 事件处理程序。</li>
<li>dblclick：在用户双击鼠标主键（通常是左键）时触发。这个事件不是在 DOM2 Events 中定义的，但得到了很好的支持，DOM3 Events 将其进行了标准化。</li>
<li>mousedown：在用户按下任意鼠标键时触发。这个事件不能通过键盘触发。</li>
<li>mouseenter：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。mouseenter 事件不是在 DOM2 Events 中定义的，而是 DOM3 Events中新增的事件。</li>
<li>mouseleave：在用户把鼠标光标从元素内部移到元素外部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。mouseleave 事件不是在 DOM2 Events 中定义的，而是 DOM3 Events中新增的事件。</li>
<li>mousemove：在鼠标光标在元素上移动时反复触发。这个事件不能通过键盘触发</li>
<li>mouseout：在用户把鼠标光标从一个元素移到另一个元素上时触发。移到的元素可以是原始元素的外部元素，也可以是原始元素的子元素。这个事件不能通过键盘触发。</li>
<li>mouseover：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不能通过键盘触发。</li>
<li>mouseup：在用户释放鼠标键时触发。这个事件不能通过键盘触发。</li>
</ul>
<p>页面中的所有元素都支持鼠标事件。除了 mouseenter 和 mouseleave，所有鼠标事件都会冒泡，都可以被取消，而这会影响浏览器的默认行为。由于事件之间存在关系，因此取消鼠标事件的默认行为也会影响其他事件。</p>
<p>比如，click 事件触发的前提是 mousedown 事件触发后，紧接着又在同一个元素上触发了 mouseup事件。如果 mousedown 和 mouseup 中的任意一个事件被取消，那么 click 事件就不会触发。类似地，两次连续的 click 事件会导致 dblclick 事件触发。只要有任何逻辑阻止了这两个 click 事件发生（比如取消其中一个 click 事件或者取消 mousedown 或 mouseup 事件中的任一个），dblclick 事件就不会发生。这 4 个事件永远会按照如下顺序触发：</p>
<ul>
<li>(1) mousedown</li>
<li>(2) mouseup</li>
<li>(3) click</li>
<li>(4) mousedown</li>
<li>(5) mouseup</li>
<li>(6) click</li>
<li>(7) dblclick</li>
</ul>
<p>click 和 dblclick 在触发前都依赖其他事件触发，mousedown 和 mouseup 则不会受其他事件影响。</p>
<p>IE8 及更早版本的实现中有个问题，这会导致双击事件跳过第二次 mousedown 和 click 事件。相应的顺序变成了：</p>
<ul>
<li>(1) mousedown</li>
<li>(2) mouseup</li>
<li>(3) click</li>
<li>(4) mouseup</li>
<li>(5) dblclick</li>
</ul>
<p>鼠标事件在 DOM3 Events 中对应的类型是”MouseEvent”，而不是”MouseEvents”。</p>
<p>鼠标事件还有一个名为滚轮事件的子类别。滚轮事件只有一个事件 mousewheel，反映的是鼠标滚轮或带滚轮的类似设备上滚轮的交互。</p>
<h6 id="客户端坐标"><a href="#客户端坐标" class="headerlink" title="客户端坐标"></a><strong>客户端坐标</strong></h6><p>鼠标事件都是在浏览器视口中的某个位置上发生的。这些信息被保存在 event 对象的 clientX 和clientY 属性中。这两个属性表示事件发生时鼠标光标在视口中的坐标，所有浏览器都支持。</p>
<p>可以通过下面的方式获取鼠标事件的客户端坐标：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Client coordinates: <span class="subst">$&#123;event.clientX&#125;</span>, <span class="subst">$&#123;event.clientY&#125;</span>`</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子为</p>
<p>元素指定了一个 onclick 事件处理程序。当元素被点击时，会显示事件发生时鼠标光标在客户端视口中的坐标。注意客户端坐标不考虑页面滚动，因此这两个值并不代表鼠标在页面上的位置。</p>
<h6 id="页面坐标"><a href="#页面坐标" class="headerlink" title="页面坐标"></a><strong>页面坐标</strong></h6><p>客户端坐标是事件发生时鼠标光标在客户端视口中的坐标，而页面坐标是事件发生时鼠标光标在页面上的坐标，通过 event 对象的 pageX 和 pageY 可以获取。这两个属性表示鼠标光标在页面上的位置，因此反映的是光标到页面而非视口左边与上边的距离。</p>
<p>可以像下面这样取得鼠标事件的页面坐标：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Page coordinates: <span class="subst">$&#123;event.pageX&#125;</span>, <span class="subst">$&#123;event.pageY&#125;</span>`</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在页面没有滚动时，pageX 和 pageY 与 clientX 和 clientY 的值相同。</p>
<p>IE8 及更早版本没有在 event 对象上暴露页面坐标。不过，可以通过客户端坐标和滚动信息计算出来。</p>
<h6 id="屏幕坐标"><a href="#屏幕坐标" class="headerlink" title="屏幕坐标"></a><strong>屏幕坐标</strong></h6><p>鼠标事件不仅是在浏览器窗口中发生的，也是在整个屏幕上发生的。可以通过 event 对象的screenX 和 screenY 属性获取鼠标光标在屏幕上的坐标。</p>
<p>可以像下面这样获取鼠标事件的屏幕坐标：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Screen coordinates: <span class="subst">$&#123;event.screenX&#125;</span>, <span class="subst">$&#123;event.screenY&#125;</span>`</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>与前面的例子类似，这段代码也为</p>
<p>元素指定了 onclick 事件处理程序。当元素被点击时，会通过控制台打印出事件的屏幕坐标。</p>
<h6 id="修饰键"><a href="#修饰键" class="headerlink" title="修饰键"></a><strong>修饰键</strong></h6><p>虽然鼠标事件主要是通过鼠标触发的，但有时候要确定用户想实现的操作，还要考虑键盘按键的状态。键盘上的修饰键 Shift、Ctrl、Alt 和 Meta 经常用于修改鼠标事件的行为。DOM 规定了 4 个属性来表示这几个修饰键的状态：shiftKey、ctrlKey、altKey 和 metaKey。这几属性会在各自对应的修饰键被按下时包含布尔值 true，没有被按下时包含 false。在鼠标事件发生的，可以通过这几个属性来检测修饰键是否被按下。来看下面的例子，其中在 click 事件发生时检测了每个修饰键的状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">shiftKey</span>) &#123;</span><br><span class="line">        keys.<span class="title function_">push</span>(<span class="string">&quot;shift&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">ctrlKey</span>) &#123;</span><br><span class="line">        keys.<span class="title function_">push</span>(<span class="string">&quot;ctrl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">altKey</span>) &#123;</span><br><span class="line">        keys.<span class="title function_">push</span>(<span class="string">&quot;alt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">metaKey</span>) &#123;</span><br><span class="line">        keys.<span class="title function_">push</span>(<span class="string">&quot;meta&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Keys: &quot;</span> + keys.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，onclick 事件处理程序检查了不同修饰键的状态。keys 数组中包含了在事件发生时被按下的修饰键的名称。每个对应属性为 true 的修饰键的名称都会添加到 keys 中。最后，事件处理程序会输出所有键的名称。</p>
<p>注意 现代浏览器支持所有这 4 个修饰键。IE8 及更早版本不支持 metaKey 属性。</p>
<h6 id="相关元素"><a href="#相关元素" class="headerlink" title="相关元素"></a><strong>相关元素</strong></h6><p>对 mouseover 和 mouseout 事件而言，还存在与事件相关的其他元素。这两个事件都涉及从一个元素的边界之内把光标移到另一个元素的边界之内。对 mouseover 事件来说，事件的主要目标是获得光标的元素，相关元素是失去光标的元素。类似地，对 mouseout 事件来说，事件的主要目标是失去光标的元素，而相关元素是获得光标的元素。来看下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Related Elements Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">style</span>=<span class="string">&quot;background-color:red;height:100px;width:100px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个页面中只包含一个元素。如果光标开始在元素上，然后从它上面移出，则元素上会触发 mouseout 事件，相关元素为元素。与此同时，元素上会触发 mouseover事件，相关元素是元素。</p>
<p>DOM通过 event 对象的 relatedTarget 属性提供了相关元素的信息。这个属性只有在 mouseover和 mouseout 事件发生时才包含值，其他所有事件的这个属性的值都是 null。IE8 及更早版本不支持relatedTarget 属性，但提供了其他的可以访问到相关元素的属性。在 mouseover 事件触发时，IE会提供 fromElement 属性，其中包含相关元素。而在 mouseout 事件触发时，IE 会提供 toElement属性，其中包含相关元素。（IE9 支持所有这些属性。）因此，可以在 EventUtil 中增加一个通用的获取相关属性的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">EventUtil</span> = &#123;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">    <span class="attr">getRelatedTarget</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.<span class="property">relatedTarget</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> event.<span class="property">relatedTarget</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.<span class="property">toElement</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> event.<span class="property">toElement</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.<span class="property">fromElement</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> event.<span class="property">fromElement</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与前面介绍的其他跨浏览器方法一样，这个方法同样使用特性检测来确定要返回哪个值。可以像下面这样使用 EventUtil.getRelatedTarget()方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseout&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> target = event.<span class="property">target</span>; </span><br><span class="line"> <span class="keyword">let</span> relatedTarget = <span class="title class_">EventUtil</span>.<span class="title function_">getRelatedTarget</span>(event); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( </span><br><span class="line"> <span class="string">`Moused out of <span class="subst">$&#123;target.tagName&#125;</span> to <span class="subst">$&#123;relatedTarget.tagName&#125;</span>`</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子在</p>
<p>元素上注册了 mouseout 事件处理程序。当事件触发时，就会打印出一条消息说明鼠标从哪个元素移出，移到了哪个元素上。</p>
<h6 id="鼠标按键"><a href="#鼠标按键" class="headerlink" title="鼠标按键"></a><strong>鼠标按键</strong></h6><p>只有在元素上单击鼠标主键（或按下键盘上的回车键）时 click 事件才会触发，因此按键信息并不是必需的。对 mousedown 和 mouseup 事件来说，event 对象上会有一个 button 属性，表示按下或释放的是哪个按键。DOM 为这个 button 属性定义了 3 个值：0 表示鼠标主键、1 表示鼠标中键（通常也是滚轮键）、2 表示鼠标副键。按照惯例，鼠标主键通常是左边的按键，副键通常是右边的按键。</p>
<p>IE8 及更早版本也提供了 button 属性，但这个属性的值与前面说的完全不同：</p>
<ul>
<li> 0，表示没有按下任何键；</li>
<li> 1，表示按下鼠标主键；</li>
<li> 2，表示按下鼠标副键；</li>
<li> 3，表示同时按下鼠标主键、副键；</li>
<li> 4，表示按下鼠标中键；</li>
<li> 5，表示同时按下鼠标主键和中键；</li>
<li> 6，表示同时按下鼠标副键和中键；</li>
<li> 7，表示同时按下 3 个键。</li>
</ul>
<p>很显然，DOM 定义的 button 属性比 IE 这一套更简单也更有用，毕竟同时按多个鼠标键的情况很少见。为此，实践中基本上都以 DOM 的 button 属性为准，这是因为除 IE8 及更早版本外的所有主流浏览器都原生支持。主、中、副键的定义非常明确，而 IE 定义的其他情形都可以翻译为按下其中某个键，而且优先翻译为主键。比如，IE 返回 5 或 7 时，就会对应到 DOM 的 0。</p>
<p><strong>额外事件信息</strong></p>
<p>DOM2 Events 规范在 event 对象上提供了 detail 属性，以给出关于事件的更多信息。对鼠标事件来说，detail 包含一个数值，表示在给定位置上发生了多少次单击。单击相当于在同一个像素上发生一次 mousedown 紧跟一次 mouseup。detail 的值从 1 开始，每次单击会加 1。如果鼠标在 mousedown和 mouseup 之间移动了，则 detail 会重置为 0。</p>
<p>IE 还为每个鼠标事件提供了以下额外信息：</p>
<ul>
<li> altLeft，布尔值，表示是否按下了左 Alt 键（如果 altLeft 是 true，那么 altKey 也是 true）；</li>
<li> ctrlLeft，布尔值，表示是否按下了左 Ctrl 键（如果 ctrlLeft 是 true，那么 ctrlKey 也是true）；</li>
<li> offsetX，光标相对于目标元素边界的 <em>x</em> 坐标；</li>
<li> offsetY，光标相对于目标元素边界的 <em>y</em> 坐标；</li>
<li> shiftLeft，布尔值，表示是否按下了左 Shift 键（如果 shiftLeft 是 true，那么 shiftKey也是 true）。</li>
</ul>
<p>这些属性的作用有限，这是因为只有 IE 支持。而且，它们提供的信息要么没必要，要么可以通过其他方式计算。</p>
<h6 id="mousewheel-事件"><a href="#mousewheel-事件" class="headerlink" title="mousewheel 事件"></a><strong>mousewheel 事件</strong></h6><p>IE6 首先实现了 mousewheel 事件。之后，Opera、Chrome 和 Safari 也跟着实现了。mousewheel事件会在用户使用鼠标滚轮时触发，包括在垂直方向上任意滚动。这个事件会在任何元素上触发，并（在IE8 中）冒泡到 document 和（在所有现代浏览器中）window。mousewheel 事件的 event 对象包含鼠标事件的所有标准信息，此外还有一个名为 wheelDelta 的新属性。当鼠标滚轮向前滚动时，wheelDelta 每次都是+120；而当鼠标滚轮向后滚动时，wheelDelta 每次都是–120</p>
<p>可以为页面上的任何元素或文档添加 onmousewheel 事件处理程序，以处理所有鼠标滚轮交互，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousewheel&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">wheelDelta</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子简单地显示了鼠标滚轮事件触发时 wheelDelta 的值。多数情况下只需知道滚轮滚动的方向，而这通过 wheelDelta 值的符号就可以知道。</p>
<p>注意 HTML5 也增加了 mousewheel 事件，以反映大多数浏览器对它的支持。</p>
<h6 id="触摸屏设备"><a href="#触摸屏设备" class="headerlink" title="触摸屏设备"></a><strong>触摸屏设备</strong></h6><p>iOS 和 Android 等触摸屏设备的实现大相径庭，因为触摸屏通常不支持鼠标操作。在为触摸屏设备开发时，要记住以下事项。</p>
<ul>
<li> 不支持 dblclick 事件。双击浏览器窗口可以放大，但没有办法覆盖这个行为。</li>
<li> 单指点触屏幕上的可点击元素会触发 mousemove 事件。如果操作会导致内容变化，则不会再触发其他事件。如果屏幕上没有变化，则会相继触发 mousedown、mouseup 和 click 事件。点触不可点击的元素不会触发事件。可点击元素是指点击时有默认动作的元素（如链接）或指定了 onclick 事件处理程序的元素。</li>
<li> mousemove 事件也会触发 mouseover 和 mouseout 事件。</li>
<li> 双指点触屏幕并滑动导致页面滚动时会触发 mousewheel 和 scroll 事件。</li>
</ul>
<h6 id="无障碍问题"><a href="#无障碍问题" class="headerlink" title="无障碍问题"></a><strong>无障碍问题</strong></h6><p>如果 Web 应用或网站必须考虑残障人士，特别是使用屏幕阅读器的用户，那么必须小心使用鼠标事件。如前所述，按回车键可以触发 click 事件，但其他鼠标事件不能通过键盘触发。因此，建议不要使用 click 事件之外的其他鼠标事件向用户提示功能或触发代码执行，这是因为其他鼠标事件会严格妨碍盲人或视障用户使用。</p>
<h5 id="17-4-4键盘与输入事件"><a href="#17-4-4键盘与输入事件" class="headerlink" title="17.4.4键盘与输入事件"></a>17.4.4键盘与输入事件</h5><p>键盘事件是用户操作键盘时触发的。DOM2 Events 最初定义了键盘事件，但该规范在最终发布前删除了相应内容。因此，键盘事件很大程度上是基于原始的 DOM0 实现的。</p>
<p>DOM3 Events 为键盘事件提供了一个首先在 IE9 中完全实现的规范。其他浏览器也开始实现该规范，但仍然存在很多遗留的实现。</p>
<p>键盘事件包含 3 个事件：</p>
<ul>
<li> keydown，用户按下键盘上某个键时触发，而且持续按住会重复触发。</li>
<li> keypress，用户按下键盘上某个键并产生字符时触发，而且持续按住会重复触发。Esc 键也会触发这个事件。DOM3 Events 废弃了 keypress 事件，而推荐 textInput 事件。</li>
<li> keyup，用户释放键盘上某个键时触发。</li>
</ul>
<p>虽然所有元素都支持这些事件，但当用户在文本框中输入内容时最容易看到。</p>
<p>输入事件只有一个，即 textInput。这个事件是对 keypress 事件的扩展，用于在文本显示给用户之前更方便地截获文本输入。textInput 会在文本被插入到文本框之前触发。</p>
<p>当用户按下键盘上的某个字符键时，首先会触发 keydown 事件，然后触发 keypress 事件，最后触发 keyup 事件。注意，这里 keydown 和 keypress 事件会在文本框出现变化之前触发，而 keyup事件会在文本框出现变化之后触发。如果一个字符键被按住不放，keydown 和 keypress 就会重复触发，直到这个键被释放。</p>
<p>对于非字符键，在键盘上按一下这个键，会先触发 keydown 事件，然后触发 keyup 事件。如果按住某个非字符键不放，则会重复触发 keydown 事件，直到这个键被释放，此时会触发 keyup 事件。</p>
<h6 id="键码"><a href="#键码" class="headerlink" title="键码"></a><strong>键码</strong></h6><p>对于 keydown 和 keyup 事件，event 对象的 keyCode 属性中会保存一个键码，对应键盘上特定的一个键。对于字母和数字键，keyCode 的值与小写字母和数字的 ASCII 编码一致。比如数字 7 键的keyCode 为 55，而字母 A 键的 keyCode 为 65，而且跟是否按了 Shift 键无关。DOM 和 IE 的 event 对象都支持 keyCode 属性。下面这个例子展示了如何使用 keyCode 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myText&quot;</span>); </span><br><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">keyCode</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子在 keyup 事件触发时直接显示出 event 对象的 keyCode 属性值。书中给出了键盘上所有非字符键的键码（P519页）。</p>
<h6 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a><strong>字符编码</strong></h6><p>keypress 事件发生时，意味着按键会影响屏幕上显示的文本。对插入或移除字符的键，所有浏览器都会触发 keypress 事件，其他键则取决于浏览器。因为 DOM3 Events 规范才刚刚开始实现，所以不同浏览器之间的实现存在显著差异。</p>
<p>浏览器在 event 对象上支持 charCode 属性，只有发生 keypress 事件时这个属性才会被设置值，包含的是按键字符对应的 ASCII 编码。通常，charCode 属性的值是 0，在 keypress 事件发生时则是对应按键的键码。IE8 及更早版本和 Opera 使用 keyCode 传达字符的 ASCII 编码。要以跨浏览器方式获取字符编码，首先要检查 charCode 属性是否有值，如果没有再使用 keyCode，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">EventUtil</span> = &#123; </span><br><span class="line">     <span class="comment">// 其他代码</span></span><br><span class="line">     <span class="attr">getCharCode</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">typeof</span> event.<span class="property">charCode</span> == <span class="string">&quot;number&quot;</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> event.<span class="property">charCode</span>; </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> event.<span class="property">keyCode</span>; </span><br><span class="line">         &#125; </span><br><span class="line">     &#125;, </span><br><span class="line">     <span class="comment">// 其他代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个方法检测 charCode 属性是否为数值（在不支持的浏览器中是 undefined）。如果是数值，则返回。否则，返回 keyCode 值。可以像下面这样使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myText&quot;</span>); </span><br><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;keypress&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">EventUtil</span>.<span class="title function_">getCharCode</span>(event)); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一旦有了字母编码，就可以使用 String.fromCharCode()方法将其转换为实际的字符了。</p>
<h6 id="textInput-事件"><a href="#textInput-事件" class="headerlink" title="textInput 事件"></a><strong>textInput 事件</strong></h6><p>DOM3 Events 规范增加了一个名为 textInput 的事件，其在字符被输入到可编辑区域时触发。作为对 keypress 的替代，textInput 事件的行为有些不一样。一个区别是 keypress 会在任何可以获得焦点的元素上触发，而 textInput 只在可编辑区域上触发。另一个区别是 textInput 只在有新字符被插入时才会触发，而 keypress 对任何可能影响文本的键都会触发（包括退格键）。</p>
<p>因为 textInput 事件主要关注字符，所以在 event 对象上提供了一个 data 属性，包含要插入的字符（不是字符编码）。data 的值始终是要被插入的字符，因此如果在按 S 键时没有按 Shift 键，data的值就是”s”，但在按 S 键时同时按 Shift 键，data 的值则是”S”。</p>
<p>textInput 事件可以这样来用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myText&quot;</span>); </span><br><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;textInput&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子会实时把输入文本框的文本通过日志打印出来。</p>
<p>event 对象上还有一个名为 inputMethod 的属性，该属性表示向控件中输入文本的手段。可能的值如下：</p>
<ul>
<li> 0，表示浏览器不能确定是什么输入手段；</li>
<li> 1，表示键盘；</li>
<li> 2，表示粘贴；</li>
<li> 3，表示拖放操作；</li>
<li> 4，表示 IME；</li>
<li> 5，表示表单选项；</li>
<li> 6，表示手写（如使用手写笔）；</li>
<li> 7，表示语音；</li>
<li> 8，表示组合方式；</li>
<li> 9，表示脚本</li>
</ul>
<p>使用这些属性，可以确定用户是如何将文本输入到控件中的，从而可以辅助验证。</p>
<p><strong>设备上的键盘事件</strong></p>
<p>任天堂 Wii 会在用户按下 Wii 遥控器上的键时触发键盘事件。虽然不能访问 Wii 遥控器上所有的键，但其中一些键可以触发键盘事件。</p>
<h5 id="17-4-5合成事件"><a href="#17-4-5合成事件" class="headerlink" title="17.4.5合成事件"></a>17.4.5合成事件</h5><p>合成事件是 DOM3 Events 中新增的，用于处理通常使用 IME 输入时的复杂输入序列。IME 可以让用户输入物理键盘上没有的字符。例如，使用拉丁字母键盘的用户还可以使用 IME 输入日文。IME 通常需要同时按下多个键才能输入一个字符。合成事件用于检测和控制这种输入。合成事件有以下 3 种：</p>
<ul>
<li> compositionstart，在 IME 的文本合成系统打开时触发，表示输入即将开始；</li>
<li> compositionupdate，在新字符插入输入字段时触发；</li>
<li> compositionend，在 IME 的文本合成系统关闭时触发，表示恢复正常键盘输入。</li>
</ul>
<p>合成事件在很多方面与输入事件很类似。在合成事件触发时，事件目标是接收文本的输入字段。唯一增加的事件属性是 data，其中包含的值视情况而异：</p>
<ul>
<li> 在 compositionstart 事件中，包含正在编辑的文本（例如，已经选择了文本但还没替换）；</li>
<li> 在 compositionupdate 事件中，包含要插入的新字符；</li>
<li> 在 compositionend 事件中，包含本次合成过程中输入的全部内容。</li>
</ul>
<p>与文本事件类似，合成事件可以用来在必要时过滤输入内容。可以像下面这样使用合成事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myText&quot;</span>); </span><br><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;compositionstart&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>); </span><br><span class="line">&#125;); </span><br><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;compositionupdate&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>); </span><br><span class="line">&#125;); </span><br><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;compositionend&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="17-4-7HTML5-事件"><a href="#17-4-7HTML5-事件" class="headerlink" title="17.4.7HTML5 事件"></a>17.4.7HTML5 事件</h5><h6 id="contextmenu-事件"><a href="#contextmenu-事件" class="headerlink" title="contextmenu 事件"></a><strong>contextmenu 事件</strong></h6><p>作用：允许开发者取消默认的上下文菜单并提供自定义菜单</p>
<p>contextmenu 事件冒泡，因此只要给 document 指定一个事件处理程序就可以处理页面上的所有同类事件。事件目标是触发操作的元素。这个事件在所有浏览器中都可以取消，在 DOM 合规的浏览器中使用 event.preventDefault()，在 IE8 及更早版本中将 event.returnValue 设置为 false。contextmenu 事件应该算一种鼠标事件，因此 event 对象上的很多属性都与光标位置有关。通常，自定义的上下文菜单都是通过 oncontextmenu 事件处理程序触发显示，并通过 onclick 事件处理程序触发隐藏的。来看下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>ContextMenu Event Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Right click or Ctrl+click me to get a custom context menu.</span><br><span class="line">    Click anywhere else to get the default context menu.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myMenu&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position:absolute;visibility:hidden;background-color: </span></span></span><br><span class="line"><span class="string"><span class="tag">    silver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.somewhere.com&quot;</span>&gt;</span> somewhere<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.wrox.com&quot;</span>&gt;</span>Wrox site<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.somewhere-else.com&quot;</span>&gt;</span>somewhere-else<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      div.<span class="title function_">addEventListener</span>(<span class="string">&quot;contextmenu&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> menu = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myMenu&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        menu.<span class="property">style</span>.<span class="property">left</span> = event.<span class="property">clientX</span> + <span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        menu.<span class="property">style</span>.<span class="property">top</span> = event.<span class="property">clientY</span> + <span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        menu.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&quot;visible&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myMenu&quot;</span>).<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&quot;hidden&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子中的</p>
<p>元素有一个上下文菜单。作为上下文菜单，元素初始时是隐藏的。这里在元素上指定了一个 oncontextmenu 事件处理程序。这个事件处理程序首先取消默认行，确保不会显示浏览器默认的上下文菜单。接着基于 event 对象的 clientX 和 clientY 属性把元素放到适当位置。最后一步通过将 visibility 属性设置为”visible”让自定义上下文菜单显示出来。另外，又给 document 添加了一个 onclick 事件处理程序，以便在单击事件发生时隐藏上下文菜单（系统上下文菜单就是这样隐藏的）。</p>
<p>虽然这个例子很简单，但它是网页中所有自定义上下文菜单的基础。在这个简单例子的基础上，再添加一些 CSS，上下文菜单就会更漂亮。</p>
<h6 id="beforeunload-事件"><a href="#beforeunload-事件" class="headerlink" title="beforeunload 事件"></a><strong>beforeunload 事件</strong></h6><p>beforeunload 事件会在 window 上触发，用意是给开发者提供阻止页面被卸载的机会。这个事件会在页面即将从浏览器中卸载时触发，如果页面需要继续使用，则可以不被卸载。这个事件不能取消，否则就意味着可以把用户永久阻拦在一个页面上。相反，这个事件会向用户显示一个确认框，其中的消息表明浏览器即将卸载页面，并请用户确认是希望关闭页面，还是继续留在页面上。</p>
<p>需要将 event.returnValue 设置为要在确认框中显示的字符串（对于 IE 和 Firefox 来说），并将其作为函数值返回（对于 Safari 和 Chrome 来说），如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> message = <span class="string">&quot;I&#x27;m really going to miss you if you go.&quot;</span>; </span><br><span class="line"> event.<span class="property">returnValue</span> = message; </span><br><span class="line"> <span class="keyword">return</span> message; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="DOMContentLoaded-事件"><a href="#DOMContentLoaded-事件" class="headerlink" title="DOMContentLoaded 事件"></a><strong>DOMContentLoaded 事件</strong></h6><p>window 的 load 事件会在页面完全加载后触发，因为要等待很多外部资源加载完成，所以会花费较长时间。而 DOMContentLoaded 事件会在 DOM 树构建完成后立即触发，而不用等待图片、JavaScript文件、CSS 文件或其他资源加载完成。相对于 load 事件，DOMContentLoaded 可以让开发者在外部资源下载的同时就能指定事件处理程序，从而让用户能够更快地与页面交互。</p>
<p>要处理 DOMContentLoaded 事件，需要给 document 或 window 添加事件处理程序（实际的事件目标是 document，但会冒泡到 window）。下面是一个在 document 上监听 DOMContentLoaded 事件的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Content loaded&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>DOMContentLoaded 事件的 event 对象中不包含任何额外信息（除了 target 等于 document）。</p>
<p>DOMContentLoaded 事件通常用于添加事件处理程序或执行其他 DOM操作。这个事件始终在 load事件之前触发。</p>
<p>对于不支持 DOMContentLoaded 事件的浏览器，可以使用超时为 0 的 setTimeout()函数，通过其回调来设置事件处理程序，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="comment">// 在这里添加事件处理程序</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码本质上意味着在当前 JavaScript 进程执行完毕后立即执行这个回调。页面加载和构建期间，只有一个 JavaScript 进程运行。所以可以在这个进程空闲后立即执行回调，至于是否与同一个浏览器或同一页面上不同脚本的 DOMContentLoaded 触发时机一致并无绝对把握。为了尽可能早一些执行，以上代码最好是页面上的第一个超时代码。即使如此，考虑到各种影响因素，也不一定保证能在 load 事件之前执行超时回调。</p>
<h6 id="readystatechange-事件"><a href="#readystatechange-事件" class="headerlink" title="readystatechange 事件"></a><strong>readystatechange 事件</strong></h6><p>IE 首先在 DOM 文档的一些地方定义了一个名为 readystatechange 事件。这个有点神秘的事件旨在提供文档或元素加载状态的信息，但行为有时候并不稳定。支持 readystatechange 事件的每个对象都有一个 readyState 属性，该属性具有一个以下列出的可能的字符串值。</p>
<ul>
<li> uninitialized：对象存在并尚未初始化。</li>
<li> loading：对象正在加载数据。</li>
<li> loaded：对象已经加载完数据。</li>
<li> interactive：对象可以交互，但尚未加载完成。</li>
<li> complete：对象加载完成。</li>
</ul>
<p>看起来很简单，其实并非所有对象都会经历所有 readystate 阶段。文档中说有些对象会完全跳过某个阶段，但并未说明哪些阶段适用于哪些对象。这意味着 readystatechange 事件经常会触发不到4 次，而 readyState 未必会依次呈现上述值。</p>
<p>在 document 上使用时，值为”interactive”的 readyState 首先会触发 readystatechange事件，时机类似于 DOMContentLoaded。进入交互阶段，意味着 DOM 树已加载完成，因而可以安全地交互了。此时图片和其他外部资源不一定都加载完了。可以像下面这样使用 readystatechange 事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;readystatechange&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">     <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> == <span class="string">&quot;interactive&quot;</span>) &#123; </span><br><span class="line">     	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Content loaded&quot;</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个事件的 event 对象中没有任何额外的信息，连事件目标都不会设置</p>
<p>让问题变得更加复杂的是，交互阶段与完成阶段的顺序也不是固定的。在外部资源较多的页面中，很可能交互阶段会早于完成阶段，而在外部资源较少的页面中，很可能完成阶段会早于交互阶段。因此，实践中为了抢到较早的时机，需要同时检测交互阶段和完成阶段。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;readystatechange&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">     <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> == <span class="string">&quot;interactive&quot;</span> || </span><br><span class="line">     	<span class="variable language_">document</span>.<span class="property">readyState</span> == <span class="string">&quot;complete&quot;</span>) &#123; </span><br><span class="line">         <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;readystatechange&quot;</span>, <span class="variable language_">arguments</span>.<span class="property">callee</span>); </span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Content loaded&quot;</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当 readystatechange 事件触发时，这段代码会检测 document.readyState 属性，以确定当前是不是交互或完成状态。如果是，则移除事件处理程序，以保证其他阶段不再执行。注意，因为这里的事件处理程序是匿名函数，所以使用了 arguments.callee 作为函数指针。然后，又打印出一条表示内容已加载的消息。这样的逻辑可以保证尽可能接近使用 DOMContentLoaded 事件的效果。</p>
<h6 id="pageshow-与-pagehide-事件"><a href="#pageshow-与-pagehide-事件" class="headerlink" title="pageshow 与 pagehide 事件"></a><strong>pageshow 与 pagehide 事件</strong></h6><p>Firefox 和 Opera 开发了一个名为往返缓存（bfcache，back-forward cache）的功能，此功能旨在使用浏览器“前进”和“后退”按钮时加快页面之间的切换。这个缓存不仅存储页面数据，也存储 DOM 和JavaScript 状态，实际上是把整个页面都保存在内存里。如果页面在缓存中，那么导航到这个页面时就不会触发 load 事件。通常，这不会导致什么问题，因为整个页面状态都被保存起来了。不过，Firefx决定提供一些事件，把往返缓存的行为暴露出来。</p>
<p>第一个事件是 pageshow，其会在页面显示时触发，无论是否来自往返缓存。在新加载的页面上，pageshow 会在 load 事件之后触发；在来自往返缓存的页面上，pageshow 会在页面状态完全恢复后触发。注意，虽然这个事件的目标是 document，但事件处理程序必须添加到 window 上。下面的例子展示了追踪这些事件的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="keyword">let</span> showCount = <span class="number">0</span>; </span><br><span class="line">     <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">     	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Load fired&quot;</span>); </span><br><span class="line">     &#125;); </span><br><span class="line">     <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;pageshow&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    	 showCount++; </span><br><span class="line">     	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Show has been fired <span class="subst">$&#123;showCount&#125;</span> times.`</span>); </span><br><span class="line">     &#125;); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>这个例子使用了私有作用域来保证 showCount 变量不进入全局作用域。在页面首次加载时，showCount 的值为 0。之后每次触发 pageshow 事件，showCount 都会加 1 并输出消息。如果从包含以上代码的页面跳走，然后又点击“后退”按钮返回以恢复它，就能够每次都看到 showCount 递增的值。这是因为变量的状态连同整个页面状态都保存在了内存中，导航回来后可以恢复。如果是点击了浏览器的“刷新”按钮，则 showCount 的值会重置为 0，因为页面会重新加载。</p>
<p>除了常用的属性，pageshow 的 event 对象中还包含一个名为 persisted 的属性。这个属性是一个布尔值，如果页面存储在了往返缓存中就是 true，否则就是 false。可以像下面这样在事件处理程序中检测这个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="keyword">let</span> showCount = <span class="number">0</span>; </span><br><span class="line">     <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">     	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Load fired&quot;</span>); </span><br><span class="line">     &#125;); </span><br><span class="line">     <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;pageshow&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">     	showCount++; </span><br><span class="line">     	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Show has been fired <span class="subst">$&#123;showCount&#125;</span> times.`</span>, </span><br><span class="line">    	 <span class="string">`Persisted? <span class="subst">$&#123;event.persisted&#125;</span>`</span>); </span><br><span class="line">     &#125;); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>与 pageshow 对应的事件是 pagehide，这个事件会在页面从浏览器中卸载后，在 unload 事件之前触发。与 pageshow 事件一样，pagehide 事件同样是在 document 上触发，但事件处理程序必须被添加到 window。event 对象中同样包含 persisted 属性，但用法稍有不同。比如，以下代码检测了event.persisted 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;pagehide&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hiding. Persisted? &quot;</span> + event.<span class="property">persisted</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样，当 pagehide 事件触发时，也许可以根据 persisted 属性的值来采取一些不同的操作。对pageshow 事件来说，persisted 为 true 表示页面是从往返缓存中加载的；而对 pagehide 事件来说，persisted 为 true 表示页面在卸载之后会被保存在往返缓存中。因此，第一次触发 pageshow 事件时 persisted 始终是 false，而第一次触发 pagehide 事件时 persisted 始终是 true（除非页面不符合使用往返缓存的条件）。</p>
<h6 id="hashchange-事件"><a href="#hashchange-事件" class="headerlink" title="hashchange 事件"></a><strong>hashchange 事件</strong></h6><p>HTML5 增加了 hashchange 事件，用于在 URL 散列值（URL 最后#后面的部分）发生变化时通知开发者。这是因为开发者经常在 Ajax 应用程序中使用 URL 散列值存储状态信息或路由导航信息。</p>
<p>onhashchange 事件处理程序必须添加给 window，每次 URL 散列值发生变化时会调用它。event对象有两个新属性：oldURL 和 newURL。这两个属性分别保存变化前后的 URL，而且是包含散列值的完整 URL。下面的例子展示了如何获取变化前后的 URL：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;hashchange&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Old URL: <span class="subst">$&#123;event.oldURL&#125;</span>, New URL: <span class="subst">$&#123;event.newURL&#125;</span>`</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果想确定当前的散列值，最好使用 location 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;hashchange&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Current hash: <span class="subst">$&#123;location.hash&#125;</span>`</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="17-4-8设备事件"><a href="#17-4-8设备事件" class="headerlink" title="17.4.8设备事件"></a>17.4.8设备事件</h5><h6 id="orientationchange-事件"><a href="#orientationchange-事件" class="headerlink" title="orientationchange 事件"></a><strong>orientationchange 事件</strong></h6><p>苹果公司在移动 Safari 浏览器上创造了 orientationchange 事件，以方便开发者判断用户的设备是处于垂直模式还是水平模式。移动 Safari 在 window 上暴露了 window.orientation 属性，它有以下 3 种值之一：0 表示垂直模式，90 表示左转水平模式（主屏幕键在右侧），–90 表示右转水平模式（主屏幕键在左）。虽然相关文档也提及设备倒置后的值为 180，但设备本身至今还不支持。</p>
<p>每当用户旋转设备改变了模式，就会触发 orientationchange 事件。但 event 对象上没有暴露任何有用的信息，这是因为相关信息都可以从 window.orientation 属性中获取。以下是这个事件典型的用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">     <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">     div.<span class="property">innerHTML</span> = <span class="string">&quot;Current orientation is &quot;</span> + <span class="variable language_">window</span>.<span class="property">orientation</span>; </span><br><span class="line">     <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;orientationchange&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">     	div.<span class="property">innerHTML</span> = <span class="string">&quot;Current orientation is &quot;</span> + <span class="variable language_">window</span>.<span class="property">orientation</span>; </span><br><span class="line">     &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子会在 load 事件触发时显示设备初始的朝向。然后，又指定了 orientationchange 事件处理程序。此后，只要这个事件触发，页面就会更新以显示新的朝向信息。</p>
<p>所有 iOS 设备都支持 orientationchange 事件和 window.orientation 属性。</p>
<p>注意 因为 orientationchange 事件被认为是 window 事件，所以也可以通过给元素添加 onorientationchange 属性来指定事件处理程序。</p>
<h6 id="deviceorientation-事件"><a href="#deviceorientation-事件" class="headerlink" title="deviceorientation 事件"></a><strong>deviceorientation 事件</strong></h6><p>deviceorientation 是DeviceOrientationEvent规范定义的事件。如果可以获取设备的加速计信息，而且数据发生了变化，这个事件就会在 window 上触发。要注意的是，deviceorientation 事件只反映设备在空间中的朝向，而不涉及移动相关的信息。</p>
<p>设备本身处于 3D 空间即拥有 <em>x</em> 轴、<em>y</em> 轴和 <em>z</em> 轴的坐标系中。如果把设备静止放在水平的表面上，那么三轴的值均为 0，其中，<em>x</em> 轴方向为从设备左侧到右侧，<em>y</em> 轴方向为从设备底部到上部，<em>z</em> 轴方向为从设备背面到正面，</p>
<p>当 deviceorientation 触发时，event 对象中会包含各个轴相对于设备静置时坐标值的变化，主要是以下 5 个属性。</p>
<ul>
<li> alpha：0~360 范围内的浮点值，表示围绕 <em>z</em> 轴旋转时 <em>y</em> 轴的度数（左右转）。</li>
<li> beta：–180~180 范围内的浮点值，表示围绕 <em>x</em> 轴旋转时 <em>z</em> 轴的度数（前后转）。</li>
<li> gamma：–90~90 范围内的浮点值，表示围绕 <em>y</em> 轴旋转时 <em>z</em> 轴的度数（扭转）。</li>
<li> absolute：布尔值，表示设备是否返回绝对值。</li>
<li> compassCalibrated：布尔值，表示设备的指南针是否正确校准。</li>
</ul>
<p>下面是一个输出 alpha、beta 和 gamma 值的简单例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;deviceorientation&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;output&quot;</span>); </span><br><span class="line"> output.<span class="property">innerHTML</span> = </span><br><span class="line"> <span class="string">`Alpha=<span class="subst">$&#123;event.alpha&#125;</span>, Beta=<span class="subst">$&#123;event.beta&#125;</span>, Gamma=<span class="subst">$&#123;event.gamma&#125;</span>&lt;br&gt;`</span>; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>基于这些信息，可以随着设备朝向的变化重新组织或修改屏幕上显示的元素。例如，以下代码会随着朝向变化旋转一个元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;deviceorientation&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> arrow = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;arrow&quot;</span>); </span><br><span class="line"> arrow.<span class="property">style</span>.<span class="property">webkitTransform</span> = <span class="string">`rotate(<span class="subst">$&#123;<span class="built_in">Math</span>.round(event.alpha)&#125;</span>deg)`</span>; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子只适用于移动 WebKit 浏览器，因为使用的是专有的 webkitTransform 属性（CSS 标准的 transform 属性的临时版本）。“箭头”（arrow）元素会随着 event.alpha 值的变化而变化，呈现出指南针的样子。这里给 CSS3 旋转变形函数传入了四舍五入后的值，以确保平顺。</p>
<h6 id="devicemotion-事件"><a href="#devicemotion-事件" class="headerlink" title="devicemotion 事件"></a><strong>devicemotion 事件</strong></h6><p>DeviceOrientationEvent 规范也定义了 devicemotion 事件。这个事件用于提示设备实际上在移动，而不仅仅是改变了朝向。例如，devicemotion 事件可以用来确定设备正在掉落或者正拿在一个行走的人手里。</p>
<p>当 devicemotion 事件触发时，event 对象中包含如下额外的属性。</p>
<ul>
<li> acceleration：对象，包含 x、y 和 z 属性，反映不考虑重力情况下各个维度的加速信息。</li>
<li> accelerationIncludingGravity：对象，包含 x、y 和 z 属性，反映各个维度的加速信息，包含 <em>z</em> 轴自然重力加速度。</li>
<li> interval：毫秒，距离下次触发 devicemotion 事件的时间。此值在事件之间应为常量。</li>
<li> rotationRate：对象，包含 alpha、beta 和 gamma 属性，表示设备朝向。</li>
</ul>
<p>如果无法提供 acceleration、accelerationIncludingGravity 和 rotationRate 信息，则属性值为 null。为此，在使用这些属性前必须先检测它们的值是否为 null。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;devicemotion&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;output&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">rotationRate</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        output.<span class="property">innerHTML</span> += <span class="string">`Alpha=<span class="subst">$&#123;event.rotationRate.alpha&#125;</span>`</span> +</span><br><span class="line">            <span class="string">`Beta=<span class="subst">$&#123;event.rotationRate.beta&#125;</span>`</span> +</span><br><span class="line">            <span class="string">`Gamma=<span class="subst">$&#123;event.rotationRate.gamma&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="17-4-9触摸及手势事件"><a href="#17-4-9触摸及手势事件" class="headerlink" title="17.4.9触摸及手势事件"></a>17.4.9触摸及手势事件</h5><h6 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a><strong>触摸事件</strong></h6><p>当手指放在屏幕上、在屏幕上滑动或从屏幕移开时，触摸事件即会触发。触摸事件有如下几种。</p>
<ul>
<li> touchstart：手指放到屏幕上时触发（即使有一个手指已经放在了屏幕上）。</li>
<li> touchmove：手指在屏幕上滑动时连续触发。在这个事件中调用 preventDefault()可以阻止滚动。</li>
<li> touchend：手指从屏幕上移开时触发。</li>
<li> touchcancel：系统停止跟踪触摸时触发。文档中并未明确什么情况下停止跟踪。</li>
</ul>
<p>这些事件都会冒泡，也都可以被取消。尽管触摸事件不属于 DOM 规范，但浏览器仍然以兼容 DOM的方式实现了它们。因此，每个触摸事件的 event 对象都提供了鼠标事件的公共属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey 和 metaKey。</p>
<p>除了这些公共的 DOM 属性，触摸事件还提供了以下 3 个属性用于跟踪触点</p>
<ul>
<li> touches：Touch 对象的数组，表示当前屏幕上的每个触点。</li>
<li> targetTouches：Touch 对象的数组，表示特定于事件目标的触点。</li>
<li> changedTouches：Touch 对象的数组，表示自上次用户动作之后变化的触点。</li>
</ul>
<p>每个 Touch 对象都包含下列属性。</p>
<ul>
<li> clientX：触点在视口中的 <em>x</em> 坐标。</li>
<li> clientY：触点在视口中的 <em>y</em> 坐标。</li>
<li> identifier：触点 ID。</li>
<li> pageX：触点在页面上的 <em>x</em> 坐标。</li>
<li> pageY：触点在页面上的 <em>y</em> 坐标。</li>
<li> screenX：触点在屏幕上的 <em>x</em> 坐标。</li>
<li> screenY：触点在屏幕上的 <em>y</em> 坐标。</li>
<li> target：触摸事件的事件目标。</li>
</ul>
<p>这些属性可用于追踪屏幕上的触摸轨迹。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleTouchEvent</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 只针对一个触点</span></span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">touches</span>.<span class="property">length</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;output&quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span> (event.<span class="property">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;touchstart&quot;</span>:</span><br><span class="line">                output.<span class="property">innerHTML</span> += <span class="string">`&lt;br&gt;Touch started:`</span> +</span><br><span class="line">                    <span class="string">`(<span class="subst">$&#123;event.touches[<span class="number">0</span>].clientX&#125;</span>`</span> +</span><br><span class="line">                    <span class="string">` <span class="subst">$&#123;event.touches[<span class="number">0</span>].clientY&#125;</span>)`</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;touchend&quot;</span>:</span><br><span class="line">                output.<span class="property">innerHTML</span> += <span class="string">`&lt;br&gt;Touch ended:`</span> +</span><br><span class="line">                    <span class="string">`(<span class="subst">$&#123;event.changedTouches[<span class="number">0</span>].clientX&#125;</span>`</span> +</span><br><span class="line">                    <span class="string">` <span class="subst">$&#123;event.changedTouches[<span class="number">0</span>].clientY&#125;</span>)`</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;touchmove&quot;</span>:</span><br><span class="line">                event.<span class="title function_">preventDefault</span>(); <span class="comment">// 阻止滚动</span></span><br><span class="line">                output.<span class="property">innerHTML</span> += <span class="string">`&lt;br&gt;Touch moved:`</span> +</span><br><span class="line">                    <span class="string">`(<span class="subst">$&#123;event.changedTouches[<span class="number">0</span>].clientX&#125;</span>`</span> +</span><br><span class="line">                    <span class="string">` <span class="subst">$&#123;event.changedTouches[<span class="number">0</span>].clientY&#125;</span>)`</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;touchstart&quot;</span>, handleTouchEvent);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;touchend&quot;</span>, handleTouchEvent);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;touchmove&quot;</span>, handleTouchEvent);</span><br></pre></td></tr></table></figure>

<p>以上代码会追踪屏幕上的一个触点。为简单起见，代码只会在屏幕有一个触点时输出信息。在touchstart 事件触发时，触点的位置信息会输出到 output 元素中。在 touchmove 事件触发时，会取消默认行为以阻止滚动（移动触点通常会滚动页面），并输出变化的触点信息。在 touchend 事件触发时，会输出触点最后的信息。注意，touchend 事件触发时 touches 集合中什么也没有，这是因为没有滚动的触点了。此时必须使用 changedTouches 集合。</p>
<p>这些事件会在文档的所有元素上触发，因此可以分别控制页面的不同部分。当手指点触屏幕上的元素时，依次会发生如下事件（包括鼠标事件）：</p>
<ul>
<li>(1) touchstart</li>
<li>(2) mouseover</li>
<li>(3) mousemove（1 次）</li>
<li>(4) mousedown</li>
<li>(5) mouseup</li>
<li>(6) click</li>
<li>(7) touchend</li>
</ul>
<h6 id="手势事件"><a href="#手势事件" class="headerlink" title="手势事件"></a><strong>手势事件</strong></h6><p>手势事件会在两个手指触碰屏幕且相对距离或旋转角度变化时触发。手势事件有以下 3 种。</p>
<ul>
<li> gesturestart：一个手指已经放在屏幕上，再把另一个手指放到屏幕上时触发。</li>
<li> gesturechange：任何一个手指在屏幕上的位置发生变化时触发。</li>
<li> gestureend：其中一个手指离开屏幕时触发。</li>
</ul>
<p>只有在两个手指同时接触事件接收者时，这些事件才会触发。在一个元素上设置事件处理程序，意味着两个手指必须都在元素边界以内才能触发手势事件（这个元素就是事件目标）。因为这些事件会冒泡，所以也可以把事件处理程序放到文档级别，从而可以处理所有手势事件。使用这种方式时，事件的目标就是两个手指均位于其边界内的元素。</p>
<p>触摸事件和手势事件存在一定的关系。当一个手指放在屏幕上时，会触发 touchstart 事件。当另一个手指放到屏幕上时，gesturestart 事件会首先触发，然后紧接着触发这个手指的 touchstart事件。如果两个手指或其中一个手指移动，则会触发 gesturechange 事件。只要其中一个手指离开屏幕，就会触发 gestureend 事件，紧接着触发该手指的 touchend 事件。</p>
<p>与触摸事件类似，每个手势事件的 event 对象都包含所有标准的鼠标事件属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey 和 metaKey。新增的两个 event 对象属性是 rotation 和 scale。rotation 属性表示手指变化旋转的度数，负值表示逆时针旋转，正值表示顺时针旋转（从 0 开始）。scale 属性表示两指之间距离变化（对捏）的程度。开始时为 1，然后随着距离增大或缩小相应地增大或缩小。</p>
<p>可以像下面这样使用手势事件的属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleGestureEvent</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;output&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (event.<span class="property">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;gesturestart&quot;</span>:</span><br><span class="line">            output.<span class="property">innerHTML</span> += <span class="string">`Gesture started: `</span> +</span><br><span class="line">                <span class="string">`rotation=<span class="subst">$&#123;event.rotation&#125;</span>,`</span> +</span><br><span class="line">                <span class="string">`scale=<span class="subst">$&#123;event.scale&#125;</span>`</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;gestureend&quot;</span>:</span><br><span class="line">            output.<span class="property">innerHTML</span> += <span class="string">`Gesture ended: `</span> +</span><br><span class="line">                <span class="string">`rotation=<span class="subst">$&#123;event.rotation&#125;</span>,`</span> +</span><br><span class="line">                <span class="string">`scale=<span class="subst">$&#123;event.scale&#125;</span>`</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;gesturechange&quot;</span>:</span><br><span class="line">            output.<span class="property">innerHTML</span> += <span class="string">`Gesture changed: `</span> +</span><br><span class="line">                <span class="string">`rotation=<span class="subst">$&#123;event.rotation&#125;</span>,`</span> +</span><br><span class="line">                <span class="string">`scale=<span class="subst">$&#123;event.scale&#125;</span>`</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;gesturestart&quot;</span>, handleGestureEvent, <span class="literal">false</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;gestureend&quot;</span>, handleGestureEvent, <span class="literal">false</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;gesturechange&quot;</span>, handleGestureEvent, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>与触摸事件的例子一样，以上代码简单地将每个事件对应到一个处理函数，然后输出每个事件的信息</p>
<p>注意 触摸事件也会返回 rotation 和 scale 属性，但只在两个手指触碰屏幕时才会变化。一般来说，使用两个手指的手势事件比考虑所有交互的触摸事件使用起来更容易一些。</p>
<h6 id="富文本编辑"><a href="#富文本编辑" class="headerlink" title="富文本编辑"></a><strong>富文本编辑</strong></h6><p>富文本编辑在现在的开发中是一个常用的需求。咱们大多数时候都会通过一些 富文本的库来去实现这个功能。</p>
<p>作者在书中介绍了一些 富文本编辑的底层实现逻辑，咱们一起来看一下。</p>
<p>富文本实现的基本技术就是：在空白 <code>HTML</code> 文件中嵌入一个 <code>iframe</code>。</p>
<p>通过 <code>designMode</code> 属性，可以将这个空白文档变成可以编辑的，实际编辑的则是<code>&lt;body&gt;</code>元素的 <code>HTML</code>。</p>
<p><code>designMode</code> 属性有两个可能的值：<code>&quot;off&quot;</code>（默认值）和<code>&quot;on&quot;</code>。</p>
<p>设置为<code>&quot;on&quot;</code>时，整个文档都会变成可以编辑的（显示插入光标），从而可以像使用文字处理程序一样编辑文本，通过键盘将文本标记为粗体、斜体，等等。</p>
<h4 id="17-5内存与性能"><a href="#17-5内存与性能" class="headerlink" title="17.5内存与性能"></a>17.5内存与性能</h4><h5 id="17-5-1事件委托"><a href="#17-5-1事件委托" class="headerlink" title="17.5.1事件委托"></a>17.5.1事件委托</h5><p>“过多事件处理程序”的解决方案是使用事件委托。事件委托利用事件冒泡，可以只使用一个事件处理程序来管理一种类型的事件。</p>
<p>例如，click 事件冒泡到 document。这意味着可以为整个页面指定一个 onclick 事件处理程序，而不用为每个可点击元素分别指定事件处理程序。比如有以下 HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myLinks&quot;</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;goSomewhere&quot;</span>&gt;</span>Go somewhere<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;sayHi&quot;</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 HTML 包含 3 个列表项，在被点击时应该执行某个操作。对此，通常的做法是像这样指定 3个事件处理程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> item1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;goSomewhere&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> item2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;doSomething&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> item3 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;sayHi&quot;</span>); </span><br><span class="line">item1.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> location.<span class="property">href</span> = <span class="string">&quot;http:// www.wrox.com&quot;</span>; </span><br><span class="line">&#125;); </span><br><span class="line">item2.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&quot;I changed the document&#x27;s title&quot;</span>; </span><br><span class="line">&#125;); </span><br><span class="line">item3.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果对页面中所有需要使用 onclick 事件处理程序的元素都如法炮制，结果就会出现大片雷同的只为指定事件处理程序的代码。使用事件委托，只要给所有元素共同的祖先节点添加一个事件处理程序，就可以解决问题。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myLinks&quot;</span>);</span><br><span class="line">list.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> target = event.<span class="property">target</span>;</span><br><span class="line">    <span class="keyword">switch</span> (target.<span class="property">id</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;doSomething&quot;</span>:</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&quot;I changed the document&#x27;s title&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;goSomewhere&quot;</span>:</span><br><span class="line">            location.<span class="property">href</span> = <span class="string">&quot;http:// www.wrox.com&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;sayHi&quot;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里只给元素添加了一个 onclick 事件处理程序。因为所有列表项都是这个元素的后代，所以它们的事件会向上冒泡，最终都会由这个函数来处理。但事件目标是每个被点击的列表项，只要检查 event 对象的 id 属性就可以确定，然后再执行相应的操作即可。相对于前面不使用事件委托的代码，这里的代码不会导致先期延迟，因为只访问了一个 DOM 元素和添加了一个事件处理程序。结果对用户来说没有区别，但这种方式占用内存更少。所有使用按钮的事件（大多数鼠标事件和键盘事件）都适用于这个解决方案。</p>
<p>只要可行，就应该考虑只给 document 添加一个事件处理程序，通过它处理页面中所有某种类型的事件。相对于之前的技术，事件委托具有如下优点。</p>
<ul>
<li> document 对象随时可用，任何时候都可以给它添加事件处理程序（不用等待 DOMContentLoaded或 load 事件）。这意味着只要页面渲染出可点击的元素，就可以无延迟地起作用。</li>
<li> 节省花在设置页面事件处理程序上的时间。只指定一个事件处理程序既可以节省 DOM 引用，也可以节省时间。</li>
<li> 减少整个页面所需的内存，提升整体性能。</li>
</ul>
<p>最适合使用事件委托的事件包括：click、mousedown、mouseup、keydown 和 keypress。</p>
<p>mouseover 和 mouseout 事件冒泡，但很难适当处理，且经常需要计算元素位置（因为 mouseout 会在光标从一个元素移动到它的一个后代节点以及移出元素之外时触发）。</p>
<h5 id="17-5-2删除事件处理程序"><a href="#17-5-2删除事件处理程序" class="headerlink" title="17.5.2删除事件处理程序"></a>17.5.2删除事件处理程序</h5><p>把事件处理程序指定给元素后，在浏览器代码和负责页面交互的 JavaScript 代码之间就建立了联系。这种联系建立得越多，页面性能就越差。除了通过事件委托来限制这种连接之外，还应该及时删除不用的事件处理程序。很多 Web 应用性能不佳都是由于无用的事件处理程序长驻内存导致的。</p>
<p>导致这个问题的原因主要有两个。第一个是删除带有事件处理程序的元素。比如通过真正的 DOM方法 removeChild()或 replaceChild()删除节点。最常见的还是使用 innerHTML 整体替换页面的某一部分。这时候，被 innerHTML 删除的元素上如果有事件处理程序，就不会被垃圾收集程序正常清理。比如下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span> </span><br><span class="line"> 	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myBtn&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span></span><br><span class="line"><span class="language-javascript">     btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span></span><br><span class="line"><span class="language-javascript">    	 <span class="comment">// 执行操作</span></span></span><br><span class="line"><span class="language-javascript">     	<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;Processing...&quot;</span>; </span></span><br><span class="line"><span class="language-javascript">     	<span class="comment">// 不好！</span></span></span><br><span class="line"><span class="language-javascript">     &#125;; </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的按钮在元素中。单击按钮，会将自己删除并替换为一条消息，以阻止双击发生。这是很多网站上常见的做法。问题在于，按钮被删除之后仍然关联着一个事件处理程序。在元素上设置 innerHTML 会完全删除按钮，但事件处理程序仍然挂在按钮上面。某些浏览器，特别是 IE8 及更早版本，在这时候就会有问题了。很有可能元素的引用和事件处理程序的引用都会残留在内存中。如果知道某个元素会被删除，那么最好在删除它之前手工删除它的事件处理程序，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myBtn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 执行操作</span></span></span><br><span class="line"><span class="language-javascript">    btn.<span class="property">onclick</span> = <span class="literal">null</span>; <span class="comment">// 删除事件处理程序</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;Processing...&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;; </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个重写后的例子中，设置元素的 innerHTML 属性之前，按钮的事件处理程序先被删除了。这样就可以确保内存被回收，按钮也可以安全地从 DOM 中删掉。</p>
<p>但也要注意，在事件处理程序中删除按钮会阻止事件冒泡。只有事件目标仍然存在于文档中时，事件才会冒泡。</p>
<p>注意 事件委托也有助于解决这种问题。如果提前知道页面某一部分会被使用innerHTML删除，就不要直接给该部分中的元素添加事件处理程序了。把事件处理程序添加到更高层级的节点上同样可以处理该区域的事件。</p>
<p>另一个可能导致内存中残留引用的问题是页面卸载。同样，IE8 及更早版本在这种情况下有很多问题，不过好像所有浏览器都会受这个问题影响。如果在页面卸载后事件处理程序没有被清理，则它们仍然会残留在内存中。之后，浏览器每次加载和卸载页面（比如通过前进、后退或刷新），内存中残留对象的数量都会增加，这是因为事件处理程序不会被回收。</p>
<p>一般来说，最好在 onunload 事件处理程序中趁页面尚未卸载先删除所有事件处理程序。这时候也能体现使用事件委托的优势，因为事件处理程序很少，所以很容易记住要删除哪些。关于卸载页面时的清理，可以记住一点：onload 事件处理程序中做了什么，最好在 onunload 事件处理程序中恢复。</p>
<h4 id="17-6模拟事件"><a href="#17-6模拟事件" class="headerlink" title="17.6模拟事件"></a>17.6模拟事件</h4><h5 id="17-6-1DOM-事件模拟"><a href="#17-6-1DOM-事件模拟" class="headerlink" title="17.6.1DOM 事件模拟"></a>17.6.1DOM 事件模拟</h5><p>任何时候，都可以使用 document.createEvent()方法创建一个 event 对象。这个方法接收一个参数，此参数是一个表示要创建事件类型的字符串。</p>
<ul>
<li> “UIEvents”（DOM3 中是”UIEvent”）：通用用户界面事件（鼠标事件和键盘事件都继承自这个事件）。</li>
<li> “MouseEvents”（DOM3 中是”MouseEvent”）：通用鼠标事件。</li>
<li> “HTMLEvents”（DOM3 中没有）：通用 HTML 事件（HTML 事件已经分散到了其他事件大类中）。</li>
</ul>
<p>触发事件需要调用：使用 dispatchEvent()方法，这个方法存在于所有支持事件的 DOM 节点之上。dispatchEvent()方法接收一个参数，即表示要触发事件的 event 对象。调用 dispatchEvent()方法之后，事件就“转正”了，接着便冒泡并触发事件处理程序执行。</p>
<h6 id="模拟鼠标事件"><a href="#模拟鼠标事件" class="headerlink" title="模拟鼠标事件"></a><strong>模拟鼠标事件</strong></h6><p>模拟鼠标事件需要先创建一个新的鼠标 event 对象，然后再使用必要的信息对其进行初始化。要创建鼠标 event 对象，可以调用 createEvent()方法并传入”MouseEvents”参数。这样就会返回一个 event 对象，这个对象有一个 initMouseEvent()方法，用于为新对象指定鼠标的特定信息。</p>
<p>initMouseEvent()方法接收 15 个参数，分别对应鼠标事件会暴露的属性。这些参数列举如下。</p>
<ul>
<li> type（字符串）：要触发的事件类型，如”click”。</li>
<li> bubbles（布尔值）：表示事件是否冒泡。为精确模拟鼠标事件，应该设置为 true。</li>
<li> cancelable（布尔值）：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为 true。</li>
<li> view（AbstractView）：与事件关联的视图。基本上始终是 document.defaultView。</li>
<li> detail（整数）：关于事件的额外信息。只被事件处理程序使用，通常为 0。</li>
<li> screenX（整数）：事件相对于屏幕的 <em>x</em> 坐标。</li>
<li> screenY（整数）：事件相对于屏幕的 <em>y</em> 坐标。</li>
<li> clientX（整数）：事件相对于视口的 <em>x</em> 坐标。</li>
<li> clientY（整数）：事件相对于视口的 <em>y</em> 坐标。</li>
<li> ctrlkey（布尔值）：表示是否按下了 Ctrl 键。默认为 false。</li>
<li> altkey（布尔值）：表示是否按下了 Alt 键。默认为 false。</li>
<li> shiftkey（布尔值）：表示是否按下了 Shift 键。默认为 false。</li>
<li> metakey（布尔值）：表示是否按下了 Meta 键。默认为 false。</li>
<li> button（整数）：表示按下了哪个按钮。默认为 0。</li>
<li> relatedTarget（对象）：与事件相关的对象。只在模拟 mouseover 和 mouseout 时使用。</li>
</ul>
<p>显然，initMouseEvent()方法的这些参数与鼠标事件的 event 对象属性是一一对应的。前 4 个参数是正确模拟事件唯一重要的几个参数，这是因为它们是浏览器要用的，其他参数则是事件处理程序要用的。event 对象的 target 属性会自动设置为调用 dispatchEvent()方法时传入的节点。下面来看一个使用默认值模拟单击事件的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line"><span class="comment">// 创建 event 对象</span></span><br><span class="line"><span class="keyword">let</span> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;MouseEvents&quot;</span>); </span><br><span class="line"><span class="comment">// 初始化 event 对象</span></span><br><span class="line">event.<span class="title function_">initMouseEvent</span>(<span class="string">&quot;click&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="variable language_">document</span>.<span class="property">defaultView</span>, </span><br><span class="line"> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>); </span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">btn.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>

<p>所有鼠标事件，包括 dblclick 都可以像这样在 DOM 合规的浏览器中模拟出来。</p>
<h6 id="模拟键盘事件"><a href="#模拟键盘事件" class="headerlink" title="模拟键盘事件"></a><strong>模拟键盘事件</strong></h6><p>在 DOM3 中创建键盘事件的方式是给 createEvent()方法传入参数”KeyboardEvent”。这样会返回一个 event 对象，这个对象有一个 initKeyboardEvent()方法。这个方法接收以下参数。</p>
<ul>
<li> type（字符串）：要触发的事件类型，如”keydown”。</li>
<li> bubbles（布尔值）：表示事件是否冒泡。为精确模拟键盘事件，应该设置为 true。</li>
<li> cancelable（布尔值）：表示事件是否可以取消。为精确模拟键盘事件，应该设置为 true。</li>
<li> view（AbstractView）：与事件关联的视图。基本上始终是 document.defaultView。</li>
<li> key（字符串）：按下按键的字符串代码。</li>
<li> location（整数）：按下按键的位置。0 表示默认键，1 表示左边，2 表示右边，3 表示数字键盘，4 表示移动设备（虚拟键盘），5 表示游戏手柄。</li>
<li> modifiers（字符串）：空格分隔的修饰键列表，如”Shift”。</li>
<li> repeat（整数）：连续按了这个键多少次。</li>
</ul>
<p>注意，DOM3 Events 废弃了 keypress 事件，因此只能通过上述方式模拟 keydown 和 keyup 事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myTextbox&quot;</span>), </span><br><span class="line"> event; </span><br><span class="line"><span class="comment">// 按照 DOM3 的方式创建 event 对象</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">hasFeature</span>(<span class="string">&quot;KeyboardEvents&quot;</span>, <span class="string">&quot;3.0&quot;</span>)) &#123; </span><br><span class="line"> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;KeyboardEvent&quot;</span>); </span><br><span class="line"> <span class="comment">// 初始化 event 对象</span></span><br><span class="line"> event.<span class="title function_">initKeyboardEvent</span>(<span class="string">&quot;keydown&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="variable language_">document</span>.<span class="property">defaultView</span>, <span class="string">&quot;a&quot;</span>, </span><br><span class="line"> <span class="number">0</span>, <span class="string">&quot;Shift&quot;</span>, <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">textbox.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>

<p>这个例子模拟了同时按住 Shift 键和键盘上 A 键的 keydown 事件。在使用 document.create Event(“KeyboardEvent”)之前，最好检测一下浏览器对 DOM3 键盘事件的支持情况，其他浏览器会返回非标准的 KeyboardEvent 对象。</p>
<p>Firefox 允许给 createEvent()传入”KeyEvents”来创建键盘事件。这时候返回的 event 对象包含的方法叫 initKeyEvent()，此方法接收以下 10 个参数。</p>
<ul>
<li> type（字符串）：要触发的事件类型，如”keydown”。</li>
<li> bubbles（布尔值）：表示事件是否冒泡。为精确模拟键盘事件，应该设置为 true。</li>
<li> cancelable（布尔值）：表示事件是否可以取消。为精确模拟键盘事件，应该设置为 true。</li>
<li> view（AbstractView）：与事件关联的视图，基本上始终是 document.defaultView。</li>
<li> ctrlkey（布尔值）：表示是否按下了 Ctrl 键。默认为 false。</li>
<li> altkey（布尔值）：表示是否按下了 Alt 键。默认为 false。</li>
<li> shiftkey（布尔值）：表示是否按下了 Shift 键。默认为 false。</li>
<li> metakey（布尔值）：表示是否按下了 Meta 键。默认为 false。</li>
<li> keyCode（整数）：表示按下或释放键的键码。在 keydown 和 keyup 中使用。默认为 0。</li>
<li> charCode（整数）：表示按下键对应字符的 ASCII 编码。在 keypress 中使用。默认为 0。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅适用于 Firefox </span></span><br><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myTextbox&quot;</span>); </span><br><span class="line"><span class="comment">// 创建 event 对象</span></span><br><span class="line"><span class="keyword">let</span> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;KeyEvents&quot;</span>); </span><br><span class="line"><span class="comment">// 初始化 event 对象</span></span><br><span class="line">event.<span class="title function_">initKeyEvent</span>(<span class="string">&quot;keydown&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="variable language_">document</span>.<span class="property">defaultView</span>, <span class="literal">false</span>, </span><br><span class="line"> <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">65</span>, <span class="number">65</span>); </span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">textbox.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>

<p>这个例子模拟了同时按住 Shift 键和键盘上 A 键的 keydown 事件。同样也可以像这样模拟 keyup和 keypress 事件。</p>
<p>对于其他浏览器，需要创建一个通用的事件，并为其指定特定于键盘的信息，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myTextbox&quot;</span>); </span><br><span class="line"><span class="comment">// 创建 event 对象</span></span><br><span class="line"><span class="keyword">let</span> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;Events&quot;</span>); </span><br><span class="line"><span class="comment">// 初始化 event 对象</span></span><br><span class="line">event.<span class="title function_">initEvent</span>(type, bubbles, cancelable); </span><br><span class="line">event.<span class="property">view</span> = <span class="variable language_">document</span>.<span class="property">defaultView</span>; </span><br><span class="line">event.<span class="property">altKey</span> = <span class="literal">false</span>; </span><br><span class="line">event.<span class="property">ctrlKey</span> = <span class="literal">false</span>; </span><br><span class="line">event.<span class="property">shiftKey</span> = <span class="literal">false</span>; </span><br><span class="line">event.<span class="property">metaKey</span> = <span class="literal">false</span>; </span><br><span class="line">event.<span class="property">keyCode</span> = <span class="number">65</span>; </span><br><span class="line">event.<span class="property">charCode</span> = <span class="number">65</span>; </span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">textbox.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>

<p>以上代码创建了一个通用事件，然后使用 initEvent()方法初始化，接着又为它指定了键盘事件信息。这里必须使用通用事件而不是用户界面事件，因为用户界面事件不允许直接给 event 对象添加属性（Safari 例外）。像这样模拟一个事件虽然会触发键盘事件，但文本框中不会输入任何文本，因为它并不能准确模拟键盘事件。</p>
<h6 id="模拟其他事件"><a href="#模拟其他事件" class="headerlink" title="模拟其他事件"></a><strong>模拟其他事件</strong></h6><p>鼠标事件和键盘事件是浏览器中最常见的模拟对象。不过，有时候可能也需要模拟 HTML 事件。模 拟 HTML 事件要调用 createEvent()方法并传入”HTMLEvents”，然后再使用返回对象的initEvent()方法来初始化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;HTMLEvents&quot;</span>); </span><br><span class="line">event.<span class="title function_">initEvent</span>(<span class="string">&quot;focus&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>); </span><br><span class="line">target.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>

<p>这个例子模拟了在给定目标上触发 focus 事件。其他 HTML 事件也可以像这样来模拟。</p>
<h6 id="自定义-DOM-事件"><a href="#自定义-DOM-事件" class="headerlink" title="自定义 DOM 事件"></a><strong>自定义 DOM 事件</strong></h6><p>DOM3 增加了自定义事件的类型。自定义事件不会触发原生 DOM 事件，但可以让开发者定义自己的事件。要创建自定义事件，需要调用 createEvent(“CustomEvent”) 。返回的对象包含initCustomEvent()方法，该方法接收以下 4 个参数。</p>
<ul>
<li> type（字符串）：要触发的事件类型，如”myevent”。</li>
<li> bubbles（布尔值）：表示事件是否冒泡。</li>
<li> cancelable（布尔值）：表示事件是否可以取消。</li>
<li> detail（对象）：任意值。作为 event 对象的 detail 属性。</li>
</ul>
<p>自定义事件可以像其他事件一样在 DOM 中派发，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>), event; </span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;myevent&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DIV: &quot;</span> + event.<span class="property">detail</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;myevent&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DOCUMENT: &quot;</span> + event.<span class="property">detail</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">hasFeature</span>(<span class="string">&quot;CustomEvents&quot;</span>, <span class="string">&quot;3.0&quot;</span>)) &#123; </span><br><span class="line"> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;CustomEvent&quot;</span>); </span><br><span class="line"> event.<span class="title function_">initCustomEvent</span>(<span class="string">&quot;myevent&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line"> div.<span class="title function_">dispatchEvent</span>(event); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子创建了一个名为”myevent”的冒泡事件。event 对象的 detail 属性就是一个简单的字符串，</p>
<p>元素和 document 都为这个事件注册了事件处理程序。因为使用 initCustomEvent()初始化时将事件指定为可以冒泡，所以浏览器会负责把事件冒泡到 document。</p>
<h5 id="17-6-2IE-事件模拟"><a href="#17-6-2IE-事件模拟" class="headerlink" title="17.6.2IE 事件模拟"></a>17.6.2IE 事件模拟</h5><p>在 IE8 及更早版本中模拟事件的过程与 DOM 方式类似：创建 event 对象，指定相应信息，然后使用这个对象触发。当然，IE 实现每一步的方式都不一样。</p>
<p>首先，要使用 document 对象的 createEventObject()方法来创建 event 对象。与 DOM 不同，这个方法不接收参数，返回一个通用 event 对象。然后，可以手工给返回的对象指定希望该对象具备的所有属性。（没有初始化方法。）最后一步是在事件目标上调用 fireEvent()方法，这个方法接收两个参数：事件处理程序的名字和 event 对象。调用 fireEvent()时，srcElement 和 type 属性会自动指派到 event 对象（其他所有属性必须手工指定）。这意味着 IE 支持的所有事件都可以通过相同的方式来模拟。例如，下面的代码在一个按钮上模拟了 click 事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line"><span class="comment">// 创建 event 对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="variable language_">document</span>.<span class="title function_">createEventObject</span>(); </span><br><span class="line"><span class="comment">/// 初始化 event 对象</span></span><br><span class="line">event.<span class="property">screenX</span> = <span class="number">100</span>; </span><br><span class="line">event.<span class="property">screenY</span> = <span class="number">0</span>; </span><br><span class="line">event.<span class="property">clientX</span> = <span class="number">0</span>; </span><br><span class="line">event.<span class="property">clientY</span> = <span class="number">0</span>; </span><br><span class="line">event.<span class="property">ctrlKey</span> = <span class="literal">false</span>; </span><br><span class="line">event.<span class="property">altKey</span> = <span class="literal">false</span>; </span><br><span class="line">event.<span class="property">shiftKey</span> = <span class="literal">false</span>; </span><br><span class="line">event.<span class="property">button</span> = <span class="number">0</span>; </span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">btn.<span class="title function_">fireEvent</span>(<span class="string">&quot;onclick&quot;</span>, event);</span><br></pre></td></tr></table></figure>

<p>这个例子先创建 event 对象，然后用相关信息对其进行了初始化。注意，这里可以指定任何属性，包括 IE8 及更早版本不支持的属性。这些属性的值对于事件来说并不重要，因为只有事件处理程序才会使用它们</p>
<p>同样的方式也可以用来模拟 keypress 事件，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myTextbox&quot;</span>); </span><br><span class="line"><span class="comment">// 创建 event 对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="variable language_">document</span>.<span class="title function_">createEventObject</span>(); </span><br><span class="line"><span class="comment">// 初始化 event 对象</span></span><br><span class="line">event.<span class="property">altKey</span> = <span class="literal">false</span>; </span><br><span class="line">event.<span class="property">ctrlKey</span> = <span class="literal">false</span>; </span><br><span class="line">event.<span class="property">shiftKey</span> = <span class="literal">false</span>; </span><br><span class="line">event.<span class="property">keyCode</span> = <span class="number">65</span>; </span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">textbox.<span class="title function_">fireEvent</span>(<span class="string">&quot;onkeypress&quot;</span>, event);</span><br></pre></td></tr></table></figure>

<p>由于鼠标事件、键盘事件或其他事件的 event 对象并没有区别，因此使用通用的 event 对象可以触发任何类型的事件。注意，与 DOM 方式模拟键盘事件一样，这里模拟的 keypress 虽然会触发，但文本框中也不会出现字符。</p>
<h3 id="18：动画与-Canvas-图形"><a href="#18：动画与-Canvas-图形" class="headerlink" title="18：动画与 Canvas 图形"></a>18：动画与 Canvas 图形</h3><h4 id="18-1使用-requestAnimationFrame"><a href="#18-1使用-requestAnimationFrame" class="headerlink" title="18.1使用 requestAnimationFrame"></a>18.1使用 requestAnimationFrame</h4><h5 id="18-1-1早期定时动画"><a href="#18-1-1早期定时动画" class="headerlink" title="18.1.1早期定时动画"></a>18.1.1早期定时动画</h5><p>以前，在 JavaScript 中创建动画基本上就是使用 setInterval()来控制动画的执行。下面的例子展示了使用 setInterval()的基本模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">updateAnimations</span>(<span class="params"></span>) &#123; </span><br><span class="line">         <span class="title function_">doAnimation1</span>(); </span><br><span class="line">         <span class="title function_">doAnimation2</span>(); </span><br><span class="line">         <span class="comment">// 其他任务</span></span><br><span class="line">     &#125; </span><br><span class="line">     <span class="built_in">setInterval</span>(updateAnimations, <span class="number">100</span>); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>虽然使用 setInterval()的定时动画比使用多个 setTimeout()实现循环效率更高，但也不是没有问题。无论 setInterval()还是 setTimeout()都是不能保证时间精度的。</p>
<p>作为第二个参数的延时只能保证何时会把代码添加到浏览器的任务队列，不能保证添加到队列就会立即运行。如果队列前面还有其他任务，那么就要等这些任务执行完再执行。简单来讲，这里毫秒延时并不是说何时这些代码会执行，而只是说到时候会把回调加到任务队列。如果添加到队列后，主线程还被其他任务占用，比如正在处理用户操作，那么回调就不会马上执行。</p>
<h5 id="18-1-2时间间隔的问题"><a href="#18-1-2时间间隔的问题" class="headerlink" title="18.1.2时间间隔的问题"></a>18.1.2时间间隔的问题</h5><p>浏览器的计时器精度不足毫秒。以下是几个浏览器计时器的精度情况：</p>
<ul>
<li> IE8 及更早版本的计时器精度为 15.625 毫秒；</li>
<li> IE9 及更晚版本的计时器精度为 4 毫秒；</li>
<li> Firefox 和 Safari 的计时器精度为约 10 毫秒；</li>
<li> Chrome 的计时器精度为 4 毫秒。</li>
</ul>
<p>因此即使将时间间隔设定为最优，也免不了只能得到近似的结果。</p>
<h5 id="18-1-3requestAnimationFrame"><a href="#18-1-3requestAnimationFrame" class="headerlink" title="18.1.3requestAnimationFrame"></a>18.1.3requestAnimationFrame</h5><p>浏览器知道 CSS过渡和动画应该什么时候开始，并据此计算出正确的时间间隔，到时间就去刷新用户界面。</p>
<p>目前所有浏览器都支持这个方法不带前缀的版本，即 requestAnimationFrame()。</p>
<p>requestAnimationFrame()方法接收一个参数，此参数是一个要在重绘屏幕前调用的函数。这个函数就是修改 DOM 样式以反映下一次重绘有什么变化的地方。为了实现动画循环，可以把多个requestAnimationFrame()调用串联起来，就像以前使用 setTimeout()时一样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;status&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:100px;width:1%; background-color:red;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">updateProgress</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;status&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        div.<span class="property">style</span>.<span class="property">width</span> = (<span class="built_in">parseInt</span>(div.<span class="property">style</span>.<span class="property">width</span>, <span class="number">10</span>) + <span class="number">1</span>) + <span class="string">&quot;%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (div.<span class="property">style</span>.<span class="property">width</span> != <span class="string">&quot;100%&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">requestAnimationFrame</span>(updateProgress);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">requestAnimationFrame</span>(updateProgress);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为 requestAnimationFrame()只会调用一次传入的函数，所以每次更新用户界面时需要再手动调用它一次。同样，也需要控制动画何时停止。结果就会得到非常平滑的动画。</p>
<p>目前为止，requestAnimationFrame()已经解决了浏览器不知道 JavaScript 动画何时开始的问题，以及最佳间隔是多少的问题，但是，不知道自己的代码何时实际执行的问题呢？这个方案同样也给出了解决方法。</p>
<p>传给 requestAnimationFrame()的函数实际上可以接收一个参数，此参数是一个 DOMHighResTimeStamp 的实例（比如 performance.now()返回的值），表示下次重绘的时间。这一点非常重要：requestAnimationFrame()实际上把重绘任务安排在了未来一个已知的时间点上，而且通过这个参数告诉了开发者。基于这个参数，就可以更好地决定如何调优动画了。</p>
<h5 id="18-1-4cancelAnimationFrame"><a href="#18-1-4cancelAnimationFrame" class="headerlink" title="18.1.4cancelAnimationFrame"></a>18.1.4cancelAnimationFrame</h5><p>与 setTimeout()类似，requestAnimationFrame()也返回一个请求 ID，可以用于通过另一个方法 cancelAnimationFrame()来取消重绘任务。下面的例子展示了刚把一个任务加入队列又立即将其取消：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> requestID = <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Repaint!&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">cancelAnimationFrame</span>(requestID);</span><br></pre></td></tr></table></figure>

<h5 id="18-1-5通过-requestAnimationFrame-节流"><a href="#18-1-5通过-requestAnimationFrame-节流" class="headerlink" title="18.1.5通过 requestAnimationFrame 节流"></a>18.1.5通过 <strong>requestAnimationFrame</strong> 节流</h5><p>先来看一个原生实现，其中的滚动事件监听器每次触发都会调用名为 expensiveOperation()（耗时操作）的函数。当向下滚动网页时，这个事件很快就会被触发并执行成百上千次：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">expensiveOperation</span>(<span class="params"></span>) &#123; </span><br><span class="line">	 <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invoked at&#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">	 <span class="title function_">expensiveOperation</span>(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果想把事件处理程序的调用限制在每次重绘前发生，那么可以像这样下面把它封装到 requestAnimationFrame()调用中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">expensiveOperation</span>(<span class="params"></span>) &#123; </span><br><span class="line"> 	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invoked at&#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> 	<span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(expensiveOperation); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样会把所有回调的执行集中在重绘钩子，但不会过滤掉每次重绘的多余调用。此时，定义一个标志变量，由回调设置其开关状态，就可以将多余的调用屏蔽：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enqueued = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">expensiveOperation</span>(<span class="params"></span>) &#123; </span><br><span class="line"> 	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invoked at&#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>()); </span><br><span class="line"> 	enqueued = <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> 	<span class="keyword">if</span> (!enqueued) &#123; </span><br><span class="line"> 	enqueued = <span class="literal">true</span>; </span><br><span class="line">	 	<span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(expensiveOperation); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>因为重绘是非常频繁的操作，所以这还算不上真正的节流。更好的办法是配合使用一个计时器来限制操作执行的频率。这样，计时器可以限制实际的操作执行间隔，而 requestAnimationFrame 控制在浏览器的哪个渲染周期中执行。下面的例子可以将回调限制为不超过 50 毫秒执行一次：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enabled = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">expensiveOperation</span>(<span class="params"></span>) &#123; </span><br><span class="line"> 	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invoked at&#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> 	<span class="keyword">if</span> (enabled) &#123; </span><br><span class="line"> 		enabled = <span class="literal">false</span>; </span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(expensiveOperation); </span><br><span class="line">        <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> enabled = <span class="literal">true</span>, <span class="number">50</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="18-2基本的画布功能"><a href="#18-2基本的画布功能" class="headerlink" title="18.2基本的画布功能"></a>18.2基本的画布功能</h4><p>创建元素时至少要设置其 width 和 height 属性，这样才能告诉浏览器在多大面积上绘图。出现在开始和结束标签之间的内容是后备数据，会在浏览器不支持元素时显示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;drawing&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span>A drawing of something.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与其他元素一样，width 和 height 属性也可以在 DOM 节点上设置，因此可以随时修改。整个元素还可以通过 CSS 添加样式，并且元素在添加样式或实际绘制内容前是不可见的。</p>
<p>要在画布上绘制图形，首先要取得绘图上下文。使用 getContext()方法可以获取对绘图上下文的引用。对于平面图形，需要给这个方法传入参数”2d”，表示要获取 2D 上下文对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"> <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用元素时，最好先测试一下 getContext()方法是否存在。有些浏览器对 HTML 规范中没有的元素会创建默认 HTML 元素对象。这就意味着即使 drawing 包含一个有效的元素引用，getContext()方法也未必存在。</p>
<p>可以使用 toDataURL()方法导出元素上的图像。这个方法接收一个参数：要生成图像的 MIME 类型（与用来创建图形的上下文无关）。例如，要从画布上导出一张 PNG 格式的图片，可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="comment">// 取得图像的数据 URI </span></span><br><span class="line"> <span class="keyword">let</span> imgURI = drawing.<span class="title function_">toDataURL</span>(<span class="string">&quot;image/png&quot;</span>); </span><br><span class="line"> <span class="comment">// 显示图片</span></span><br><span class="line"> <span class="keyword">let</span> image = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>); </span><br><span class="line"> image.<span class="property">src</span> = imgURI; </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(image); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器默认将图像编码为 PNG 格式，除非另行指定。Firefox 和 Opera 还支持传入”image&#x2F;jpeg”进行 JPEG 编码。因为这个方法是后来才增加到规范中的，所以支持的浏览器也是在后面的版本实现的，包括 IE9、Firefox 3.5 和 Opera 10。</p>
<h4 id="18-3-2D-绘图上下文"><a href="#18-3-2D-绘图上下文" class="headerlink" title="18.3 2D 绘图上下文"></a>18.3 2D 绘图上下文</h4><p>2D 绘图上下文提供了绘制 2D 图形的方法，包括矩形、弧形和路径。2D 上下文的坐标原点(0, 0)在元素的左上角。所有坐标值都相对于该点计算，因此 <em>x</em> 坐标向右增长，<em>y</em> 坐标向下增长。默认情况下，width 和 height 表示两个方向上像素的最大值。</p>
<h5 id="18-3-1填充和描边"><a href="#18-3-1填充和描边" class="headerlink" title="18.3.1填充和描边"></a>18.3.1填充和描边</h5><p>2D 上下文有两个基本绘制操作：填充和描边。填充以指定样式（颜色、渐变或图像）自动填充形状，而描边只为图形边界着色。大多数 2D 上下文操作有填充和描边的变体，显示效果取决于两个属性：fillStyle 和 strokeStyle。</p>
<p>这两个属性可以是字符串、渐变对象或图案对象，默认值都为”#000000”。字符串表示颜色值，可以是 CSS 支持的任意格式：名称、十六进制代码、rgb、rgba、hsl 或 hsla。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"> context.<span class="property">strokeStyle</span> = <span class="string">&quot;red&quot;</span>; </span><br><span class="line"> context.<span class="property">fillStyle</span> = <span class="string">&quot;#0000ff&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把 strokeStyle 设置为”red”（CSS 颜色名称），把 fillStyle 设置为”#0000ff”（蓝色）。所有与描边和填充相关的操作都会使用这两种样式，除非再次修改。这两个属性也可以是渐变或图案</p>
<h5 id="18-3-2绘制矩形"><a href="#18-3-2绘制矩形" class="headerlink" title="18.3.2绘制矩形"></a>18.3.2绘制矩形</h5><p>矩形是唯一一个可以直接在 2D 绘图上下文中绘制的形状。与绘制矩形相关的方法有 3 个：fillRect()、strokeRect()和 clearRect()。这些方法都接收 4 个参数：矩形 <em>x</em> 坐标、矩形 <em>y</em> 坐标、矩形宽度和矩形高度。这几个参数的单位都是像素。</p>
<p>fillRect()方法用于以指定颜色在画布上绘制并填充矩形。填充的颜色使用 fillStyle 属性指定。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line">     <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line">     <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 引自 MDN 文档</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">     <span class="comment">// 绘制红色矩形</span></span><br><span class="line">     context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">     context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line">     <span class="comment">// 绘制半透明蓝色矩形</span></span><br><span class="line">     context.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(0,0,255,0.5)&quot;</span>; </span><br><span class="line">     context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码先将 fillStyle 设置为红色并在坐标点(10, 10)绘制了一个宽高均为 50 像素的矩形。接着，使用 rgba()格式将 fillStyle 设置为半透明蓝色，并绘制了另一个与第一个部分重叠的矩形。结果就是可以透过蓝色矩形看到红色矩形</p>
<p>strokeRect()方法使用通过 strokeStyle 属性指定的颜色绘制矩形轮廓。下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      * 引自 MDN 文档</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="comment">// 绘制红色轮廓的矩形</span></span><br><span class="line">    context.<span class="property">strokeStyle</span> = <span class="string">&quot;#ff0000&quot;</span>;</span><br><span class="line">    context.<span class="title function_">strokeRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 绘制半透明蓝色轮廓的矩形</span></span><br><span class="line">    context.<span class="property">strokeStyle</span> = <span class="string">&quot;rgba(0,0,255,0.5)&quot;</span>;</span><br><span class="line">    context.<span class="title function_">strokeRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码同样绘制了两个重叠的矩形，不过只有轮廓，而不是实心的</p>
<p>描边宽度由 lineWidth 属性控制，它可以是任意整数值。类似地，lineCap 属性控制线条端点的形状［”butt”（平头）、”round”（出圆头）或”square”（出方头）］，而 lineJoin属性控制线条交点的形状［”round”（圆转）、”bevel”（取平）或”miter”（出尖）］</p>
<p>使用 clearRect()方法可以擦除画布中某个区域。该方法用于把绘图上下文中的某个区域变透明。通过先绘制形状再擦除指定区域，可以创建出有趣的效果，比如从已有矩形中开个孔。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      * 引自 MDN 文档</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="comment">// 绘制红色矩形</span></span><br><span class="line">    context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>;</span><br><span class="line">    context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 绘制半透明蓝色矩形</span></span><br><span class="line">    context.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(0,0,255,0.5)&quot;</span>;</span><br><span class="line">    context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 在前两个矩形重叠的区域擦除一个矩形区域</span></span><br><span class="line">    context.<span class="title function_">clearRect</span>(<span class="number">40</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码在两个矩形重叠的区域上擦除了一个小矩形</p>
<h5 id="18-3-3绘制路径"><a href="#18-3-3绘制路径" class="headerlink" title="18.3.3绘制路径"></a>18.3.3绘制路径</h5><p>2D 绘图上下文支持很多在画布上绘制路径的方法。通过路径可以创建复杂的形状和线条。要绘制路径，必须首先调用 beginPath()方法以表示要开始绘制新路径。然后，再调用下列方法来绘制路径。</p>
<ul>
<li>arc(x, y, radius, startAngle, endAngle, counterclockwise)：以坐标(x, y)为圆心，以 radius 为半径绘制一条弧线，起始角度为 startAngle，结束角度为 endAngle（都是弧度）。最后一个参数 counterclockwise 表示是否逆时针计算起始角度和结束角度（默认为顺时针）。</li>
<li>arcTo(x1, y1, x2, y2, radius)：以给定半径 radius，经由(x1, y1)绘制一条从上一点到(x2, y2)的弧线。</li>
<li>bezierCurveTo(c1x, c1y, c2x, c2y, x, y)：以(c1x, c1y)和(c2x, c2y)为控制点，绘制一条从上一点到(x, y)的弧线（三次贝塞尔曲线）。</li>
<li>lineTo(x, y)：绘制一条从上一点到(x, y)的直线。</li>
<li>moveTo(x, y)：不绘制线条，只把绘制光标移动到(x, y)。</li>
<li>quadraticCurveTo(cx, cy, x, y)：以(cx, cy)为控制点，绘制一条从上一点到(x, y)的弧线（二次贝塞尔曲线）。</li>
<li>rect(x, y, width, height)：以给定宽度和高度在坐标点(x, y)绘制一个矩形。这个方法与 strokeRect()和 fillRect()的区别在于，它创建的是一条路径，而不是独立的图形。</li>
</ul>
<p>创建路径之后，可以使用 closePath()方法绘制一条返回起点的线。如果路径已经完成，则既可以指定 fillStyle 属性并调用 fill()方法来填充路径，也可以指定 strokeStyle 属性并调用stroke()方法来描画路径，还可以调用 clip()方法基于已有路径创建一个新剪切区域。</p>
<p>下面这个例子使用前面提到的方法绘制了一个不带数字的表盘：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建路径</span></span><br><span class="line">    context.<span class="title function_">beginPath</span>();</span><br><span class="line">    <span class="comment">// 绘制外圆</span></span><br><span class="line">    context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 绘制内圆</span></span><br><span class="line">    context.<span class="title function_">moveTo</span>(<span class="number">194</span>, <span class="number">100</span>);</span><br><span class="line">    context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 绘制分针</span></span><br><span class="line">    context.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    context.<span class="title function_">lineTo</span>(<span class="number">100</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="comment">// 绘制时针</span></span><br><span class="line">    context.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    context.<span class="title function_">lineTo</span>(<span class="number">35</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 描画路径</span></span><br><span class="line">    context.<span class="title function_">stroke</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子使用 arc()绘制了两个圆形，一个外圆和一个内圆，以构成表盘的边框。外圆半径 99 像素，原点为(100,100)，也就是画布的中心。要绘制完整的圆形，必须从 0 弧度绘制到 2π 弧度（使用数学常量 Math.PI）。而在绘制内圆之前，必须先把路径移动到内圆上的一点，以避免绘制出多余的线条。第二次调用 arc()时使用了稍小一些的半径，以呈现边框效果。然后，再组合运用 moveTo()和 lineTo()分别绘制分针和时针。最后一步是调用 stroke()</p>
<p>路径是 2D 上下文的主要绘制机制，为绘制结果提供了很多控制。因为路径经常被使用，所以也有一个 isPointInPath()方法，接收 <em>x</em> 轴和 <em>y</em> 轴坐标作为参数。这个方法用于确定指定的点是否在路径上，可以在关闭路径前随时调用，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (context.<span class="title function_">isPointInPath</span>(<span class="number">100</span>, <span class="number">100</span>)) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;Point (100, 100) is in the path.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2D 上下文的路径 API 非常可靠，可用于创建涉及各种填充样式、描述样式等的复杂图像。</p>
<h5 id="18-3-4绘制文本"><a href="#18-3-4绘制文本" class="headerlink" title="18.3.4绘制文本"></a>18.3.4绘制文本</h5><p>文本和图像混合也是常见的绘制需求，因此2D绘图上下文还提供了绘制文本的方法，即fillText()和 strokeText()。这两个方法都接收 4 个参数：要绘制的字符串、<em>x</em> 坐标、<em>y</em> 坐标和可选的最大像素宽度。而且，这两个方法最终绘制的结果都取决于以下 3 个属性。</p>
<ul>
<li>font：以 CSS 语法指定的字体样式、大小、字体族等，比如”10px Arial”。</li>
<li>textAlign：指定文本的对齐方式，可能的值包括”start”、”end”、”left”、”right”和”center”。推荐使用”start”和”end”，不使用”left”和”right”，因为前者无论在从左到右书写的语言还是从右到左书写的语言中含义都更明确。</li>
<li>textBaseLine ：指定文本的基线，可能的值包括 “top” 、 “hanging” 、 “middle” 、”alphabetic”、”ideographic”和”bottom”。</li>
</ul>
<p>fillText()方法使用</p>
<p>fillStyle 属性绘制文本，而 strokeText()方法使用 strokeStyle 属性。通常，fillText()方法是使用最多的，因为它模拟了在网页中渲染文本。</p>
<p>例如，下面的例子会在前一节示例的表盘顶部绘制数字“12”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">context.<span class="property">font</span> = <span class="string">&quot;bold 14px Arial&quot;</span>; </span><br><span class="line">context.<span class="property">textAlign</span> = <span class="string">&quot;center&quot;</span>; </span><br><span class="line">context.<span class="property">textBaseline</span> = <span class="string">&quot;middle&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillText</span>(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>因为把 textAlign 设置为了”center”，把 textBaseline 设置为了”middle”，所以(100, 20)表示文本水平和垂直中心点的坐标。如果 textAlign 是”start”，那么 <em>x</em> 坐标在从左到右书写的语言中表示文本的左侧坐标，而”end”会让 <em>x</em> 坐标在从左到右书写的语言中表示文本的右侧坐标。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常</span></span><br><span class="line">context.<span class="property">font</span> = <span class="string">&quot;bold 14px Arial&quot;</span>; </span><br><span class="line">context.<span class="property">textAlign</span> = <span class="string">&quot;center&quot;</span>; </span><br><span class="line">context.<span class="property">textBaseline</span> = <span class="string">&quot;middle&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillText</span>(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">20</span>); </span><br><span class="line"><span class="comment">// 与开头对齐</span></span><br><span class="line">context.<span class="property">textAlign</span> = <span class="string">&quot;start&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillText</span>(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">40</span>); </span><br><span class="line"><span class="comment">// 与末尾对齐</span></span><br><span class="line">context.<span class="property">textAlign</span> = <span class="string">&quot;end&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillText</span>(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">60</span>);</span><br></pre></td></tr></table></figure>

<p>字符串”12”被绘制了 3 次，每次使用的坐标都一样，但 textAlign 值不同。为了让每个字符串不</p>
<p>至于重叠，每次绘制的 <em>y</em> 坐标都会设置得大一些。</p>
<p>因为表盘中垂直的线条是居中的，所以文本的对齐方式就一目了然了。类似地，通过修改 textBaseline属性，可以改变文本的垂直对齐方式。比如，设置为”top”意味着 <em>y</em> 坐标表示文本顶部，”bottom”表示文本底部，”hanging”、”alphabetic”和”ideographic”分别引用字体中特定的基准点。</p>
<p>因此 2D 上下文提供了用于辅助确</p>
<p>定文本大小的 measureText()方法。这个方法接收一个参数，即要绘制的文本，然后返回一个TextMetrics 对象。这</p>
<p>measureText()方法使用 font、textAlign 和 textBaseline 属性当前的值计算绘制指定文本后的大小。例如，假设要把文本”Hello world!”放到一个 140 像素宽的矩形中，可以使用以下代码，从 100 像素的字体大小开始计算，不断递减，直到文本大小合适：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;warpBox&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;drawing&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> fontSize = <span class="number">100</span>;</span></span><br><span class="line"><span class="language-javascript">        context.<span class="property">font</span> = fontSize + <span class="string">&quot;px Arial&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">while</span> (context.<span class="title function_">measureText</span>(<span class="string">&quot;Hello world!&quot;</span>).<span class="property">width</span> &gt; <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            fontSize--;</span></span><br><span class="line"><span class="language-javascript">            context.<span class="property">font</span> = fontSize + <span class="string">&quot;px Arial&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        context.<span class="title function_">fillText</span>(<span class="string">&quot;Hello world!&quot;</span>, <span class="number">50</span>, <span class="number">50</span>);</span></span><br><span class="line"><span class="language-javascript">        context.<span class="title function_">fillText</span>(<span class="string">&quot;Font size is &quot;</span> + fontSize + <span class="string">&quot;px&quot;</span>, <span class="number">50</span>, <span class="number">100</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>fillText()和 strokeText()方法还有第四个参数，即文本的最大宽度。这个参数是可选的（Firefox 4 是第一个实现它的浏览器），如果调用 fillText()和 strokeText()时提供了此参数，但要绘制的字符串超出了最大宽度限制，则文本会以正确的字符高度绘制，这时字符会被水平压缩，以达到限定宽度。</p>
<p>绘制文本是一项比较复杂的操作，因此支持元素的浏览器不一定全部实现了相关的文本绘制 API。</p>
<h5 id="18-3-5变换"><a href="#18-3-5变换" class="headerlink" title="18.3.5变换"></a>18.3.5变换</h5><p>以下方法可用于改变绘制上下文的变换矩阵。</p>
<ul>
<li>rotate(angle)：围绕原点把图像旋转 angle 弧度。</li>
<li>scale(scaleX, scaleY)：通过在 <em>x</em> 轴乘以 scaleX、在 <em>y</em> 轴乘以 scaleY 来缩放图像。scaleX和 scaleY 的默认值都是 1.0。</li>
<li>translate(x, y)：把原点移动到(x, y)。执行这个操作后，坐标(0, 0)就会变成(x, y)。</li>
<li>transform(m1_1, m1_2, m2_1, m2_2, dx, dy)：像下面这样通过矩阵乘法直接修改矩阵。</li>
<li>setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)：把矩阵重置为默认值，再以传入的参数调用 transform()。</li>
</ul>
<p>变换可以简单，也可以复杂。例如，在前面绘制表盘的例子中，如果把坐标原点移动到表盘中心，那再绘制表针就非常简单了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"> <span class="comment">// 创建路径</span></span><br><span class="line"> context.<span class="title function_">beginPath</span>(); </span><br><span class="line"> <span class="comment">// 绘制外圆</span></span><br><span class="line"> context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>); </span><br><span class="line"> <span class="comment">// 绘制内圆</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">194</span>, <span class="number">100</span>); </span><br><span class="line"> context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>); </span><br><span class="line"> <span class="comment">// 移动原点到表盘中心</span></span><br><span class="line"> context.<span class="title function_">translate</span>(<span class="number">100</span>, <span class="number">100</span>); </span><br><span class="line"> <span class="comment">// 绘制分针</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"> context.<span class="title function_">lineTo</span>(<span class="number">0</span>, -<span class="number">85</span>); </span><br><span class="line"> <span class="comment">// 绘制时针</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"> context.<span class="title function_">lineTo</span>(-<span class="number">65</span>, <span class="number">0</span>); </span><br><span class="line"> <span class="comment">// 描画路径</span></span><br><span class="line"> context.<span class="title function_">stroke</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把原点移动到(100, 100)，也就是表盘的中心后，要绘制表针只需简单的数学计算即可。这是因为所有计算都是基于(0, 0)，而不是(100, 100)了。当然，也可以使用 rotate()方法来转动表针：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"> <span class="comment">// 创建路径</span></span><br><span class="line"> context.<span class="title function_">beginPath</span>(); </span><br><span class="line"> <span class="comment">// 绘制外圆</span></span><br><span class="line"> context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>); </span><br><span class="line"> <span class="comment">// 绘制内圆</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">194</span>, <span class="number">100</span>); </span><br><span class="line"> context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>); </span><br><span class="line"> <span class="comment">// 移动原点到表盘中心</span></span><br><span class="line"> context.<span class="title function_">translate</span>(<span class="number">100</span>, <span class="number">100</span>); </span><br><span class="line"> <span class="comment">// 旋转表针</span></span><br><span class="line"> context.<span class="title function_">rotate</span>(<span class="number">1</span>); </span><br><span class="line"> <span class="comment">// 绘制分针</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"> context.<span class="title function_">lineTo</span>(<span class="number">0</span>, -<span class="number">85</span>); </span><br><span class="line"> <span class="comment">// 绘制时针</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"> context.<span class="title function_">lineTo</span>(-<span class="number">65</span>, <span class="number">0</span>); </span><br><span class="line"> <span class="comment">// 描画路径</span></span><br><span class="line"> context.<span class="title function_">stroke</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为原点已经移动到表盘中心，所以旋转就是以该点为圆心的。这相当于把表针一头固定在表盘中心，然后向右拨了一个弧度。</p>
<p>所有这些变换，包括 fillStyle 和 strokeStyle 属性，会一直保留在上下文中，直到再次修改它们。虽然没有办法明确地将所有值都重置为默认值，但有两个方法可以帮我们跟踪变化。如果想着什么时候再回到当前的属性和变换状态，可以调用 save()方法。调用这个方法后，所有这一时刻的设置会被放到一个暂存栈中。保存之后，可以继续修改上下文。而在需要恢复之前的上下文时，可以调用restore()方法。这个方法会从暂存栈中取出并恢复之前保存的设置。多次调用 save()方法可以在暂存栈中存储多套设置，然后通过 restore()可以系统地恢复。下面来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">context.<span class="title function_">save</span>(); </span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#00ff00&quot;</span>; </span><br><span class="line">context.<span class="title function_">translate</span>(<span class="number">100</span>, <span class="number">100</span>); </span><br><span class="line">context.<span class="title function_">save</span>(); </span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#0000ff&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>); <span class="comment">// 在(100, 100)绘制蓝色矩形</span></span><br><span class="line">context.<span class="title function_">restore</span>(); </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>); <span class="comment">// 在(100, 100)绘制绿色矩形</span></span><br><span class="line">context.<span class="title function_">restore</span>(); </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>); <span class="comment">// 在(0, 0)绘制红色矩形</span></span><br></pre></td></tr></table></figure>

<p>以上代码先将 fillStyle 设置为红色，然后调用 save()。接着，将 fillStyle 修改为绿色，坐标移动到(100, 100)，并再次调用 save()，保存设置。随后，将 fillStyle 属性设置为蓝色并绘制一个矩形。因为此时坐标被移动了，所以绘制矩形的坐标实际上是(100, 100)。在调用 restore()之后，fillStyle 恢复为绿色，因此这一次绘制的矩形是绿色的。而绘制矩形的坐标是(110, 110)，因为变换仍在起作用。再次调用 restore()之后，变换被移除，fillStyle 也恢复为红色。绘制最后一个矩形的坐标变成了(0, 0)。</p>
<p>注意，save()方法只保存应用到绘图上下文的设置和变换，不保存绘图上下文的内容</p>
<h5 id="18-3-6绘制图像"><a href="#18-3-6绘制图像" class="headerlink" title="18.3.6绘制图像"></a>18.3.6绘制图像</h5><p>2D 绘图上下文内置支持操作图像。如果想把现有图像绘制到画布上，可以使用 drawImage()方法。这个方法可以接收 3 组不同的参数，并产生不同的结果。最简单的调用是传入一个 HTML 的img元素，以及表示绘制目标的 <em>x</em> 和 <em>y</em> 坐标，结果是把图像绘制到指定位置。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="variable language_">document</span>.<span class="property">images</span>[<span class="number">0</span>]; </span><br><span class="line">context.<span class="title function_">drawImage</span>(image, <span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码获取了文本中的第一个图像，然后在画布上的坐标(10, 10)处将它绘制了出来。绘制出来的图像与原来的图像一样大。如果想改变所绘制图像的大小，可以再传入另外两个参数：目标宽度和目标高度。这里的缩放只影响绘制的图像，不影响上下文的变换矩阵。比如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.<span class="title function_">drawImage</span>(image, <span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>执行之后，图像会缩放到 20 像素宽、30 像素高。</p>
<p>还可以只把图像绘制到上下文中的一个区域。此时，需要给 drawImage()提供 9 个参数：要绘制的图像、源图像 <em>x</em> 坐标、源图像 <em>y</em> 坐标、源图像宽度、源图像高度、目标区域 <em>x</em> 坐标、目标区域 <em>y</em> 坐标、目标区域宽度和目标区域高度。这个重载后的 drawImage()方法可以实现最大限度的控制，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.<span class="title function_">drawImage</span>(image, <span class="number">0</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">40</span>, <span class="number">60</span>);</span><br></pre></td></tr></table></figure>

<p>最终，原始图像中只有一部分会绘制到画布上。这一部分从(0, 10)开始，50 像素宽、50 像素高。而绘制到画布上时，会从(0, 100)开始，变成 40 像素宽、60 像素高。</p>
<p>第一个参数除了可以是 HTML 的img元素，还可以是另一个元素，这样就会把另一个画布的内容绘制到当前画布上。</p>
<p>结合其他一些方法，drawImage()方法可以方便地实现常见的图像操作。操作的结果可以使用toDataURL()方法获取。不过有一种情况例外：如果绘制的图像来自其他域而非当前页面，则不能获取其数据。此时，调用 toDataURL()将抛出错误。</p>
<h5 id="18-3-7阴影"><a href="#18-3-7阴影" class="headerlink" title="18.3.7阴影"></a>18.3.7阴影</h5><p>2D 上下文可以根据以下属性的值自动为已有形状或路径生成阴影。</p>
<ul>
<li> shadowColor：CSS 颜色值，表示要绘制的阴影颜色，默认为黑色。</li>
<li> shadowOffsetX：阴影相对于形状或路径的 <em>x</em> 坐标的偏移量，默认为 0。</li>
<li> shadowOffsetY：阴影相对于形状或路径的 <em>y</em> 坐标的偏移量，默认为 0。</li>
<li> shadowBlur：像素，表示阴影的模糊量。默认值为 0，表示不模糊。</li>
</ul>
<p>这些属性都可以通过 context 对象读写。只要在绘制图形或路径前给这些属性设置好适当的值，阴影就会自动生成。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"><span class="comment">// 设置阴影</span></span><br><span class="line">context.<span class="property">shadowOffsetX</span> = <span class="number">5</span>; </span><br><span class="line">context.<span class="property">shadowOffsetY</span> = <span class="number">5</span>; </span><br><span class="line">context.<span class="property">shadowBlur</span> = <span class="number">4</span>; </span><br><span class="line">context.<span class="property">shadowColor</span> = <span class="string">&quot;rgba(0, 0, 0, 0.5)&quot;</span>; </span><br><span class="line"><span class="comment">// 绘制红色矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"><span class="comment">// 绘制蓝色矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(0,0,255,1)&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>这里两个矩形使用了相同的阴影样式。</p>
<h5 id="18-3-8渐变"><a href="#18-3-8渐变" class="headerlink" title="18.3.8渐变"></a>18.3.8渐变</h5><p>渐变通过 CanvasGradient 的实例表示，在 2D 上下文中创建和修改都非常简单。要创建一个新的线性渐变，可以调用上下文的 createLinearGradient()方法。这个方法接收 4 个参数：起点 <em>x</em> 坐标、起点 <em>y</em> 坐标、终点 <em>x</em> 坐标和终点 <em>y</em> 坐标。调用之后，该方法会以指定大小创建一个新的 CanvasGradient对象并返回实例。</p>
<p>有了 gradient 对象后，接下来要使用 addColorStop()方法为渐变指定色标。这个方法接收两个参数：色标位置和 CSS 颜色字符串。色标位置通过 0～1 范围内的值表示，0 是第一种颜色，1 是最后一种颜色。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gradient = context.<span class="title function_">createLinearGradient</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">70</span>); </span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&quot;white&quot;</span>); </span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&quot;black&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个 gradient 对象现在表示的就是在画布上从(30, 30)到(70, 70)绘制一个渐变。渐变的起点颜色为白色，终点颜色为黑色。可以把这个对象赋给 fillStyle 或 strokeStyle 属性，从而以渐变填充或描画绘制的图形：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> gradient = context.<span class="title function_">createLinearGradient</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">70</span>);</span><br><span class="line">    gradient.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&quot;white&quot;</span>);</span><br><span class="line">    gradient.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&quot;black&quot;</span>);</span><br><span class="line">    <span class="comment">// 绘制红色矩形</span></span><br><span class="line">    context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>;</span><br><span class="line">    context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 绘制渐变矩形</span></span><br><span class="line">    context.<span class="property">fillStyle</span> = gradient;</span><br><span class="line">    context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让渐变覆盖整个矩形，而不只是其中一部分，两者的坐标必须搭配合适。以上代码将得到如图18-11 所示的结果。</p>
<p>如果矩形没有绘制到渐变的范围内，则只会显示部分渐变。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.<span class="property">fillStyle</span> = gradient; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码执行之后绘制的矩形只有左上角有一部分白色。这是因为矩形的起点在渐变的中间，此时颜色的过渡几乎要完成了。结果矩形大部分地方是黑色的，因为渐变不会重复。保持渐变与形状的一致非常重要，有时候可能需要写个函数计算相应的坐标。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createRectLinearGradient</span>(<span class="params">context, x, y, width, height</span>) &#123; </span><br><span class="line"> 	<span class="keyword">return</span> context.<span class="title function_">createLinearGradient</span>(x, y, x+width, y+height); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数会基于起点的 <em>x</em>、<em>y</em> 坐标和传入的宽度、高度创建渐变对象，之后调用 fillRect()方法时可以使用相同的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gradient = <span class="title function_">createRectLinearGradient</span>(context, <span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&quot;white&quot;</span>); </span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&quot;black&quot;</span>); </span><br><span class="line"><span class="comment">// 绘制渐变矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = gradient; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>计算坐标是使用画布时重要而复杂的问题。使用类似 createRectLinearGradient()这样的辅助函数能让计算坐标简单一些。</p>
<p>径向渐变（或放射性渐变）要使用 createRadialGradient()方法来创建。这个方法接收 6 个参数，分别对应两个圆形圆心的坐标和半径。前 3 个参数指定起点圆形中心的 <em>x</em>、<em>y</em> 坐标和半径，后 3 个参数指定终点圆形中心的 <em>x</em>、<em>y</em> 坐标和半径。在创建径向渐变时，可以把两个圆形想象成一个圆柱体的两个圆形表面。把一个表面定义得小一点，另一个定义得大一点，就会得到一个圆锥体。然后，通过移动两个圆形的圆心，就可以旋转这个圆锥体。</p>
<p>要创建起点圆心在形状中心并向外扩散的径向渐变，需要将两个圆形设置为同心圆。比如，要在前面例子中矩形的中心创建径向渐变，则渐变的两个圆形的圆心都必须设置为(55, 55)。这是因为矩形的起点是(30, 30)，终点是(80, 80)。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gradient = context.<span class="title function_">createRadialGradient</span>(<span class="number">55</span>, <span class="number">55</span>, <span class="number">10</span>, <span class="number">55</span>, <span class="number">55</span>, <span class="number">30</span>); </span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&quot;white&quot;</span>); </span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&quot;black&quot;</span>); </span><br><span class="line"><span class="comment">// 绘制红色矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"><span class="comment">// 绘制渐变矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = gradient; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>因为创建起来要复杂一些，所以径向渐变比较难处理。不过，通常情况下，起点和终点的圆形都是同心圆，只要定义好圆心坐标，剩下的就是调整各自半径的问题了。</p>
<h5 id="18-3-9图案"><a href="#18-3-9图案" class="headerlink" title="18.3.9图案"></a>18.3.9图案</h5><p>图案是用于填充和描画图形的重复图像。要创建新图案，可以调用 createPattern()方法并传入两个参数：一个 HTML img元素和一个表示该如何重复图像的字符串。第二个参数的值与 CSS 的background-repeat 属性是一样的，包括”repeat”、”repeat-x”、”repeat-y”和”no-repeat”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="variable language_">document</span>.<span class="property">images</span>[<span class="number">0</span>], </span><br><span class="line"> pattern = context.<span class="title function_">createPattern</span>(image, <span class="string">&quot;repeat&quot;</span>); </span><br><span class="line"><span class="comment">// 绘制矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = pattern; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br></pre></td></tr></table></figure>

<p>记住，跟渐变一样，图案的起点实际上是画布的原点(0, 0)。将填充样式设置为图案，表示在指定位置而不是开始绘制的位置显示图案。</p>
<p>传给 createPattern()方法的第一个参数也可以是img元素或者另一个元素。</p>
<h5 id="18-3-10图像数据"><a href="#18-3-10图像数据" class="headerlink" title="18.3.10图像数据"></a>18.3.10图像数据</h5><p>2D 上下文中比较强大的一种能力是可以使用 getImageData()方法获取原始图像数据。这个方法接收 4 个参数：要取得数据中第一个像素的左上角坐标和要取得的像素宽度及高度。例如，要从(10, 5)开始取得 50 像素宽、50 像素高的区域对应的数据，可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imageData = context.<span class="title function_">getImageData</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>返回的对象是一个 ImageData 的实例。每个 ImageData 对象都包含 3 个属性：width、height和 data，其中，data 属性是包含图像的原始像素信息的数组。每个像素在 data 数组中都由 4 个值表示，分别代表红、绿、蓝和透明度值。换句话说，第一个像素的信息包含在第 0 到第 3 个值中，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = imageData.<span class="property">data</span>, </span><br><span class="line">red = data[<span class="number">0</span>], </span><br><span class="line">green = data[<span class="number">1</span>], </span><br><span class="line">blue = data[<span class="number">2</span>], </span><br><span class="line">alpha = data[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>这个数组中的每个值都在 0~255 范围内（包括 0 和 255）。对原始图像数据进行访问可以更灵活地操作图像。例如，通过更改图像数据可以创建一个简单的灰阶过滤器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>), </span><br><span class="line"> image = <span class="variable language_">document</span>.<span class="property">images</span>[<span class="number">0</span>], </span><br><span class="line"> imageData, data, </span><br><span class="line"> i, len, average, </span><br><span class="line"> red, green, blue, alpha; </span><br><span class="line"> <span class="comment">// 绘制图像</span></span><br><span class="line"> context.<span class="title function_">drawImage</span>(image, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"> <span class="comment">// 取得图像数据</span></span><br><span class="line"> imageData = context.<span class="title function_">getImageData</span>(<span class="number">0</span>, <span class="number">0</span>, image.<span class="property">width</span>, image.<span class="property">height</span>); </span><br><span class="line"> data = imageData.<span class="property">data</span>; </span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>, len=data.<span class="property">length</span>; i &lt; len; i+=<span class="number">4</span>) &#123; </span><br><span class="line"> red = data[i]; </span><br><span class="line"> green = data[i+<span class="number">1</span>]; </span><br><span class="line"> blue = data[i+<span class="number">2</span>]; </span><br><span class="line"> alpha = data[i+<span class="number">3</span>]; </span><br><span class="line"> <span class="comment">// 取得 RGB 平均值</span></span><br><span class="line"> average = <span class="title class_">Math</span>.<span class="title function_">floor</span>((red + green + blue) / <span class="number">3</span>); </span><br><span class="line"> <span class="comment">// 设置颜色，不管透明度</span></span><br><span class="line"> data[i] = average; </span><br><span class="line"> data[i+<span class="number">1</span>] = average; </span><br><span class="line"> data[i+<span class="number">2</span>] = average; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 将修改后的数据写回 ImageData 并应用到画布上显示出来</span></span><br><span class="line"> imageData.<span class="property">data</span> = data; </span><br><span class="line"> context.<span class="title function_">putImageData</span>(imageData, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子首先在画布上绘制了一个图像，然后又取得了其图像数据。for 循环遍历了图像数据中的每个像素，注意每次循环都要给 i 加上 4。每次循环中取得红、绿、蓝的颜色值，计算出它们的平均值。然后再把原来的值修改为这个平均值，实际上相当于过滤掉了颜色信息，只留下类似亮度的灰度信息。之后将 data 数组重写回 imageData 对象。最后调用 putImageData()方法，把图像数据再绘制到画布上。结果就得到了原始图像的黑白版。</p>
<p>注意 只有在画布没有加载跨域内容时才可以获取图像数据。如果画布上绘制的是跨域内容，则尝试获取图像数据会导致 JavaScript 报错。</p>
<h5 id="18-3-11合成"><a href="#18-3-11合成" class="headerlink" title="18.3.11合成"></a>18.3.11合成</h5><p>2D上下文中绘制的所有内容都会应用两个属性：globalAlpha 和 globalComposition Operation，其中，globalAlpha 属性是一个范围在 0~1 的值（包括 0 和 1），用于指定所有绘制内容的透明度，默认值为 0。如果所有后来的绘制都需要使用同样的透明度，那么可以将 globalAlpha 设置为适当的值，&#x3D;执行绘制，然后再把 globalAlpha 设置为 0。比如：</p>
<blockquote>
<p>注意这里书上说的是默认值是0,但是我尝试他的默认值应该是1；</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制红色矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"><span class="comment">// 修改全局透明度</span></span><br><span class="line">context.<span class="property">globalAlpha</span> = <span class="number">0.5</span>; </span><br><span class="line"><span class="comment">// 绘制蓝色矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(0,0,255,1)&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"><span class="comment">// 重置</span></span><br><span class="line">context.<span class="property">globalAlpha</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，蓝色矩形是绘制在红色矩形上面的。因为在绘制蓝色矩形前 globalAlpha 被设置成了 0.5，所以蓝色矩形就变成半透明了，从而可以透过它看到下面的红色矩形。</p>
<p>globalCompositionOperation属性表示新绘制的形状如何与上下文中已有的形状融合。这个属性是一个字符串，可以取下列值。</p>
<ul>
<li> source-over：默认值，新图形绘制在原有图形上面。</li>
<li> source-in：新图形只绘制出与原有图形重叠的部分，画布上其余部分全部透明。</li>
<li> source-out：新图形只绘制出不与原有图形重叠的部分，画布上其余部分全部透明。</li>
<li> source-atop：新图形只绘制出与原有图形重叠的部分，原有图形不受影响。</li>
<li> destination-over：新图形绘制在原有图形下面，重叠部分只有原图形透明像素下的部分可见。</li>
<li> destination-in：新图形绘制在原有图形下面，画布上只剩下二者重叠的部分，其余部分完全透明。</li>
<li> destination-out：新图形与原有图形重叠的部分完全透明，原图形其余部分不受影响。</li>
<li> destination-atop：新图形绘制在原有图形下面，原有图形与新图形不重叠的部分完全透明。</li>
<li> lighter：新图形与原有图形重叠部分的像素值相加，使该部分变亮。</li>
<li> copy：新图形将擦除并完全取代原有图形。</li>
<li> xor：新图形与原有图形重叠部分的像素执行“异或”计算。</li>
</ul>
<p>以上合成选项的含义很难用语言来表达清楚，只用黑白图像也体现不出所有合成的效果。下面来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制红色矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"><span class="comment">// 设置合成方式</span></span><br><span class="line">context.<span class="property">globalCompositeOperation</span> = <span class="string">&quot;destination-over&quot;</span>; </span><br><span class="line"><span class="comment">// 绘制蓝色矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(0,0,255,1)&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>使用 globalCompositeOperation 属性时，一定记得要在不同浏览器上进行测试。不同浏览器在实现这些选项时可能存在差异。这些操作在 Safari 和 Chrome 中仍然有些问题，可以参考 MDN 文档上的CanvasRenderingContext2D.globalCompositeOperation，比较它们与 IE 或 Firefox 渲染的差异。</p>
<h4 id="18-4WebGL-上下文-了解"><a href="#18-4WebGL-上下文-了解" class="headerlink" title="18.4WebGL 上下文(了解)"></a>18.4WebGL 上下文(了解)</h4><p>如果浏览器不支持 WebGL，则尝试访问 WebGL 上下文会返回 null。在使用上下文之前，应该先检测返回值是否存在：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line">     <span class="keyword">let</span> gl = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;webgl&quot;</span>); </span><br><span class="line">     <span class="keyword">if</span> (gl)&#123; </span><br><span class="line">     	<span class="comment">// 使用 WebGL </span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="WebGL-基础"><a href="#WebGL-基础" class="headerlink" title="WebGL 基础"></a>WebGL 基础</h5><p>取得 WebGL 上下文后，就可以开始 3D 绘图了。可以在调用 getContext()取得 WebGL 上下文时指定一些选项。这些选项通过一个参数对象传入，选项就是参数对象的一个或多个属性。</p>
<ul>
<li> alpha：布尔值，表示是否为上下文创建透明通道缓冲区，默认为 true。</li>
<li> depth：布尔值，表示是否使用 16 位深缓冲区，默认为 true。</li>
<li> stencil：布尔值，表示是否使用 8 位模板缓冲区，默认为 false。</li>
<li> antialias：布尔值，表示是否使用默认机制执行抗锯齿操作，默认为 true。</li>
<li> premultipliedAlpha：布尔值，表示绘图缓冲区是否预乘透明度值，默认为 true。</li>
<li> preserveDrawingBuffer：布尔值，表示绘图完成后是否保留绘图缓冲区，默认为 false。</li>
</ul>
<p>如果调用 getContext()不能创建 WebGL 上下文，某些浏览器就会抛出错误。为此，最好把这个方法调用包装在 try&#x2F;catch 块中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line">     <span class="keyword">try</span> &#123; </span><br><span class="line">     	gl = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;webgl&quot;</span>); </span><br><span class="line">     &#125; <span class="keyword">catch</span> (ex) &#123; </span><br><span class="line">     	<span class="comment">// 什么也不做</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (gl) &#123; </span><br><span class="line">     	<span class="comment">// 使用 WebGL </span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">     	<span class="title function_">alert</span>(<span class="string">&quot;WebGL context could not be created.&quot;</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19：表单脚本"><a href="#19：表单脚本" class="headerlink" title="19：表单脚本"></a>19：表单脚本</h3><h4 id="19-1表单基础"><a href="#19-1表单基础" class="headerlink" title="19.1表单基础"></a>19.1表单基础</h4><p>Web 表单在 HTML 中以form元素表示，在 JavaScript 中则以 HTMLFormElement 类型表示。HTMLFormElement 类型继承自 HTMLElement 类型，因此拥有与其他 HTML 元素一样的默认属性。不过，HTMLFormElement 也有自己的属性和方法 acceptCharset：服务器可以接收的字符集，等价于 HTML 的 accept-charset 属性。</p>
<ul>
<li>action：请求的 URL，等价于 HTML 的 action 属性。</li>
<li>elements：表单中所有控件的 HTMLCollection。</li>
<li>enctype：请求的编码类型，等价于 HTML 的 enctype 属性。</li>
<li>length：表单中控件的数量。</li>
<li>method：HTTP 请求的方法类型，通常是”get”或”post”，等价于 HTML 的 method 属性。</li>
<li>name：表单的名字，等价于 HTML 的 name 属性。</li>
<li>reset()：把表单字段重置为各自的默认值。</li>
<li>submit()：提交表单。</li>
<li>target：用于发送请求和接收响应的窗口的名字，等价于 HTML 的 target 属性。</li>
</ul>
<p>有几种方式可以取得对元素的引用。最常用的是将表单当作普通元素为它指定一个 id 属性，从而可以使用 getElementById()来获取表单，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;form1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此外，使用 document.forms 集合可以获取页面上所有的表单元素。然后，可以进一步使用数字索引或表单的名字（name）来访问特定的表单。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得页面中的第一个表单</span></span><br><span class="line"><span class="keyword">let</span> firstForm = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 取得名字为&quot;form2&quot;的表单</span></span><br><span class="line"><span class="keyword">let</span> myForm = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="string">&quot;form2&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>较早的浏览器，或者严格向后兼容的浏览器，也会把每个表单的 name 作为 document 对象的属性。例如，名为”form2”的表单可以通过 document.form2 来访问。不推荐使用这种方法，因为容易出错，而且这些属性将来可能会被浏览器删除。</p>
<p>注意，表单可以同时拥有 id 和 name，而且两者可以不相同。</p>
<h5 id="19-1-1提交表单"><a href="#19-1-1提交表单" class="headerlink" title="19.1.1提交表单"></a>19.1.1提交表单</h5><p>表单是通过用户点击提交按钮或图片按钮的方式提交的。提交按钮可以使用 type 属性为”submit”的或元素来定义，图片按钮可以使用 type 属性为”image”的元素来定义。点击下面例子中定义的所有按钮都可以提交它们所在的表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通用提交按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit Form&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自定义提交按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit Form<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 图片按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;graphic.gif&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果表单中有上述任何一个按钮，且焦点在表单中某个控件上，则按回车键也可以提交表单。（textarea 控件是个例外，当焦点在它上面时，按回车键会换行。）注意，没有提交按钮的表单在按回车键时不会提交。</p>
<p>以这种方式提交表单会在向服务器发送请求之前触发 submit 事件。这样就提供了一个验证表单数据的机会，可以根据验证结果决定是否真的要提交。阻止这个事件的默认行为可以取消提交表单。例如，下面的代码会阻止表单提交：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 阻止表单提交</span></span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>调用 preventDefault()方法可以阻止表单提交。通常，在表单数据无效以及不应该发送到服务器时可以这样处理。</p>
<p>当然，也可以通过编程方式在 JavaScript 中调用 submit()方法来提交表单。可以在任何时候调用这个方法来提交表单，而且表单中不存在提交按钮也不影响表单提交。下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line"><span class="comment">// 提交表单</span></span><br><span class="line">form.<span class="title function_">submit</span>();</span><br></pre></td></tr></table></figure>

<p>通过 submit()提交表单时，submit 事件不会触发。因此在调用这个方法前要先做数据验证。</p>
<p>表单提交的一个最大的问题是可能会提交两次表单。如果提交表单之后没有什么反应，那么没有耐心的用户可能会多次点击提交按钮。结果是很烦人的（因为服务器要处理重复的请求），甚至可能造成损失（如果用户正在购物，则可能会多次下单）。解决这个问题主要有两种方式：在表单提交后禁用提交按钮，或者通过 onsubmit 事件处理程序取消之后的表单提交。</p>
<h5 id="19-1-2重置表单"><a href="#19-1-2重置表单" class="headerlink" title="19.1.2重置表单"></a>19.1.2重置表单</h5><p>用户单击重置按钮可以重置表单。重置按钮可以使用 type 属性为”reset”的或</p>
<p>元素来创建，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通用重置按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Reset Form&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自定义重置按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>Reset Form<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两种按钮都可以重置表单。表单重置后，所有表单字段都会重置回页面第一次渲染时各自拥有的值。如果字段原来是空的，就会变成空的；如果字段有默认值，则恢复为默认值。</p>
<p>用户单击重置按钮重置表单会触发 reset 事件。这个事件为取消重置提供了机会。例如，以下代码演示了如何阻止重置表单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&quot;reset&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>与表单提交一样，重置表单也可以通过 JavaScript 调用 reset()方法来完成，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line"><span class="comment">// 重置表单</span></span><br><span class="line">form.<span class="title function_">reset</span>();</span><br></pre></td></tr></table></figure>

<p>与 submit()方法的功能不同，调用 reset()方法会像单击了重置按钮一样触发 reset 事件。</p>
<p>注意 表单设计中通常不提倡重置表单，因为重置表单经常会导致用户迷失方向，如果意外触发则会令人感到厌烦。实践中几乎没有重置表单的需求。一般来说，提供一个取消按钮，让用户点击返回前一个页面，而不是恢复表单中所有的值来得更直观。</p>
<h5 id="19-1-3表单字段"><a href="#19-1-3表单字段" class="headerlink" title="19.1.3表单字段"></a>19.1.3表单字段</h5><p>表单元素可以像页面中的其他元素一样使用原生 DOM 方法来访问。此外，所有表单元素都是表单elements 属性（元素集合）中包含的一个值。这个 elements 集合是一个有序列表，包含对表单中所有字段的引用，包括所有、、、和元素。elements集合中的每个字段都以它们在 HTML 标记中出现的次序保存，可以通过索引位置和 name 属性来访问。以下是几个例子： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;form1&quot;</span>);</span><br><span class="line"><span class="comment">// 取得表单中的第一个字段</span></span><br><span class="line"><span class="keyword">let</span> field1 = form.<span class="property">elements</span>[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 取得表单中名为&quot;textbox1&quot;的字段</span></span><br><span class="line"><span class="keyword">let</span> field2 = form.<span class="property">elements</span>[<span class="string">&quot;textbox1&quot;</span>];</span><br><span class="line"><span class="comment">// 取得字段的数量</span></span><br><span class="line"><span class="keyword">let</span> fieldCount = form.<span class="property">elements</span>.<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<p>如果多个表单控件使用了同一个 name，比如像单选按钮那样，则会返回包含所有同名元素的HTMLCollection。比如，来看下面的 HTML 代码片段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myForm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Red<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;green&quot;</span>&gt;</span>Green<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>Blue<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个 HTML 中的表单有 3 个单选按钮的 name 是”color”，这个名字把它们联系在了一起。在访问elements[“color”]时，返回的 NodeList 就包含这 3 个元素。而在访问 elements[0]时，只会返回第一个元素。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> colorFields = form.<span class="property">elements</span>[<span class="string">&quot;color&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colorFields.<span class="property">length</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">let</span> firstColorField = colorFields[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> firstFormField = form.<span class="property">elements</span>[<span class="number">0</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstColorField === firstFormField); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>以上代码表明，使用 form.elements[0]获取的表单的第一个字段就是 form.elements[“color”]中包含的第一个元素。</p>
<p>注意 也可以通过表单属性的方式访问表单字段，比如 form[0]这种使用索引和 form [“color”]这种使用字段名字的方式。访问这些属性与访问 form.elements 集合是一样的。这种方式是为向后兼容旧版本浏览器而提供的，实际开发中应该使用 elements。</p>
<p><strong>表单字段的公共属性</strong></p>
<p>除fieldset元素以外，所有表单字段都有一组同样的属性。由于类型可以表示多种表单字段，因此某些属性只适用于特定类型的字段。除此之外的属性可以在任何表单字段上使用。以下列出了这些表单字段的公共属性和方法。</p>
<ul>
<li>disabled：布尔值，表示表单字段是否禁用。</li>
<li>form：指针，指向表单字段所属的表单。这个属性是只读的。</li>
<li>name：字符串，这个字段的名字。</li>
<li>readOnly：布尔值，表示这个字段是否只读。</li>
<li>tabIndex：数值，表示这个字段在按 Tab 键时的切换顺序。</li>
<li>type：字符串，表示字段类型，如”checkbox”、”radio”等。</li>
<li>value：要提交给服务器的字段值。对文件输入字段来说，这个属性是只读的，仅包含计算机上某个文件的路径。</li>
</ul>
<p>这里面除了 form 属性以外，JavaScript 可以动态修改任何属性。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> field = form.<span class="property">elements</span>[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 修改字段的值</span></span><br><span class="line">field.<span class="property">value</span> = <span class="string">&quot;Another value&quot;</span>;</span><br><span class="line"><span class="comment">// 检查字段所属的表单</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(field.<span class="property">form</span> === form); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 给字段设置焦点</span></span><br><span class="line">field.<span class="title function_">focus</span>();</span><br><span class="line"><span class="comment">// 禁用字段</span></span><br><span class="line">field.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 改变字段的类型（不推荐，但对&lt;input&gt;来说是可能的）</span></span><br><span class="line">field.<span class="property">type</span> = <span class="string">&quot;checkbox&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这种动态修改表单字段属性的能力为任何时候以任何方式修改表单提供了方便。举个例子，Web 表单的一个常见问题是用户常常会点击两次提交按钮。在涉及信用卡扣款的情况下，这是个严重的问题，可能会导致重复扣款。对此，常见的解决方案是第一次点击之后禁用提交按钮。可以通过监听 submit事件来实现。比如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免多次提交表单的代码</span></span><br><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> target = event.<span class="property">target</span>;</span><br><span class="line">    <span class="comment">// 取得提交按钮</span></span><br><span class="line">    <span class="keyword">let</span> btn = target.<span class="property">elements</span>[<span class="string">&quot;submit-btn&quot;</span>];</span><br><span class="line">    <span class="comment">// 禁用提交按钮</span></span><br><span class="line">    btn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码在表单的 submit 事件上注册了一个事件处理程序。当 submit 事件触发时，代码会取得提交按钮，然后将其 disabled 属性设置为 true。注意，这个功能不能通过直接给提交按钮添加onclick 事件处理程序来实现，原因是不同浏览器触发事件的时机不一样。有些浏览器会在触发表单的 submit 事件前先触发提交按钮的 click 事件，有些浏览器则会后触发 click 事件。对于先触发click 事件的浏览器，这个按钮会在表单提交前被禁用，这意味着表单就不会被提交了。因此最好使用表单的 submit 事件来禁用提交按钮。但这种方式不适用于没有使用提交按钮的表单提交。如前所述，只有提交按钮才能触发 submit 事件。</p>
<p>type 属性可以用于除fieldset之外的任何表单字段。对于input元素，这个值等于 HTML的 type 属性值。对于其他元素，这个 type 属性的值按照下表设置。</p>
<table>
<thead>
<tr>
<th>描 述</th>
<th>示例 HTML</th>
<th>类型的值</th>
</tr>
</thead>
<tbody><tr>
<td>单选列表</td>
<td>…</td>
<td>“select-one”</td>
</tr>
<tr>
<td>多选列表</td>
<td>…</td>
<td>“select-multiple”</td>
</tr>
<tr>
<td>自定义按钮</td>
<td><button>……</button></td>
<td>“submit”</td>
</tr>
<tr>
<td>自定义非提交按钮</td>
<td><button type="button">…</button></td>
<td>“button”</td>
</tr>
<tr>
<td>自定义重置按钮</td>
<td><button type="reset">…</button></td>
<td>“reset”</td>
</tr>
<tr>
<td>自定义提交按钮</td>
<td><button type="submit">…</button></td>
<td>“submit</td>
</tr>
</tbody></table>
<p>对于input和submit元素，可以动态修改其 type 属性。但元素的 type 属性是只读的。 表单字段的公共方法 每个表单字段都有两个公共方法：focus()和 blur()。 focus()方法把浏览器焦点设置到表单字段，这意味着该字段会变成活动字段并可以响应键盘事件。focus()方法主要用来引起用户对页面中某个部分的注意。 比如，在页面加载后把焦点定位到表单中第一个字段就是很常见的做法。实现方法是监听 load 事件，然后在第一个字段上调用 focus()，如下所示： window.addEventListener(“load”, (event) &#x3D;&gt; {     document.forms[0].elements[0].focus(); });  注意，如果表单中第一个字段是 type 为”hidden”的</p>
<p>元素，或者该字段被 CSS 属性display 或 visibility 隐藏了，以上代码就会出错。</p>
<p>HTML5 为表单字段增加了 autofocus 属性，支持的浏览器会自动为带有该属性的元素设置焦点，而无须使用 JavaScript。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt; input type = <span class="string">&quot;text&quot;</span></span><br><span class="line">autofocus &gt;</span><br></pre></td></tr></table></figure>

<p>为了让之前的代码在使用 autofocus 时也能正常工作，必须先检测元素上是否设置了该属性。如果设置了 autofocus，就不再调用 focus()：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">autofocus</span> !== <span class="literal">true</span>) &#123;</span><br><span class="line">        element.<span class="title function_">focus</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JS focus&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>大多数现代浏览器支持 autofocus 属性</p>
<p>focus()的反向操作是 blur()，其用于从元素上移除焦点。现在很少有用例需要调用 blur()，没有必要的情况下不要做这个骚操作了；</p>
<p><strong>表单字段的公共事件</strong></p>
<p>除了鼠标、键盘、变化和 HTML 事件外，所有字段还支持以下 3 个事件。</p>
<ul>
<li>blur：在字段失去焦点时触发。</li>
<li>change：在和元素的 value 发生变化且失去焦点时触发，或者在元素中选中项发生变化时触发。 </li>
<li>focus：在字段获得焦点时触发。</li>
</ul>
<p>blur 和 focus 事件会因为用户手动改变字段焦点或者调用 blur()或 focus()方法而触发。这两个事件对所有表单都会一视同仁。</p>
<p>change 事件则不然，它会因控件不同而在不同时机触发。</p>
<p>对于和元素，change 事件会在字段失去焦点，同时 value 自控件获得焦点后发生变化时触发。 </p>
<p>对于元素，change 事件会在用户改变了选中项时触发，不需要控件失去焦点。  用途：  focus 和 blur 事件通常用于以某种方式改变用户界面，以提供可见的提示或额外功能（例如在文本框下面显示下拉菜单）。 change 事件通常用于验证用户在字段中输入的内容。比如，有的文本框可能只限于接收数值。  比如，有的文本框可能只限于接收数值。focus 事件可以用来改变控件的背景颜色以便更清楚地表明当前字段获得了焦点。blur 事件可以用于去掉这个背景颜色。而 change 事件可以用于在用户输入了非数值时把背景改为红色。</p>
<p> 注意 blur 和 change 事件的关系并没有明确定义。在某些浏览器中，blur 事件会先于change 事件触发；在其他浏览器中，触发顺序则相反。因此不能依赖这两个事件触发的顺序，必须区分时要多加注意。 </p>
<p>文本框编程 在 HTML 中有两种表示文本框的方式：单行使用input元素，多行使用textarea元素。 </p>
<p>举个例子：要创建一个一次可显示 25 个字符，但最多允许显示 50 个字符的文本框，可以这样写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">size</span>=<span class="string">&quot;25&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;50&quot;</span> <span class="attr">value</span>=<span class="string">&quot;initial value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt; textarea rows = <span class="string">&quot;25&quot;</span></span><br><span class="line">cols = <span class="string">&quot;5&quot;</span> &gt; initial value &lt; /textarea&gt;</span><br></pre></td></tr></table></figure>

<p>除了标记中的不同，这两种类型的文本框都会在 value 属性中保存自己的内容。通过这个属性，可以读取也可以设置文本模式的值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="string">&quot;textbox1&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(textbox.<span class="property">value</span>);</span><br><span class="line">textbox.<span class="property">value</span> = <span class="string">&quot;Some new value&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="19-2文本框编辑"><a href="#19-2文本框编辑" class="headerlink" title="19.2文本框编辑"></a>19.2文本框编辑</h4><h5 id="19-2-1选择文本"><a href="#19-2-1选择文本" class="headerlink" title="19.2.1选择文本"></a>19.2.1选择文本</h5><p>两种文本框都支持一个名为 select()的方法，此方法用于全部选中文本框中的文本。</p>
<p>下面来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="string">&quot;textbox1&quot;</span>];</span><br><span class="line">textbox.<span class="title function_">select</span>();</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<ul>
<li>常见的复制粘贴功能</li>
<li>让用户能够一次性删除所有默认内容</li>
</ul>
<h6 id="select-事件"><a href="#select-事件" class="headerlink" title="select 事件"></a><strong>select 事件</strong></h6><p>触发条件：</p>
<ul>
<li>1，用户自己选择了文本</li>
<li>2，调用了select()方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="string">&quot;textbox1&quot;</span>];</span><br><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;select&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Text selected: <span class="subst">$&#123;textbox.value&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="取得选中文本"><a href="#取得选中文本" class="headerlink" title="取得选中文本"></a><strong>取得选中文本</strong></h6><p>扩展为文本框添加了两个属性：selectionStart 和 selectionEnd。这两个属性包含基于 0 的数值，分别表示文本选区的起点和终点（文本选区起点的偏移量和文本选区终点的偏移量）。因此，要取得文本框中选中的文本，可以使用以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSelectedText</span>(<span class="params">textbox</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> textbox.<span class="property">value</span>.<span class="title function_">substring</span>(textbox.<span class="property">selectionStart</span>, textbox.<span class="property">selectionEnd</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 substring()方法是基于字符串偏移量的，所以直接传入 selectionStart 和 selectionEnd就可以取得选中的文本。</p>
<p>老版本 IE 中有一个包含整个文档中文本选择信息的 document.selection 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSelectedText</span>(<span class="params">textbox</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> textbox.<span class="property">selectionStart</span> == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> textbox.<span class="property">value</span>.<span class="title function_">substring</span>(textbox.<span class="property">selectionStart</span>, textbox.<span class="property">selectionEnd</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">selection</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="property">selection</span>.<span class="title function_">createRange</span>().<span class="property">text</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个修改后的函数兼容在 IE 老版本中取得选中文本。注意 document.selection 是根本不需要textbox 参数的。</p>
<h6 id="部分选中文本"><a href="#部分选中文本" class="headerlink" title="部分选中文本"></a><strong>部分选中文本</strong></h6><p>HTML5 也为在文本框中选择部分文本提供了额外支持。现在，除了 select()方法之外，Firefox最早实现的 setSelectionRange()方法也可以在所有文本框中使用。这个方法接收两个参数：要选择的第一个字符的索引和停止选择的字符的索引（与字符串的 substring()方法一样）。下面是几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">textbox.<span class="property">value</span> = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line"><span class="comment">// 选择所有文本</span></span><br><span class="line">textbox.<span class="title function_">setSelectionRange</span>(<span class="number">0</span>, textbox.<span class="property">value</span>.<span class="property">length</span>); <span class="comment">// &quot;Hello world!&quot; </span></span><br><span class="line"><span class="comment">// 选择前 3 个字符</span></span><br><span class="line">textbox.<span class="title function_">setSelectionRange</span>(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// &quot;Hel&quot; </span></span><br><span class="line"><span class="comment">// 选择第 4~6 个字符</span></span><br><span class="line">textbox.<span class="title function_">setSelectionRange</span>(<span class="number">4</span>, <span class="number">7</span>); <span class="comment">// &quot;o w&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果想看到选择，则必须在调用 setSelectionRange()之前或之后给文本框设置焦点。这个方法在 IE9、Firefox、Safari、Chrome 和 Opera 中都可以使用。</p>
<p>IE8 及更早版本支持通过范围部分选中文本。如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">textbox.<span class="property">value</span> = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> range = textbox.<span class="title function_">createTextRange</span>();</span><br><span class="line"><span class="comment">// 选择所有文本</span></span><br><span class="line">range.<span class="title function_">collapse</span>(<span class="literal">true</span>);</span><br><span class="line">range.<span class="title function_">moveStart</span>(<span class="string">&quot;character&quot;</span>, <span class="number">0</span>);</span><br><span class="line">range.<span class="title function_">moveEnd</span>(<span class="string">&quot;character&quot;</span>, textbox.<span class="property">value</span>.<span class="property">length</span>); <span class="comment">// &quot;Hello world!&quot; </span></span><br><span class="line">range.<span class="title function_">select</span>();</span><br><span class="line"><span class="comment">// 选择前 3 个字符</span></span><br><span class="line">range.<span class="title function_">collapse</span>(<span class="literal">true</span>);</span><br><span class="line">range.<span class="title function_">moveStart</span>(<span class="string">&quot;character&quot;</span>, <span class="number">0</span>);</span><br><span class="line">range.<span class="title function_">moveEnd</span>(<span class="string">&quot;character&quot;</span>, <span class="number">3</span>);</span><br><span class="line">range.<span class="title function_">select</span>(); <span class="comment">// &quot;Hel&quot; </span></span><br><span class="line"><span class="comment">// 选择第 4~6 个字符</span></span><br><span class="line">range.<span class="title function_">collapse</span>(<span class="literal">true</span>);</span><br><span class="line">range.<span class="title function_">moveStart</span>(<span class="string">&quot;character&quot;</span>, <span class="number">4</span>);</span><br><span class="line">range.<span class="title function_">moveEnd</span>(<span class="string">&quot;character&quot;</span>, <span class="number">6</span>);</span><br><span class="line">range.<span class="title function_">select</span>(); <span class="comment">// &quot;o w&quot;</span></span><br></pre></td></tr></table></figure>

<p>与其他浏览器一样，如果想要看到选中的效果，则必须让文本框获得焦点。</p>
<p>部分选中文本对自动完成建议项等高级文本输入框是很有用的。</p>
<h5 id="19-2-2输入过滤"><a href="#19-2-2输入过滤" class="headerlink" title="19.2.2输入过滤"></a>19.2.2输入过滤</h5><h6 id="屏蔽字符"><a href="#屏蔽字符" class="headerlink" title="屏蔽字符"></a><strong>屏蔽字符</strong></h6><p>如果想只屏蔽特定字符，则需要检查事件的 charCode 属性，以确定正确的回应方式。例如，下面就是只允许输入数字的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;keypress&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="regexp">/\d/</span>.<span class="title function_">test</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(event.<span class="property">charCode</span>))) &#123;</span><br><span class="line">                event.<span class="title function_">preventDefault</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这个例子先用String.fromCharCode()把事件的charCode 转换为字符串，再用正则表达式&#x2F;\d&#x2F;来测试。这个正则表达式匹配所有数字字符，如果测试失败就调用 preventDefault()屏蔽事件默认行为。这样就可以让文本框忽略非数字输入。</p>
<p>在Firefox 中，所有触发 keypress 事件的非字符键的 charCode 都是 0，而在 Safari 3 之前这些键的charCode 都是 8。综合考虑这些情况，就是不能屏蔽 charCode 小于 10 的键。为此，上面的函数可以改进为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;keypress&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/\d/</span>.<span class="title function_">test</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(event.<span class="property">charCode</span>)) &amp;&amp; event.<span class="property">charCode</span> &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>还有一个问题需要处理：复制、粘贴及涉及 Ctrl 键的其他功能。在除 IE 外的所有浏览器中，前面代码会屏蔽快捷键 Ctrl+C、Ctrl+V 及其他使用 Ctrl 的组合键。因此，最后一项检测是确保没有按下 Ctrl键，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;keypress&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/\d/</span>.<span class="title function_">test</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(event.<span class="property">charCode</span>)) &amp;&amp; event.<span class="property">charCode</span> &gt; <span class="number">9</span> &amp;&amp; !event.<span class="property">ctrlKey</span>) &#123;</span><br><span class="line">        event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最后这个改动可以确保所有默认的文本框行为不受影响。这个技术可以用来自定义是否允许在文本框中输入某些字符。</p>
<h6 id="处理剪贴板"><a href="#处理剪贴板" class="headerlink" title="处理剪贴板"></a><strong>处理剪贴板</strong></h6><p>以下是与剪贴板相关的 6 个事件。</p>
<ul>
<li>beforecopy：复制操作发生前触发。</li>
<li>copy：复制操作发生时触发。</li>
<li>beforecut：剪切操作发生前触发。</li>
<li>cut：剪切操作发生时触发。</li>
<li>beforepaste：粘贴操作发生前触发。</li>
<li>paste：粘贴操作发生时触发。</li>
</ul>
<p>这是一个比较新的控制剪贴板访问的标准，事件的行为及相关对象会因浏览器而异。在 Safari、Chrome 和 Firefox 中，beforecopy、beforecut 和 beforepaste 事件只会在显示文本框的上下文菜单（预期会发生剪贴板事件）时触发，但 IE 不仅在这种情况下触发，也会在 copy、cut 和 paste 事件之前触发。无论是在上下文菜单中做出选择还是使用键盘快捷键，copy、cut 和 paste 事件在所有浏览器中都会按预期触发。</p>
<p>剪贴板上的数据可以通过 window 对象（IE）或 event 对象（Firefox、Safari 和 Chrome）上的clipboardData 对象来获取。clipboardData 对象上有 3 个方法：getData()、setData()和 clearData();</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getClipboardText</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> clipboardData = (event.<span class="property">clipboardData</span> || <span class="variable language_">window</span>.<span class="property">clipboardData</span>);</span><br><span class="line">    <span class="keyword">return</span> clipboardData.<span class="title function_">getData</span>(<span class="string">&quot;text&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setClipboardText</span>(<span class="params">event, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">clipboardData</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> event.<span class="property">clipboardData</span>.<span class="title function_">setData</span>(<span class="string">&quot;text/plain&quot;</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">clipboardData</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">clipboardData</span>.<span class="title function_">setData</span>(<span class="string">&quot;text&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 getClipboardText()函数相对简单，它只需要知道 clipboardData 对象在哪里，然后便可以通过”text”类型调用 getData()。相应的，setClipboardText()函数则要复杂一些。在确定clipboardData 对象的位置之后，需要根据实现以相应的类型（Firefox、Safari 和 Chrome 是”text&#x2F;plain”，而 IE 是”text”）调用 setData()。</p>
<p>如果文本框期待某些字符或某种格式的文本，那么从剪贴板中读取文本是有帮助的。比如，如果文本框只允许输入数字，那么就必须检查粘贴过来的值，确保其中只包含数字。在 paste 事件中，可以确定剪贴板上的文本是否无效，如果无效就取消默认行为，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;paste&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> text = <span class="title function_">getClipboardText</span>(event);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/^\d*$/</span>.<span class="title function_">test</span>(text)) &#123;</span><br><span class="line">        event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个 onpaste 事件处理程序确保只有数字才能粘贴到文本框中。如果剪贴板中的值不符合指定模式，则取消粘贴操作。Firefox、Safari 和 Chrome 只允许在 onpaste 事件处理程序中访问 getData()方法。</p>
<h5 id="19-2-3自动切换"><a href="#19-2-3自动切换" class="headerlink" title="19.2.3自动切换"></a><strong>19.2.3自动切换</strong></h5><p>JavaScript 可以通过很多方式来增强表单字段的易用性。最常用的是在当前字段完成时自动切换到下一个字段。</p>
<p>在美国，电话号码通常分为 3 个部分：区号、交换局号，外加 4 位数字。在网页中，可以通过 3 个文本框来表示这几个部分，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tel1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtTel1&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tel2&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtTel2&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tel3&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtTel3&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为增加这个表单的易用性并加速数据输入，可以在每个文本框输入到最大允许字符数时自动把焦点切换到下一个文本框。因此，当用户在第一个文本框中输入 3 个字符后，就把焦点移到第二个文本框，当用户在第二个文本框中输入 3 个字符后，把焦点再移到第三个文本框。这种自动切换文本框的行为可以通过如下代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tabForward</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> target = event.<span class="property">target</span>;</span><br><span class="line">    <span class="keyword">if</span> (target.<span class="property">value</span>.<span class="property">length</span> == target.<span class="property">maxLength</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> form = target.<span class="property">form</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = form.<span class="property">elements</span>.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (form.<span class="property">elements</span>[i] == target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (form.<span class="property">elements</span>[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    form.<span class="property">elements</span>[i + <span class="number">1</span>].<span class="title function_">focus</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> inputIds = [<span class="string">&quot;txtTel1&quot;</span>, <span class="string">&quot;txtTel2&quot;</span>, <span class="string">&quot;txtTel3&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">of</span> inputIds) &#123;</span><br><span class="line">    <span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id);</span><br><span class="line">    textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, tabForward);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> textbox1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;txtTel1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> textbox2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;txtTel2&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> textbox3 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;txtTel3&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="19-2-4HTML5-约束验证-API"><a href="#19-2-4HTML5-约束验证-API" class="headerlink" title="19.2.4HTML5 约束验证 API"></a>19.2.4HTML5 约束验证 API</h5><p>HTML5为浏览器新增了在提交表单前验证数据的能力。</p>
<p>验证会根据某些条件应用到表单字段。可以使用 HTML 标记指定对特定字段的约束，然后浏览器会根据这些约束自动执行表单验证。</p>
<h6 id="必填字段"><a href="#必填字段" class="headerlink" title="必填字段"></a><strong>必填字段</strong></h6><p>第一个条件是给表单字段添加 required 属性，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt; input type = <span class="string">&quot;text&quot;</span></span><br><span class="line">name = <span class="string">&quot;username&quot;</span></span><br><span class="line">required &gt;</span><br></pre></td></tr></table></figure>

<p>可以通过JavaScript 检测对应元素的 required 属性来判断表单字段是否为必填：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isUsernameRequired = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="string">&quot;username&quot;</span>].<span class="property">required</span>;</span><br></pre></td></tr></table></figure>

<p>还可以使用下面的代码检测浏览器是否支持 required 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isRequiredSupported = <span class="string">&quot;required&quot;</span> <span class="keyword">in</span> <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;input&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这行代码使用简单的特性检测来确定新创建的元素上是否存在 required 属性。</p>
<p>注意，不同浏览器处理必填字段的机制不同。Firefox、Chrome、IE 和 Opera 会阻止表单提交并在相应字段下面显示有帮助信息的弹框，而 Safari 什么也不做，也不会阻止提交表单。</p>
<h6 id="更多输入类型"><a href="#更多输入类型" class="headerlink" title="更多输入类型"></a><strong>更多输入类型</strong></h6><p>HTML5 为元素增加了几个新的 type 值。其中两个新的输入类型是已经得到广泛支持的”email”和”url”，二者都有浏览器提供的自定义验证。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span> <span class="attr">name</span>=<span class="string">&quot;homepage&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a><strong>数值范围</strong></h6><p>HTML5 还定义了其他几种新的输入元素类型，它们都是期待某种数值输入的，包括：”number”、”range”、”datetime”、”datetime-local”、”date”、”month”、”week”和”time”。并非所有主流浏览器都支持这些类型，因此使用时要当心</p>
<h6 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a><strong>输入模式</strong></h6><p>HTML5 为文本字段新增了 pattern 属性。这个属性用于指定一个正则表达式，用户输入的文本必须与之匹配。</p>
<p>例如，要限制只能在文本字段中输入数字，可以这样添加模式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;\d+&quot;</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意模式的开头和末尾分别假设有^和$。这意味着输入内容必须从头到尾都严格与模式匹配。</p>
<p>通过访问 pattern 属性可以读取模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="string">&quot;count&quot;</span>].<span class="property">pattern</span>;</span><br></pre></td></tr></table></figure>

<p>使用如下代码可以检测浏览器是否支持 pattern 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isPatternSupported = <span class="string">&quot;pattern&quot;</span> <span class="keyword">in</span> <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;input&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="检测有效性"><a href="#检测有效性" class="headerlink" title="检测有效性"></a><strong>检测有效性</strong></h6><p>使用 checkValidity()方法可以检测表单中任意给定字段是否有效。这个方法在所有表单元素上都可以使用，如果字段值有效就会返回 true，否则返回 false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="number">0</span>].<span class="title function_">checkValidity</span>()) &#123;</span><br><span class="line">    <span class="comment">// 字段有效，继续</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 字段无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要检查整个表单是否有效，可以直接在表单上调用 checkValidity()方法。这个方法会在所有字段都有效时返回 true，有一个字段无效就会返回 false：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">checkValidity</span>()) &#123;</span><br><span class="line">    <span class="comment">// 表单有效，继续</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 表单无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>checkValidity()方法只会告诉我们字段是否有效，而 validity 属性会告诉我们字段为什么有效或无效。这个属性是一个对象，包含一系列返回布尔值的属性。</p>
<ul>
<li>customError：如果设置了 setCustomValidity()就返回 true，否则返回 false。</li>
<li>patternMismatch：如果字段值不匹配指定的 pattern 属性则返回 true。</li>
<li>rangeOverflow：如果字段值大于 max 的值则返回 true。</li>
<li>rangeUnderflow：如果字段值小于 min 的值则返回 true。</li>
<li>stepMisMatch：如果字段值与 min、max 和 step 的值不相符则返回 true。</li>
<li>tooLong：如果字段值的长度超过了 maxlength 属性指定的值则返回 true。某些浏览器，如Firefox 4 会自动限制字符数量，因此这个属性值始终为 false。</li>
<li>typeMismatch：如果字段值不是”email”或”url”要求的格式则返回 true。</li>
<li>valid：如果其他所有属性的值都为 false 则返回 true。与 checkValidity()的条件一致。</li>
<li>valueMissing：如果字段是必填的但没有值则返回 true。</li>
</ul>
<p>因此，通过 validity 属性可以检查表单字段的有效性，从而获取更具体的信息，如下面的代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (input.<span class="property">validity</span> &amp;&amp; !input.<span class="property">validity</span>.<span class="property">valid</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input.<span class="property">validity</span>.<span class="property">valueMissing</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Please specify a value.&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.<span class="property">validity</span>.<span class="property">typeMismatch</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Please enter an email address.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Value is invalid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="禁用验证"><a href="#禁用验证" class="headerlink" title="禁用验证"></a><strong>禁用验证</strong></h6><p>通过指定 novalidate 属性可以禁止对表单进行任何验证：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/signup&quot;</span> <span class="attr">novalidate</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表单元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个值也可以通过 JavaScript 属性 noValidate 检索或设置，设置为 true 表示属性存在，设置为false 表示属性不存在：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">noValidate</span> = <span class="literal">true</span>; <span class="comment">// 关闭验证</span></span><br></pre></td></tr></table></figure>

<p>如果一个表单中有多个提交按钮，那么可以给特定的提交按钮添加 formnovalidate 属性，指定通过该按钮无须验证即可提交表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/foo&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表单元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Regular Submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">formnovalidate</span> <span class="attr">name</span>=<span class="string">&quot;btnNoValidate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Non-validating Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，第一个提交按钮会让表单像往常一样验证数据，第二个提交按钮则禁用了验证，可以直接提交表单。我们也可以使用 JavaScript 来设置这个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭验证</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="string">&quot;btnNoValidate&quot;</span>].<span class="property">formNoValidate</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h4 id="19-3选择框编程"><a href="#19-3选择框编程" class="headerlink" title="19.3选择框编程"></a>19.3选择框编程</h4><p>选择框是使用select和option元素创建的。为方便交互，HTMLSelectElement 类型在所有表单字段的公共能力之外又提供了以下属性和方法。</p>
<ul>
<li>add(newOption, relOption)：在 relOption 之前向控件中添加新的option。</li>
<li>multiple：布尔值，表示是否允许多选，等价于 HTML 的 multiple 属性。</li>
<li>options：控件中所有option元素的 HTMLCollection。</li>
<li>remove(index)：移除给定位置的选项。</li>
<li>selectedIndex：选中项基于 0 的索引值，如果没有选中项则为–1。对于允许多选的列表，始终是第一个选项的索引。</li>
<li>size：选择框中可见的行数，等价于 HTML 的 size 属性。</li>
</ul>
<p>选择框的 type 属性可能是”select-one”或”select-multiple”，具体取决于 multiple 属性是否存在。当前选中项根据以下规则决定选择框的 value 属性。</p>
<ul>
<li>如果没有选中项，则选择框的值是空字符串。</li>
<li>如果有一个选中项，且其 value 属性有值，则选择框的值就是选中项 value 属性的值。即使value 属性的值是空字符串也是如此。</li>
<li>如果有一个选中项，且其 value 属性没有指定值，则选择框的值是该项的文本内容。</li>
<li>如果有多个选中项，则选择框的值根据前两条规则取得第一个选中项的值。</li>
</ul>
<p>来看下面的选择框：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">id</span>=<span class="string">&quot;selLocation&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Sunnyvale, CA&quot;</span>&gt;</span>Sunnyvale<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Los Angeles, CA&quot;</span>&gt;</span>Los Angeles<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Mountain View, CA&quot;</span>&gt;</span>Mountain View<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>China<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>Australia<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果选中这个选择框中的第一项，则字段的值就是”Sunnyvale, CA”。如果文本为”China”的项被选中，则字段的值是一个空字符串，因为该项的 value 属性是空字符串。如果选中最后一项，那么字段的值是”Australia”，因为该元素没有指定 value 属性。</p>
<p>每个元素在 DOM 中都由一个 HTMLOptionElement 对象表示。HTMLOptionElement类型为方便数据存取添加了以下属性。</p>
<ul>
<li>index：选项在 options 集合中的索引。</li>
<li>label：选项的标签，等价于 HTML 的 label 属性。</li>
<li>selected：布尔值，表示是否选中了当前选项。把这个属性设置为 true 会选中当前选项。</li>
<li>text：选项的文本。</li>
<li>value：选项的值（等价于 HTML 的 value 属性）。</li>
</ul>
<p>大多数属性是为了方便存取选项数据。可以使用常规 DOM 功能存取这些信息，只是效率比较低，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> selectbox = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="string">&quot;location&quot;</span>];</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">let</span> text = selectbox.<span class="property">options</span>[<span class="number">0</span>].<span class="property">firstChild</span>.<span class="property">nodeValue</span>; <span class="comment">// 选项文本</span></span><br><span class="line"><span class="keyword">let</span> value = selectbox.<span class="property">options</span>[<span class="number">0</span>].<span class="title function_">getAttribute</span>(<span class="string">&quot;value&quot;</span>); <span class="comment">// 选项值</span></span><br></pre></td></tr></table></figure>

<p>以上代码使用标准的 DOM 技术获取了选择框中第一个选项的文本和值。下面再比较一下使用特殊选项属性的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> selectbox = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="string">&quot;location&quot;</span>];</span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">let</span> text = selectbox.<span class="property">options</span>[<span class="number">0</span>].<span class="property">text</span>; <span class="comment">// 选项文本</span></span><br><span class="line"><span class="keyword">let</span> value = selectbox.<span class="property">options</span>[<span class="number">0</span>].<span class="property">value</span>; <span class="comment">// 选项值</span></span><br></pre></td></tr></table></figure>

<p>最后强调一下，选择框的 change 事件与其他表单字段是不一样的。其他表单字段会在自己的值改变后触发 change 事件，然后字段失去焦点。而选择框会在选中一项时立即触发 change 事件。</p>
<h5 id="19-3-1选项处理"><a href="#19-3-1选项处理" class="headerlink" title="19.3.1选项处理"></a>19.3.1选项处理</h5><p>对于只允许选择一项的选择框，获取选项最简单的方式是使用选择框的 selectedIndex 属性，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> selectedOption = selectbox.<span class="property">options</span>[selectbox.<span class="property">selectedIndex</span>];</span><br></pre></td></tr></table></figure>

<p>这样可以获取关于选项的所有信息，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> selectedIndex = selectbox.<span class="property">selectedIndex</span>;</span><br><span class="line"><span class="keyword">let</span> selectedOption = selectbox.<span class="property">options</span>[selectedIndex];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Selected index: <span class="subst">$&#123;selectedIndex&#125;</span>\n`</span> +</span><br><span class="line">    <span class="string">`Selected text: <span class="subst">$&#123;selectedOption.text&#125;</span>\n`</span> +</span><br><span class="line">    <span class="string">`Selected value: <span class="subst">$&#123;selectedOption.value&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码打印出了选中项的索引及其文本和值。</p>
<p>对于允许多选的选择框，selectedIndex 属性就像只允许选择一项一样。设置 selectedIndex会移除所有选项，只选择指定的项，而获取 selectedIndex 只会返回选中的第一项的索引。</p>
<p>如何取得多选的值：通过 selected 属性可以确定选择框中哪个选项被选中。要取得所有选中项，需要循环选项集合逐一检测 selected 属性，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSelectedOptions</span>(<span class="params">selectbox</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> option <span class="keyword">of</span> selectbox.<span class="property">options</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (option.<span class="property">selected</span>) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(option);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="19-3-2添加选项"><a href="#19-3-2添加选项" class="headerlink" title="19.3.2添加选项"></a>19.3.2添加选项</h5><p>可以使用 JavaScript 动态创建选项并将它们添加到选择框。</p>
<p>方法一：可以使用 DOM 方法，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newOption = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;option&quot;</span>);</span><br><span class="line">newOption.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Option text&quot;</span>));</span><br><span class="line">newOption.<span class="title function_">setAttribute</span>(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;Option value&quot;</span>);</span><br><span class="line">selectbox.<span class="title function_">appendChild</span>(newOption);</span><br></pre></td></tr></table></figure>

<p>以上代码创建了一个新的元素，使用文本节点添加文本，设置其 value 属性，然后将其添加到选择框。添加到选择框之后，新选项会立即显示出来。</p>
<p>方法二：Option 构造函数创建新选项，这个构造函数是 DOM 出现之前就已经得到浏览器支持的。</p>
<p>Option 构造函数接收两个参数：text 和 value，其中 value 是可选的。虽然这个构造函数通常会创建 Object 的实例，但 DOM 合规的浏览器都会返回一个元素。这意味着仍然可以使用 appendChild()方法把这样创建的选项添加到选择框。比如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newOption = <span class="keyword">new</span> <span class="title class_">Option</span>(<span class="string">&quot;Option text&quot;</span>, <span class="string">&quot;Option value&quot;</span>);</span><br><span class="line">selectbox.<span class="title function_">appendChild</span>(newOption); <span class="comment">// 在 IE8 及更低版本中有问题</span></span><br></pre></td></tr></table></figure>

<p>方法三：使用选择框的 add()方法</p>
<p>DOM 规定这个方法接收两个参数：要添加的新选项和要添加到其前面的参考选项。如果想在列表末尾添加选项，那么第二个参数应该是 null。</p>
<p>DOM 合规的浏览器要求必须传入第二个参数，因此在跨浏览器方法中不能只使用一个参数，传入 undefined 作为第二个参数可以保证在所有浏览器中都将选项添加到列表末尾。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newOption = <span class="keyword">new</span> <span class="title class_">Option</span>(<span class="string">&quot;Option text&quot;</span>, <span class="string">&quot;Option value&quot;</span>);</span><br><span class="line">selectbox.<span class="title function_">add</span>(newOption, <span class="literal">undefined</span>); <span class="comment">// 最佳方案</span></span><br></pre></td></tr></table></figure>

<p>以上代码可以在所有版本的 IE 及 DOM 合规的浏览器中使用。如果不想在最后插入新选项，则应该使用 DOM 技术和 insertBefore()。</p>
<h5 id="19-3-3移除选项"><a href="#19-3-3移除选项" class="headerlink" title="19.3.3移除选项"></a>19.3.3移除选项</h5><p>与添加选项类似，移除选项的方法也不止一种。</p>
<p>方法一：使用 DOM 的 removeChild()方法并传入要移除的选项，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectbox.<span class="title function_">removeChild</span>(selectbox.<span class="property">options</span>[<span class="number">0</span>]); <span class="comment">// 移除第一项</span></span><br></pre></td></tr></table></figure>

<p>方法二：使用选择框的 remove()方法。这个方法接收一个参数，即要移除选项的索引，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectbox.<span class="title function_">remove</span>(<span class="number">0</span>); <span class="comment">// 移除第一项</span></span><br></pre></td></tr></table></figure>

<p>方法三：直接将选项设置为等于 null。这同样也是 DOM 之前浏览器实现的方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectbox.<span class="property">options</span>[<span class="number">0</span>] = <span class="literal">null</span>; <span class="comment">// 移除第一项</span></span><br></pre></td></tr></table></figure>

<p>要清除选择框的所有选项，需要迭代所有选项并逐一移除它们，如下面例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clearSelectbox</span>(<span class="params">selectbox</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> option <span class="keyword">of</span> selectbox.<span class="property">options</span>) &#123;</span><br><span class="line">        selectbox.<span class="title function_">remove</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数可以逐一移除选择框中的每一项。因为移除第一项会自动将所有选项向前移一位，所以这样就可以移除所有选项。</p>
<h5 id="19-3-4移动和重排选项"><a href="#19-3-4移动和重排选项" class="headerlink" title="19.3.4移动和重排选项"></a>19.3.4移动和重排选项</h5><p>DOM 方法则可以直接将某个选项从第一个选择框移动到第二个选择框，只要对相应选项使用 appendChild()方法即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> selectbox1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;selLocations1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> selectbox2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;selLocations2&quot;</span>);</span><br><span class="line">selectbox2.<span class="title function_">appendChild</span>(selectbox1.<span class="property">options</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>要将选项移动到选择框中的特定位置，insertBefore()方法是最合适的。不过，要把选项移动到最后，还是 appendChild()方法比较方便</p>
<p>下面的代码演示了将一个选项在选择框中前移一个位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> optionToMove = selectbox.<span class="property">options</span>[<span class="number">1</span>];</span><br><span class="line">selectbox.<span class="title function_">insertBefore</span>(optionToMove,</span><br><span class="line">    selectbox.<span class="property">options</span>[optionToMove.<span class="property">index</span> - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>这个例子首先获得要移动选项的索引，然后将其插入之前位于它前面的选项之前，其中第二行代码适用于除第一个选项之外的所有选项。下面的代码则可以将选项向下移动一个位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> optionToMove = selectbox.<span class="property">options</span>[<span class="number">1</span>];</span><br><span class="line">selectbox.<span class="title function_">insertBefore</span>(optionToMove,</span><br><span class="line">    selectbox.<span class="property">options</span>[optionToMove.<span class="property">index</span> + <span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<h4 id="19-4表单序列化"><a href="#19-4表单序列化" class="headerlink" title="19.4表单序列化"></a>19.4表单序列化</h4><p>在写代码之前，我们需要理解浏览器如何确定在提交表单时要把什么发送到服务器。</p>
<ul>
<li>字段名和值是 URL 编码的并以和号（&amp;）分隔。</li>
<li>禁用字段不会发送。</li>
<li>复选框或单选按钮只在被选中时才发送。</li>
<li>类型为”reset”或”button”的按钮不会发送。</li>
<li>多选字段的每个选中项都有一个值。</li>
<li>通过点击提交按钮提交表单时，会发送该提交按钮；否则，不会发送提交按钮。类型为”image”的<input>元素视同提交按钮。</li>
<li>select元素的值是被选中option元素的 value 属性。如果option元素没有 value 属性，则该值是它的文本。</li>
</ul>
<h4 id="19-5富文本编辑"><a href="#19-5富文本编辑" class="headerlink" title="19.5富文本编辑"></a>19.5富文本编辑</h4><p>两种方式实现：第一个是iframe, 第二个是contenteditable；</p>
<h5 id="19-5-2与富文本交互"><a href="#19-5-2与富文本交互" class="headerlink" title="19.5.2与富文本交互"></a>19.5.2与富文本交互</h5><p>与富文本编辑器交互的主要方法是使用 document.execCommand()。</p>
<p>第一个方法是 queryCommandEnabled()，此方法用于确定对当前选中文本或光标所在位置是否可以执行相关命令。</p>
<p>另一个方法 queryCommandState()用于确定相关命令是否应用到了当前文本选区。</p>
<p>最后一个方法是 queryCommandValue()，此方法可以返回执行命令时使用的值</p>
<h5 id="19-5-3富文件选择"><a href="#19-5-3富文件选择" class="headerlink" title="19.5.3富文件选择"></a>19.5.3富文件选择</h5><p>在内嵌窗格中使用 getSelection()方法，可以获得富文本编辑器的选区。</p>
<h5 id="19-5-4通过表单提交富文本"><a href="#19-5-4通过表单提交富文本" class="headerlink" title="19.5.4通过表单提交富文本"></a>19.5.4通过表单提交富文本</h5><p>因为富文本编辑是在内嵌窗格中或通过为元素指定 contenteditable 属性实现的，而不是在表单控件中实现，所以富文本编辑器技术上与表单没有关系。这意味着要把富文本编辑的结果提交给服务器，必须手工提取 HTML 并自己提交。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> target = event.<span class="property">target</span>;</span><br><span class="line">    target.<span class="property">elements</span>[<span class="string">&quot;comments&quot;</span>].<span class="property">value</span> =</span><br><span class="line">        frames[<span class="string">&quot;richedit&quot;</span>].<span class="property">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="20：JavaScript-API"><a href="#20：JavaScript-API" class="headerlink" title="20：JavaScript API"></a>20：JavaScript API</h3><p>这一章的内容特别的多，详细的介绍了 <code>JS</code> 的各种 <code>API</code> 使用方式，总共包含了12 类：</p>
<ol>
<li><strong>Atomics 与 SharedArrayBuffer：</strong><ol>
<li>SharedArrayBuffer：用来表示一个通用的、固定长度的原始二进制数据缓冲区</li>
<li>Atomics：强制同一时刻只能对缓冲区执行一个操作，可以让多个上下文安全地读写一个 <code>SharedArrayBuffer</code>。</li>
</ol>
</li>
<li><strong>跨上下文消息：</strong>在不同执行上下文（如不同工作线程或不同源的页面）间传递信息的能力</li>
<li><strong>Encoding API：</strong> 实现字符串与定型数组之间的转换</li>
<li><strong>File API 与 Blob API：</strong> <ol>
<li>File API：文件本身</li>
<li>Blob API：文件数据对象（数据本身）</li>
</ol>
</li>
<li><strong>媒体元素：</strong>即 audio和 video ，从而为浏览器提供了嵌入音频和视频的统一解决方案。</li>
<li><strong>拖放：</strong><ol>
<li>dragstart</li>
<li>drag</li>
<li>dragend</li>
</ol>
</li>
<li><strong>Notifications API：</strong> 用于向用户显示通知</li>
<li><strong>Page Visibility API：</strong> 页面对用户是否可见的信息</li>
<li><strong>Streams API：</strong> 把一个大数据块拆分为多个小数据块分开处理</li>
<li><strong>计时 API：</strong> 检测页面性能指标</li>
<li><strong>Web 组件：</strong>一套用于增强 <code>DOM</code> 行为的工具，包括影子 <code>DOM</code>、自定义元素和 <code>HTML</code> 模板</li>
<li><strong>Web Cryptography API：</strong>一套密码学工具，规范了 <code>JavaScript</code> 如何以安全和符合惯例的方式实现加密</li>
</ol>
<h2 id="三：开发实用技术"><a href="#三：开发实用技术" class="headerlink" title="三：开发实用技术"></a>三：开发实用技术</h2><p>第三部分也是全书中最后一部分的内容。</p>
<h3 id="21：错误处理与调试"><a href="#21：错误处理与调试" class="headerlink" title="21：错误处理与调试"></a>21：错误处理与调试</h3><p>本章的内容主要分为三个部分：</p>
<ol>
<li>理解浏览器错误报告</li>
<li>处理错误</li>
<li>调试 JavaScript 代码</li>
</ol>
<p><strong>理解浏览器错误报告</strong></p>
<p>浏览器的错误报告会 <strong>展示在控制台</strong> 中。</p>
<p>如果想要查看错误，那么需要进入到浏览器的控制台。</p>
<p>而在移动端上，想要查看错误报告，则需要使用到一些其他的工具。这里作者并没有详细给出介绍。只是提出了几个方案：</p>
<ol>
<li>Chrome 的操作步骤参见 Google Developers 网站的文章《Android 设备的远程调试入门》</li>
<li>Safari 的操作步骤参见 Apple Developer 网站的文章“Safari Web Inspector Guide”。</li>
<li>Firefox 常用的调试工具是 Firebug Lite</li>
</ol>
<p><strong>处理错误</strong></p>
<p>在 <code>JS</code> 中想要捕获错误，那么需要通过 <code>tey/catch</code> 的形式进行捕获。</p>
<p>任何可能出错的代码都应该放到 <code>try</code> 块中，而处理错误的代码则放在 <code>catch</code> 块中。如果 <code>try</code> 块中有代码发生错误，代码会立即退出执行，并跳到 <code>catch</code> 块中。<code>catch</code> 块此时接收到一个对象，该对象包含发生错误的相关信息。</p>
<p><code>try/catch</code> 语句中可选的 <code>finally</code> 子句始终运行。</p>
<p>如果 <code>try</code> 块中的代码运行完，则接着执行<code>finally</code> 块中的代码。如果出错并执行 <code>catch</code> 块中的代码，则 finally 块中的代码仍执行。<code>try</code> 或 <code>catch</code> 块无法阻止 <code>finally</code> 块执行，包括 <code>return</code> 语句。</p>
<p><strong>调试 JavaScript 代码</strong></p>
<p>这里作者提供了三种方式：</p>
<ol>
<li>通过 <code>console</code> 进行控制台打印</li>
<li>通过 <code>debugger</code> 关键字调试</li>
<li>通过 <code>throw new Error</code> 抛出错误</li>
</ol>
<h3 id="22：处理-XML-23：JSON"><a href="#22：处理-XML-23：JSON" class="headerlink" title="22：处理 XML + 23：JSON"></a>22：处理 XML + 23：JSON</h3><p>首先咱们先来看一下什么是 <code>XML</code>：</p>
<p><code>XML</code> 被设计用来传输和存储数据（和 <code>JSON</code> 类似）。以上的这段 <code>XML</code> 可以用以下 <code>JSON</code> 表示：</p>
<p>在现在的数据处理中，<code>XML</code> 已经非常少见了，大部分都是通过 <code>JSON</code> 进行处理。</p>
<p>所以说，对于 <code>22</code> 章的内容，咱们没有必要再去学习，直接查看 <code>23章：json</code> 即可。</p>
<p><code>json</code> 是目前主流的数据传输格式，他支持以下几种形式：</p>
<ul>
<li>简单值</li>
<li>对象</li>
<li>数组</li>
</ul>
<p><code>JSON</code> 支持序列化和解析。</p>
<p>所谓序列化指的是：通过 <code>JSON.stringify()</code> 方法，把一个对象变为 <code>json</code> 格式的字符串。</p>
<p>解析指的是：通过 <code>JSON.parse()</code> 方法，把 <code>json</code> 格式的字符串转化为 对象。</p>
<h3 id="24：网络请求与远程资源"><a href="#24：网络请求与远程资源" class="headerlink" title="24：网络请求与远程资源"></a>24：网络请求与远程资源</h3><p>内容主要分成 5 个部分：</p>
<ul>
<li>使用 XMLHttpRequest 对象</li>
<li>处理 XMLHttpRequest 事件</li>
<li>源域 Ajax 限制</li>
<li>Fetch API </li>
<li>WebSocket</li>
</ul>
<p><strong>使用 XMLHttpRequest 对象</strong></p>
<p><code>XMLHttpRequest</code> 简称为 <code>XHR</code>，是处理 <code>ajax</code> 网络请求的基类。</p>
<p>使用 <code>new</code> 关键字得到了 <code>xhr</code> 的实例。</p>
<p><strong>处理 XMLHttpRequest 事件</strong></p>
<p>处理 <code>XHR</code> 事件指的是处理 <strong>进度事件</strong>。</p>
<p>这些事件一共有 6 种：</p>
<ul>
<li><code>loadstart</code>：在接收到响应的第一个字节时触发。</li>
<li><code>progress</code>：在接收响应期间反复触发。</li>
<li><code>error</code>：在请求出错时触发。</li>
<li><code>abort</code>：在调用 <code>abort()</code> 终止连接时触发。</li>
<li><code>load</code>：在成功接收完响应时触发。</li>
<li><code>loadend</code>：在通信完成时，且在 <code>error</code>、<code>abort</code> 或 <code>load</code> 之后触发。</li>
</ul>
<p>想要处理事件，那么可以通过 <code>xhr.</code> 的形式处理</p>
<p><strong>源域 Ajax 限制</strong></p>
<p>通过 <code>XHR</code> 进行 <code>Ajax</code> 通信的一个主要限制是 <strong>跨源安全策略</strong>。默认情况下，<code>XHR</code> 只能访问与发起请求的页面在同一个域内的资源。</p>
<p>而想要解决这个问题，则需要通过 CORS</p>
<p><strong>跨源资源共享</strong>（<code>CORS，Cross-Origin Resource Sharing</code>）定义了 <strong>浏览器与服务器如何实现跨源通信</strong>。</p>
<p>**Fetch API **</p>
<p>直接的 <code>XHR</code> 请求比较复杂，所以也可以通过 &#96;&#96;Fetch API <code> </code> 进行处理。</p>
<p><code>Fetch API</code> 是目前 <code>js</code> 原生支持的 <code>ajax</code> 请求对象。可以返回 <code>promise</code> 的实例：</p>
<p>目前 <code>fetch API</code> 在实际开发中使用并不会多，大多数会通过 <code>axios</code> 进行处理。</p>
<p><strong>WebSocket</strong></p>
<p><code>Web Socket（套接字）</code>的目标是：<strong>通过一个长时连接实现与服务器全双工、双向的通信</strong>。</p>
<p>在 <code>JavaScript</code> 中创建 <code>Web Socket</code> 时，一个 <code>HTTP</code> 请求会发送到服务器以初始化连接。</p>
<p>服务器响应后，连接使用的 HTTP 协议会切换到 Web Socket 协议。</p>
<p>这意味着 <code>Web Socket</code> 不能通过标准 <code>HTTP</code> 服务器实现，而必须使用支持该协议的专有服务器。</p>
<p>接下来咱们来看一段 <code>web socket</code> 的基本代码，分为：</p>
<ol>
<li>创建链接</li>
<li>发送事件</li>
<li>响应事件</li>
</ol>
<h3 id="25：客户端存储"><a href="#25：客户端存储" class="headerlink" title="25：客户端存储"></a>25：客户端存储</h3><p>所谓的客户端存储大致分为三类：</p>
<ul>
<li>cookie </li>
<li>浏览器存储 API </li>
<li>IndexedDB</li>
</ul>
<p><strong>cookie</strong></p>
<p>cookie，最初用于 <strong>在客户端存储会话信息</strong>。</p>
<p>这个规范要求服务器在响应 <code>HTTP</code> 请求时，通过发送 <code>Set-Cookie HTTP</code> 头部包含会话信息</p>
<p>**浏览器存储 API **</p>
<p>所谓浏览器存储 <code>API</code> 指的就是 <code>Web Storage</code>。</p>
<p>这个 <code>Storage</code> 分为：</p>
<ol>
<li><strong>sessionStorage</strong>：只存储会话数据，这意味着数据只会存储到浏览器关闭。</li>
<li><strong>localStorage</strong>：作为在客户端持久存储数据的机制。数据不会跟随浏览器关闭消失。</li>
</ol>
<p><code>sessionStorage</code> 与 <code>localStorage</code> 提供了同样的操作方法，主要有以下四个：</p>
<ul>
<li><code>clear()</code>：删除所有值；不在 Firefox 中实现。</li>
<li><code>getItem(*name*)</code>：取得给定 <em>name</em> 的值。</li>
<li><code>key(*index*)</code>：取得给定数值位置的名称。</li>
<li><code>removeItem(*name*)</code>：删除给定 <em>name</em> 的名&#x2F;值对。</li>
</ul>
<p><strong>IndexedDB</strong></p>
<p>IndexedDB 是浏览器中存储结构化数据的一个方案。用于代替目前已废弃的 Web SQL Database API。</p>
<p>它是类似于 <code>MySQL</code>  的数据库。与传统数据库最大的区别在于， <code>IndexedDB</code> 使用 <strong>对象存储</strong> 而不是表格保存数据。<code>IndexedDB</code> 数据库就是在一个公共命名空间下的一组对象存储，类似于 <code>NoSQL</code> 风格（mongoDB）的实现。</p>
<p>作者在书中详细的介绍了 <code>IndexedDB</code> 的使用，包括：</p>
<ol>
<li>如何创建对象存储</li>
<li>如何开启 事务</li>
<li>如何插入对象</li>
<li>如何使用游标查询</li>
</ol>
<h3 id="26：模块"><a href="#26：模块" class="headerlink" title="26：模块"></a>26：模块</h3><p>本章的内容主要分为四部分：</p>
<ol>
<li>理解模块模式</li>
<li>凑合的模块系统</li>
<li>使用前 ES6 模块加载器</li>
<li>使用 ES6 模块</li>
</ol>
<p><strong>理解模块模式</strong></p>
<p>所谓模块化其实指的就是：<strong>把逻辑分块，各自封装，相互独立，每个块自行决定对外暴露什么，同时自行决定引入执行哪些外部代码</strong>。</p>
<p>这些不同的模块想要连接在一起工作，那么必须有一个 <strong>入口</strong>，也就是代码执行的起点。</p>
<p>图中的箭头表示依赖方向：模块 A 依赖模块 B 和模块 C，模块 B 依赖模块 D 和模块 E，模块 C 依赖模块 E。</p>
<p>因为模块必须在依赖加载完成后才能被加载，所以这个应用程序的入口模块 A 必须在应用程序的其他部分加载后才能执行。</p>
<p><strong>凑合的模块系统</strong></p>
<p>所谓 凑合的模块系统 指的是 <code>IIFE（立即调用函数表达式）</code> 的模块化方式：</p>
<p>这种立即执行函数可以通过外部传参的形式传递参数：</p>
<p><strong>使用前 ES6 模块加载器</strong></p>
<p><code>ES6</code> 之前的模块加载器，指的主要是三部分：</p>
<ol>
<li><code>CommonJS</code></li>
<li><code>AMD</code></li>
<li><code>UMD</code></li>
</ol>
<p>咱们这里主要来看下 <code>CommonJS</code> 就可以。</p>
<p><code>CommonJS</code> 模块语法不能在浏览器中直接运行，主要应用在 <code>node</code> 环境中。</p>
<p><code>CommonJS</code> 模块定义需要使用 <code>require()</code>指定依赖，而使用 <code>exports</code> 对象定义自己的公共 <code>API</code>。</p>
<p><strong>使用 ES6 模块</strong></p>
<p>ES6 模块化咱们在其他的书中讲解过很多次了。这里咱们就不再多说了。给大家把脑图的内容展示即可。</p>
<h3 id="27：工作者线程"><a href="#27：工作者线程" class="headerlink" title="27：工作者线程"></a>27：工作者线程</h3><p>工作者线程是一套比较复杂的内容，大致可以分为四个部分：</p>
<ol>
<li>工作者线程简介</li>
<li>使用专用工作者线程执行后台任务</li>
<li>使用共享的工作者线程</li>
<li>通过服务工作者线程管理请求</li>
</ol>
<p><strong>工作者线程简介</strong></p>
<p><code>JavaScript</code> 环境实际上是运行在托管操作系统中的虚拟环境。</p>
<p>在浏览器中每打开一个页面，就会分配一个它自己的环境。</p>
<p>这样，每个页面都有自己的内存、事件循环、DOM，等等。</p>
<p>每个页面就相当于一个沙盒，不会干扰其他页面。每个页面环境都是 <strong>并行执行</strong> 的。</p>
<p>而工作者线程的作用就是：<strong>让浏览器可以在原始页面环境之外再分配一个完全独立的二级子环境</strong>。这个子环境 <strong>不能</strong> 与依赖单线程交互的 API（如 DOM）互操作，但可以与父环境 <strong>并行执行代码</strong>。简单来说，就是让 <code>JS</code> 拥有了 <strong>类似多线程</strong> 的能力。</p>
<p>工作者线程可以分为三类：</p>
<ol>
<li>专用工作者线程</li>
<li>共享工作者线程</li>
<li>服务工作者线程</li>
</ol>
<p>这三类工作者线程，作者在书中详细的解释了他们的使用方式。但是因为涉及到的内容比较细节，所以说咱们这里就不去详解了。</p>
<h3 id="28：最佳实践"><a href="#28：最佳实践" class="headerlink" title="28：最佳实践"></a>28：最佳实践</h3><p>本书中最后一章的内容，更多的是一些 <strong>思想层面</strong> 的描述。</p>
<p>内容主要有三部分：</p>
<ol>
<li>可维护性</li>
<li>性能</li>
<li>部署</li>
</ol>
<p><strong>可维护性</strong></p>
<p>通常，说代码“可维护”就意味着它具备如下特点：</p>
<ul>
<li>容易理解：无须求助原始开发者，任何人一看代码就知道它是干什么的，以及它是怎么实现的。</li>
<li>符合常识：代码中的一切都显得顺理成章，无论操作有多么复杂。</li>
<li>容易适配：即使数据发生变化也不用完全重写。</li>
<li>容易扩展：代码架构经过认真设计，支持未来扩展核心功能。</li>
<li>容易调试：出问题时，代码可以给出明确的信息，通过它能直接定位问题。</li>
</ul>
<p>而想要实现这五点，则需要从 <strong>编码规范</strong> 和 <strong>松散解耦</strong> 两个方向入手。</p>
<p>所谓编码规范指的就是：<strong>一套规定代码如何编写的方案</strong>。这个方案不同的企业可能会有细微差异。</p>
<p>而松散解耦指的就是：<strong>不要让代码过于耦合</strong>。</p>
<p><strong>性能</strong></p>
<p>关于性能的优化，作者主要提出了四个方面：</p>
<ol>
<li>作用域意识：访问全局变量始终比访问局部变量慢，因为必须遍历作用域链。任何可以缩短遍历作用域链时间的举措都能提升代码性能</li>
<li>选择正确的方法：使用最优的计算方法（感觉像废话）。在这里作者介绍了几种方式，比如：简化终止条件、简化循环体、使用后测试循环。但是想要达到这些条件，需要开发者拥有比较好的算法基础。</li>
<li>语句最少化：语句的数量影响操作执行的速度。一条可以执行多个操作的语句，比多条语句中每个语句执行一个操作要快。</li>
<li>优化 DOM 交互：涉及 DOM 操作的部分是最慢的，所以想要提升性能则尽量减少 DOM 操作</li>
</ol>
<p><strong>部署</strong></p>
<p>所谓部署就是把 <code>web 应用程序</code> 发布到线上环境。</p>
<p>整体流程大致分为三步：</p>
<ol>
<li>构建：把代码进行打包。可以使用 <code>webpack</code> 等打包工具进行。</li>
<li>验证：这些错误主要指的是一些 <strong>运行时的错误</strong> 或 <strong>语法错误</strong> 。</li>
<li>压缩：指的就是代码压缩。比如可以删除一些 <strong>空格、换行、注释</strong> 的内容。这些内容都会影响最终代码的大小。</li>
</ol>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>License</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>READ NEXT</span></section><section class="body fs14"><a id="next" href="/2023/03/19/Express%E4%B8%8EMongodb/">Express与Mongodb<span class="note">Older</span></a><div class="line"></div><a id="prev" href="/2024/03/31/React%E6%80%BB%E7%BB%93/">React总结<span class="note">Newer</span></a></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</p>
<p>This site was deployed by <a href="http://example.com/">@李阳滨</a> using <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0" title="v1.8.0">Stellar</a>.</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0';
  stellar.config = {
    date_suffix: {
      just: 'Just',
      min: 'minutes ago',
      hour: 'hours ago',
      day: 'days ago',
      month: 'months ago',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://fastly.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://fastly.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://fastly.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
